{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-5630-encryption-and-decryption/10761",
            "title": "EIP-5630: Encryption and Decryption ",
            "index": 10761,
            "category": [
                "EIPs"
            ],
            "tags": [
                "NONE"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "1",
                    "likes": "4",
                    "time": "08/09/2022-23:22:22",
                    "content": "Opening the discussion for EIP-5630; see edit: link to the EIP: ERC-5630: New approach for encryption / decryption ",
                    "links": [
                        "https://ethereum-magicians.org/t/private-key-encapsulation-to-move-around-securely-without-entering-seed/11604/5"
                    ],
                    "GPT-summary": "The author is introducing a new proposal, EIP-5630, and is opening a discussion for it. They provide a link to the proposal and are seeking feedback on it.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Privacy, Security and risk management",
                        "Interoperability and Scaleability",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.681818181818182
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/darcys22",
                    "index": "2",
                    "likes": "3",
                    "time": "10/09/2022-06:34:33",
                    "content": "I love this idea, a pretty big thing i wanted for ERC5570 was to encrypt the receipts so they were private. So wanted a way for a business to encrypt the metadata of an nft against the owners address. This implementation seems to separate the decryption key, this is great because it would mean you could provide the decrypting key to an external financial system without giving it the ability to sign transactions and send fund. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.61875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "3",
                    "likes": "0",
                    "time": "10/09/2022-12:18:30",
                    "content": "exactly! and yes, you\u2019re correct that the decryption key is separated. appreciate the feedback. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.78125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "4",
                    "likes": "1",
                    "time": "19/09/2022-14:41:42",
                    "content": "Is retrieving a recipient\u2019s public key out of scope for this EIP? If so, would you be open to working on a standard for doing that as well? I\u2019ve been toying with the idea of publishing PGP keys to ENS. Perhaps something like that would work. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "5",
                    "likes": "1",
                    "time": "19/09/2022-15:52:01",
                    "content": "good question. retrieving the public key is very much in scope, and is in fact spec\u2019d out in the EIP. edit what\u2019s spec\u2019d is a local RPC routine to retrieve your own public key. what you then do with that\u2014e.g., whether you publish it to ENS, or something else\u2014is not (currently) in scope. perhaps there should be a separate EIP to dictate how exactly that key gets serialized and published to ENS? I\u2019m pretty sure PGP keys are RSA; we are opting to use secp256k1 keys instead. this is essentially for cryptographic and compatibility reasons. but other than that\u2014yes, publishing these to ENS would be absolutely a good idea! let me know if you have questions. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.034375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Pandapip1",
                    "index": "6",
                    "likes": "0",
                    "time": "19/09/2022-16:20:43",
                    "content": "    firnprotocol:  I\u2019m pretty sure PGP keys are RSA;   If you want to use GPG keys instead, those support many more schemes - including ECDSA ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.1875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "7",
                    "likes": "0",
                    "time": "19/09/2022-16:40:00",
                    "content": "hmm. it would be intriguing to make our decrypt spec exactly match what GPG does. if possible. GPG says that they support \u201cECDH\u201d over secp256k1. (this is confusing, since, ECDH is a key agreement scheme, not an encryption scheme. so I assume they actually mean ECIES?) ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.947916666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "8",
                    "likes": "0",
                    "time": "19/09/2022-16:56:17",
                    "content": "update: as far as I can tell, GPG doesn\u2019t support full-on ECIES, only ECDH. so drop-in replacement might not be viable. moreover, it appears that their ECDH spec makes some weird choices, including a KDF which differs from [SEC 1, \u00a7 3.1.6] (in particular, they put the 4 counter bytes on the left of the message, instead of on the right). so not sure how fruitful this direction is. note that implementing SEC 1-compliant ECIES \u201cfrom scratch\u201d is not difficult; we\u2019ve already built a reference implementation at GitHub - firnprotocol/eth-sig-util at encryption (using a very good existing library). so, to put it simply, i think the idea is absolutely the right one, but whether we \u201cformally\u201d can agree with GPG is hard to say. in any case, you can get the same functionality regardless. ",
                    "links": [
                        "https://github.com/firnprotocol/eth-sig-util/tree/encryption"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.298883928571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "9",
                    "likes": "0",
                    "time": "19/09/2022-20:47:58",
                    "content": "ECDH is being used to setup a symmetrical encryption key rather than using asymmetric encryption (ECDH) since asymmetric is notoriously slow in comparison when encrypting large messages and hits other cryptographic limitations that aren\u2019t traditionally faced. I still don\u2019t believe the current design here is a good fit as it\u2019s only a one way encryption scheme meant only to encrypt messages from the dApp to the wallet. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.444642857142857
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "10",
                    "likes": "0",
                    "time": "19/09/2022-20:48:57",
                    "content": "When you say a \u201crecipient\u2019s key\u201d who would be playing the role of a recipient? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "11",
                    "likes": "0",
                    "time": "19/09/2022-20:50:11",
                    "content": "Can we take a step back here and align on what use case we\u2019re trying to solve and what\u2019s the threat model we\u2019re trying to address? I don\u2019t think we\u2019ve got alignment on that yet. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "12",
                    "likes": "0",
                    "time": "19/09/2022-21:07:14",
                    "content": "    kdenhartog:  I still don\u2019t believe the current design here is a good fit as it\u2019s only a one way encryption scheme meant only to encrypt messages from the dApp to the wallet.   I\u2019m truly at a loss to understand your objection, to be honest. All public-key encryption schemes are \u201cone-way\u201d, by definition. And no, encryption from dApp to wallet is not the only intended use here. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.214285714285714
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "13",
                    "likes": "0",
                    "time": "19/09/2022-21:16:02",
                    "content": "    kdenhartog:  I still don\u2019t believe the current design here is a good fit as it\u2019s only a one way encryption scheme meant only to encrypt messages from the dApp to the wallet.   Ah, I see. So this EIP is more about creating a secure keystore than it is about general purpose encrypted messaging. The note about e2e encrypted messaging threw me off.     kdenhartog:  When you say a \u201crecipient\u2019s key\u201d who would be playing the role of a recipient?   I\u2019m imagining the scenario where you want to send me an encrypted message without having communicated beforehand. I would be the recipient. In light of my new understanding above, I guess the pattern would be to:  Create a new public/private key pair. Publish the public key using some other EIP (maybe using ENS.) Request an encryption key using eth_getEncryptionPublicKey. Encrypt the private key created in (1) using the the key from (3). Publish the encrypted private key using some other EIP.  Then anyone wanting to message me could retrieve my public key from ENS, and send the message. I could read the message by fetching my encrypted private key, decrypting using eth_decrypt, and then decrypting the message. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.4579124579124585
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "14",
                    "likes": "0",
                    "time": "19/09/2022-21:23:34",
                    "content": "    SamWilsn:  Ah, I see. So this EIP is more about creating a secure keystore than it is about general purpose encrypted messaging. The note about e2e encrypted messaging threw me off.   That is not the intention\u2014we do want to be able to support e2e messaging here.     SamWilsn:  In light of my new understanding above, I guess the pattern would be to:  Create a new public/private key pair. Publish the public key using some other EIP (maybe using ENS.) Request an encryption key using eth_getEncryptionPublicKey. Encrypt the private key created in (1) using the the key from (3). Publish the encrypted private key using some other EIP.  Then anyone wanting to message me could retrieve my public key from ENS, and send the message. I could read the message by fetching my encrypted private key, decrypting using eth_decrypt , and then decrypting the message.   I think this is more complicated than you need! here would be the flow:  locally call eth_getEncryptionPublicKey; obtain a public encryption key. post that key to your ENS.  then whenever anyone wants to encrypt to you, they retrieve the public key from your ENS, encrypt locally, and then send the ciphertext to you. you decrypt using eth_decrypt. no need to generate a separate keypair, and encrypt its secret key. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.221103896103896
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "15",
                    "likes": "2",
                    "time": "19/09/2022-21:24:03",
                    "content": " And no , encryption from dApp to wallet is not the only intended use here.  Cool let\u2019s start by listing off the ones that we\u2019re working for here because in my experience building 2 versions of an asynchronous messaging protocol (DIDComm V1 and V2) we\u2019re going to go around and around in circles on this if we don\u2019t define this first. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "16",
                    "likes": "0",
                    "time": "19/09/2022-21:35:33",
                    "content": "sure. i think our preliminary list of target use cases can be:  encrypt/decrypt from a dApp to a user\u2019s wallet. end-to-end encrypted messaging.  (1) we\u2019ve already discussed\u2014but I think we\u2019re also fully equipped to support (2) in this EIP too (if you think otherwise, let me know why). namely, the flow would be as suggested above:     firnprotocol:   locally call eth_getEncryptionPublicKey; obtain a public encryption key. post that key to your ENS.  then whenever anyone wants to encrypt to you, they retrieve the public key from your ENS, encrypt locally, and then send the ciphertext to you. you decrypt using eth_decrypt.   let me know your thoughts. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.3500000000000005
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "17",
                    "likes": "0",
                    "time": "19/09/2022-21:42:41",
                    "content": "    firnprotocol:  then send the ciphertext to you   as far as the details of how to \u201csend\u201d: though it\u2019s probably out of scope for this EIP (and might be worth a separate EIP), one way to do it would be to create a simple contract (or extend ENS) with a mapping (address => bytes[]), essentially associating to each address / ENS name an arbitrary-length, append-only list of ciphertexts. anybody could freely append a ciphertext, i.e. a bytes, to this list\u2014it\u2019d be the \u201cinbox\u201d for that ENS. then the user can trivially go through this list and locally eth_decrypt each new message it gets. there could even be a fun extension where you have to pay someone to send them a message. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.7727272727272725
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "18",
                    "likes": "0",
                    "time": "20/09/2022-02:02:48",
                    "content": "  encrypt/decrypt from a dApp to a user\u2019s wallet. end-to-end encrypted messaging.   Some other cases to consider: For end-to-end encrypted messaging or are we doing 1 to 1 messaging only or group messaging and what size groups are we thinking here? Are we expecting both parties to be online (synchronous communication) or are we planning for some parties to be offline (async communication)? Ok, now just taking these two uses cases let\u2019s start to build a threat model for this. Some things to consider: Is dApp to wallet communication bi-directional (any party can encrypt a message from one to another) or uni-directional (e.g. only one party can encrypt a message for another)? Follow up discussion for this:  How do we handle key discovery for these parties whether bi-directional or uni-directional? How does key rotation occur? With signing crypto operations limits of keys are much larger if there are any to the point they can largely be ignored. With ECIES though we\u2019re limited based on the cipher chosen.  How are nonces being coordinated to prevent nonce reuse attacks if AES-CTR or AES-GCM is used? How are we transporting these ciphertexts and what sort of adversarial actors are we looking to avoid here? Are we attempting to achieve perfect forward secrecy, weak perfect forward secrecy, or post compromise security? What integrity guarantees are we looking to achieve? What\u2019s the average size of a message we\u2019re expecting? 100KB/10MB/1GB  Are we wanting to store these messages as well?  If so are we planning to re-encrypt the message once received or are we going to store it as received? Are we planning to publish them to the chain? Doesn\u2019t that introduce gas fees? What if a user doesn\u2019t pick the message up by the time the block gets pruned? What if a key is broken or an implementation vulnerability is discovered later so that the ciphertext is able to be decrypted later?  What\u2019s our adversarial privacy threat model look like since we want to provide confidentiality guarantees?  How are we linking the controller of a key to the subject of the ethereum account (do we even care who the subject is?) to know that the identity is trusted and someone we want to share information with? What time frame are we trying to keep the plaintext message confidential?  These are just some of the questions we should be aligning on first before we start working on a solution here because each of these is going to lead to a different type of solution. Furthermore the more use cases we try to address at once the more likely we\u2019re going to end up with a far more complex solution. For example, take a look at Message Layer Security (MLS) to see how complex group messaging can become. ",
                    "links": [
                        "https://messaginglayersecurity.rocks/"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.501587301587302
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "19",
                    "likes": "0",
                    "time": "20/09/2022-02:07:32",
                    "content": "Even with DIDComm V2 we ended up with a lot of optionality that\u2019s pretty hard to parse through and that decided to exclude group messaging beyond the scope of a single DID. Additionally, given walletconnect is looking to address the E2E messaging case, would it make sense for us to remain focused on just dApp to wallet communication? ",
                    "links": [
                        "https://www.businesswire.com/news/home/20220720005034/en/WalletConnect-Unveils-the-Future-of-Web3-Chat-With-Wallet-to-Wallet-Messaging-Preview"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.811507936507937
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "20",
                    "likes": "0",
                    "time": "20/09/2022-19:24:03",
                    "content": "thank you for the questions. i want to please ask that we limit the scope of this discussion to this EIP, which specifies a way to do simple encryption and decryption. while most of your questions are legitimate, they are concerns for the builders of applications, and lie beyond the scope of this EIP.     kdenhartog:  How do we handle key discovery for these parties whether bi-directional or uni-directional?   though it\u2019s out of scope, one way would be to use ENS (by adding a \u201cpublic key\u201d field), or something like it.     kdenhartog:  How does key rotation occur? With signing crypto operations limits of keys are much larger if there are any to the point they can largely be ignored. With ECIES though we\u2019re limited based on the cipher chosen.   the message length limitation is only per message, and has nothing to do with encrypting many different messages under the same key. moreover, CBC mode appears to have no length limit. if you want to adopt a key rotation strategy, that\u2019s up to you\u2014same as in the case of signing.     kdenhartog:  How are nonces being coordinated to prevent nonce reuse attacks if AES-CTR or AES-GCM is used?   note that we propose CBC mode. the determination of IV is fully specified by the spec; as for the generation of random ephemeral keys, this is handled by the spec and by the implementation.     kdenhartog:  How are we transporting these ciphertexts and what sort of adversarial actors are we looking to avoid here?   transport of ciphertexts is out of scope (though could optionally be done on-chain; see my comments above). the adversarial model is the standard one: indistinguishable multiple encryptions under chosen ciphertext attack. ECIES satisfies this.     kdenhartog:  Are we attempting to achieve perfect forward secrecy, weak perfect forward secrecy, or post compromise security?   these could be optionally achieved by building on top of this EIP, but they\u2019re out of scope\u2014this EIP only provides simple encryption.     kdenhartog:  What integrity guarantees are we looking to achieve?   the same ones ECIES guarantees: CCA-security.     kdenhartog:  What\u2019s the average size of a message we\u2019re expecting? 100KB/10MB/1GB   up to the user.     kdenhartog:  If so are we planning to re-encrypt the message once received or are we going to store it as received?   up to the client to do whatever it wants with its messages.     kdenhartog:  Are we planning to publish them to the chain?   up to the users.     kdenhartog:  Doesn\u2019t that introduce gas fees?   if you choose to publish your messages on chain, then yes; otherwise, no.     kdenhartog:  What if a user doesn\u2019t pick the message up by the time the block gets pruned?   i have to say that I don\u2019t find to be a legitimate question. Ethereum state doesn\u2019t get \u201cpruned\u201d. perhaps if you only post it to calldata, but not anywhere in contract storage, then this could be an issue; if some user were to choose to operate in that way, then that user would need access to a full (archive) node.     kdenhartog:  How are we linking the controller of a key to the subject of the ethereum account (do we even care who the subject is?) to know that the identity is trusted and someone we want to share information with?   it\u2019s up to the consumer of this API to do this however it wants. one way would be to publish your public encryption key to your own ENS, or elsewhere on-chain that links the public key to your known Ethereum address.     kdenhartog:  Additionally, given walletconnect is looking to address the E2E messaging case, would it make sense for us to remain focused on just dApp to wallet communication?   I don\u2019t see a rationale for narrowing the scope, since that project appears tied to a specific product, and not Ethereum-wide. ",
                    "links": [
                        "https://www.secg.org/sec1-v2.pdf"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.478226817042606
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/friedtrout",
                    "index": "21",
                    "likes": "1",
                    "time": "20/09/2022-20:11:27",
                    "content": "@kdenhartog Thanks for your questions. I think it\u2019s worth reiterating the actual point of this EIP: We want to create a simple generic way of leveraging Ethereum keys to securely encrypt and decrypt generic bytes. Importantly, this EIP avoids being prescriptive of how this functionality can be used, e.g. off-chain or on-chain. The key is that the capability of encryption/decryption is a natural fit for Ethereum. The core components of this EIP are the encryption spec used and how the encryption/decryption keys are derived. We should consider which questions are relevant to the EIP itself, versus design decisions for products or tooling that could leverage this EIP. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.916666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TJKoury",
                    "index": "22",
                    "likes": "1",
                    "time": "20/09/2022-20:29:07",
                    "content": "Throwing my support behind @firnprotocol here.  This proposed standard is necessary to begin exploring integrating encryption into Ethereum apps by describing an implementation agnostic, isomorphic algorithm.  Any other consideration including key exchange / discovery, message transport / storage, identity management, et al. is far beyond scope. @kdenhartog While I applaud your attempts to consider all facets of this issue, the main problem being addressed here is the lack of a standardized way to encrypt and decrypt messages. In my opinion @firnprotocol has sufficiently documented a method by which entropy is deterministically generated for the key material using widely available and well-tested algorithms, and specified how to use secp256k1 key pairs with the ECIES algorithm. Let\u2019s keep the comments to discussing key generation and encryption algorithms. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0643939393939394
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "23",
                    "likes": "1",
                    "time": "20/09/2022-20:58:07",
                    "content": " the main problem being addressed here is the lack of a standardized way to encrypt and decrypt messages  This has existed for nearly 3 years before MM decided to deprecate it. Even today, this API is still available and usable. My point is these APIs are hardly used and we should utilize this hindsight to inform the design. Compare the usage of eth_getEncryptionPublicKey to eth_sign. Has anyone looked at this at all or any other wallet API call insights to consider this? I think at this point we\u2019re talking past each other because I\u2019m trying to look at the forest and assess the landscape where as it seems others are focused on a specific tree. That\u2019s ok, if all you want to ship is a small patch to improve this that works and I\u2019ve said as such in the PR. Fundamentally I think the necessary changes, no matter how small they are, aren\u2019t worth shipping in any wallet because they\u2019ll be a wasted effort in dev time given the current adoption seen so far. I\u2019ll leave it at that. ",
                    "links": [
                        "https://github.com/search?q=eth_sign&type=code"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.022058823529411
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "24",
                    "likes": "0",
                    "time": "20/09/2022-21:35:04",
                    "content": "    kdenhartog:  My point is these APIs are hardly used and we should utilize this hindsight to inform the design.   just a factual clarification / point of order: I think this not quite accuate. Tornado uses it, and has large usership. and\u2014to the extent they\u2019re not used much\u2014it might be because of lack of support. only non-mobile MetaMask used to support it (and now no one does). ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.871031746031746
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "25",
                    "likes": "0",
                    "time": "20/09/2022-23:47:47",
                    "content": " only non-mobile MetaMask used to support it  What I\u2019m gathering from this is it was (and still is) available on millions of wallets which didn\u2019t attract enough dApp support to get other wallets interested in supporting it? I get that you\u2019re processing these facts in a different way, but even if I\u2019m wrong and you\u2019re correct that it didn\u2019t get supported because wallets didn\u2019t implement we have to look objectively at what is clear. Wallets don\u2019t consider this work a priority to implement after 3 years of roadmap planning. So how do we need to change that to make it a larger priority? Changing cryptographic algorithms won\u2019t do that. We need to deliver additional value. AFAICT you\u2019re only further supporting the point that this was a bad design from the outset. It can\u2019t even support one of the use cases you\u2019ve pointed out so far: end-to-end encrypted messaging. As currently speced wallets cannot encrypt messages. They can only decrypt them. Why are you so adamant on keeping this? It genuinely doesn\u2019t make sense to me. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.1312500000000005
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/friedtrout",
                    "index": "26",
                    "likes": "1",
                    "time": "21/09/2022-03:05:46",
                    "content": "@kdenhartog You\u2019re completely right that it is important to understand what the priority is for wallets. We absolutely will be having discussions with these wallets to understand what is valuable for them, and why they may have discontinued support for the original encryption scheme. There\u2019s no point to an EIP that won\u2019t be used by the community. That being said, this EIP is simply the core component that can be used to create many interesting protocols, tools, services. What we should be looking at is if there\u2019s something irreversible in our proposal that could negatively impact potential future use-cases. We can always look into and define key discovery protocols or standards for storing/ sending ciphertexts in the future (for e2e encrypted messaging), but these questions can be discussed further down the road. You\u2019re correct about needing to deliver additional value. As mentioned in the proposal, the improvements are two fold: The EIP provides a sound encryption scheme that leverages only a single curve (the previous implementation juggled two), it also separates out the functionality of signing and encryption keys. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.546406525573192
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "27",
                    "likes": "0",
                    "time": "21/09/2022-06:43:31",
                    "content": " We absolutely will be having discussions with these wallets to understand what is valuable for them  Please note, I work for Brave on our security team and I\u2019ve been syncing with our wallet team on this. I\u2019ve also briefly discussed this with Metamask because I\u2019m the person who originally reported the issue of key reuse to them when I was auditing our implementation and realized this wasn\u2019t ideal so reported it to them. My views represent at least a single wallet here. Additionally, from my brief chats with Metamask during the reporting process my impression was they have similar views to me here. My take away from it was they don\u2019t consider this functionality a massive priority, but are still interested in supporting it if they can justify the effort for the change. I don\u2019t speak for them and could also be misinterpreting their views though, so I\u2019ll let them comment here if they wish. I\u2019ve also notified the Ethereum Wallets discord server of this topic to get their opinion on this topic (only 3 days ago) and so far no one has taken an interest other than @SamWilsn. I\u2019m trying to provide legitimate feedback here, but I feel like I\u2019m not getting anywhere and I\u2019ve got 3 people who are digging their feet in every time I try and contribute. Right now, it seems it would be a better use of my time to cut my losses and work on a separate EIP. I don\u2019t want to do this, since I\u2019d rather be working with dApp developers who want to use these APIs, but I\u2019m getting no where by doing this.  The EIP provides a sound encryption scheme that leverages only a single curve (the previous implementation juggled two)  Huh, I\u2019m confused here, who only has to use a single curve? The dApp only needs to use a single curve whether it\u2019s Ed25519 or secp256k1. The wallet needs to use multiple curves\u2026 sure, but that\u2019s not that big of a deal from our perspective. In fact, we\u2019ve already implemented it as such because we support Solana as well as EVM networks. Similarly, it seems like more wallets are already considering supporting multiple chains as they consider becoming multichain so I don\u2019t think this is that big of a concern. Originally, the security concern here that I reported to metamask was the reuse of key material for different operations that didn\u2019t have a security proof. It\u2019s not directly vulnerable, but it\u2019s also not a crypto best practice and given millions if not billions of dollars depend on these wallets erroring on the side of caution was the same bet. I appreciate metamask taking the stance they have. With that in mind, this could easily be solved with just using a different salt with the KDF function. This would achieve the domain separation as defined in the papers I originally linked and is a smaller change than what @firnprotocol has proposed.  it also separates out the functionality of signing and encryption keys.  Can you be a bit more detailed in what you mean here? You\u2019ve confused me here with this point because it seems like this contradicts the previous point that a single curve can now be used. The original design meets this requirement as well by supporting signing and encryption but not in a way that\u2019s provably secure because the KDF digest is reused. That\u2019s why I\u2019m confused by this. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.657111528822055
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/friedtrout",
                    "index": "28",
                    "likes": "0",
                    "time": "21/09/2022-21:53:30",
                    "content": "    kdenhartog:  Huh, I\u2019m confused here, who only has to use a single curve? The dApp only needs to use a single curve whether it\u2019s Ed25519 or secp256k1.   Note that this is an EIP, using just secp256k1 leverages the fact that Ethereum already supports secp256k1 crypto operations, and prevents any bloat of adding a second curve.     kdenhartog:  With that in mind, this could easily be solved with just using a different salt with the KDF function.   Yeah, I think we\u2019re in agreement here! Our proposal uses a KDF to derive an encryption/decryption key pair to be used for encryption/decryption functionality.     kdenhartog:  Can you be a bit more detailed in what you mean here? You\u2019ve confused me here with this point because it seems like this contradicts the previous point that a single curve can now be used.   Absolutely. While we use the same curve for signing vs encryption, the proposal derives an encryption/decryption keypair which is distinct from the signing/verifying keypair, as mentioned above. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.089442355889724
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "29",
                    "likes": "1",
                    "time": "22/09/2022-00:54:20",
                    "content": " Yeah, I think we\u2019re in agreement here! Our proposal uses a KDF to derive an encryption/decryption key pair to be used for encryption/decryption functionality.  There\u2019s a nuance here that\u2019s important. If we use different curves we need to use different deterministic salts with the KDF to achieve domain separation. Instead, with the ECIES/ECDSA re-usage we\u2019re relying on the soundness of a different security proof here. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.4
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "30",
                    "likes": "0",
                    "time": "22/09/2022-00:55:35",
                    "content": " encryption/decryption keypair which is distinct from the signing/verifying keypair  This isn\u2019t correct to my understanding. The same keypair would be used, but since there\u2019s been a security proof to show this isn\u2019t a concern we would consider it acceptable. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "31",
                    "likes": "0",
                    "time": "22/09/2022-01:00:35",
                    "content": " Note that this is an EIP, using just secp256k1 leverages the fact that Ethereum already supports secp256k1 crypto operations, and prevents any bloat of adding a second curve.  Ethereum also supports many other curves (Pairing based crypto is needed for rollups and BLS Signatures were added when The beacon chain HF occured to support The merge HF) and never was intended to be locked to a single curve implementation. Please take a look at the motivations of EIP-86 and the further related efforts under account abstraction. In fact, I\u2019m pretty sure @firnprotocol would have to be using pairing based crypto to achieve the onchain protocol that they\u2019re implementing, but it\u2019s not obvious to me which curve is in use based on their code. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.5853174603174605
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/friedtrout",
                    "index": "32",
                    "likes": "1",
                    "time": "22/09/2022-01:57:53",
                    "content": "    kdenhartog:  This isn\u2019t correct to my understanding. The same keypair would be used, but since there\u2019s been a security proof to show this isn\u2019t a concern we would consider it acceptable.   Your latter statement is correct! By Degabriele et al., it is secure to use the same key for ECDSA and ECIES in the generic group model. Given this, we decided to take a slightly more conservative and hygienic approach by deriving a separate enc/dec keypair from the signing key. Degrabriele et al. proves that this could be done using the same keypair, but we leverage a KDF to additionally establish distinct decryption vs signing keys, just as a low-cost, conservative measure. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.681818181818182
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AustinZhu",
                    "index": "34",
                    "likes": "0",
                    "time": "29/09/2022-17:14:03",
                    "content": "This is awesome! Currently I\u2019m developing an SBT protocol for managing credentials and memberships. We have an extension in our contract for managing the visibility of a token, so people can make their SBT private. To protect the owner\u2019s privacy we also need to make sure that the off-chain data gets encrypted. I\u2019ve thought about something like PGP encryption for emails. Now if this gets supported by wallets it will be easier to encrypt/decrypt the metadata! BTW: We have submitted our EIP draft and if you guys are interested please check.  github.com/ethereum/EIPs         Add EIP-5727: Semi-Fungible Soulbound Token   ethereum:master \u2190 soularis-protocol:master            opened 12:39PM - 28 Sep 22 UTC               AustinZhu             +2820 -0       When opening a pull request to submit a new EIP, please use the suggested templa\u2026te: https://github.com/ethereum/EIPs/blob/master/eip-template.md  We have a GitHub bot that automatically merges some PRs. It will merge yours immediately if certain criteria are met:   - The PR edits only existing draft PRs.  - The build passes.  - Your GitHub username or email address is listed in the 'author' header of all affected PRs, inside <triangular brackets>.  - If matching on email address, the email address is the one publicly listed on your GitHub profile.       ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/5727",
                        "https://github.com/AustinZhu",
                        "https://github.com/ethereum/EIPs/pull/5727/files",
                        "https://github.com/ethereum/EIPs/pull/5727"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.236471861471862
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "35",
                    "likes": "1",
                    "time": "30/09/2022-00:49:15",
                    "content": "awesome! i\u2019ll take a look; glad to have you interested in this EIP and on board. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.916666666666668
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rekmarks",
                    "index": "36",
                    "likes": "1",
                    "time": "03/10/2022-20:45:41",
                    "content": "Speaking as a maintainer of MetaMask, we want to support an encryption / decryption feature, and are grateful for the work everyone here is putting into creating a new standard. I want to note that we have strong reservations about supporting encryption and decryption using secp256k1 due the concerns outlined here: blog/secp256k1_twist_attacks.md at master \u00b7 christianlundkvist/blog \u00b7 GitHub In my understanding, secp256k1 is rarely if ever used for encryption / decryption. The only justification I\u2019ve seen for it in this thread is that it\u2019s convenient for the Ethereum ecosystem, and that strikes me as a weak argument. Using e.g. curve25519 as @chrislundkvist suggests in the above blog post would be our preference, and doing so would make us more likely to implement this standard, not less. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.462703962703963
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "37",
                    "likes": "0",
                    "time": "03/10/2022-20:59:59",
                    "content": "hi @rekmarks. many thanks for the response and good to hear from you. i want to first be clear about a few conceptual matters before we proceed. as i understand, this is an attack on ECDH, and ECIES is completely unaffected. indeed, it can only take place when the victim exponentiates an attacker-supplied point by a sensitive scalar, and then sends the result back to the attacker. but this pattern only happens in ECDH, and never in ECIES. since, in ECIES, the only sensitive Diffie\u2013Hellman operation happens during decryption, but in this case the victim\u2014who would be the decryptor\u2014will never send the resulting DH point back to the attacker (and will only use it to attempt an AES decryption). keep in mind that ECIES has an asymmetry which ECDH doesn\u2019t. (there is a further Diffie\u2013Hellman operation which happens during encryption; indeed, the encryptor exponentiates the decryptor\u2019s public key by an ephemeral scalar. here too the attack would be useless, since there\u2019s nothing to learn\u2014the exponent here is ephemeral, not persistent.) separately\u2014even in the ECDH case\u2014this sort of attack is only possible when using uncompressed points (we use compressed), and is moreover only possible when the implementation fails to check whether a point is on the curve. before we discuss further merits of using secp256k1 vs. curve25519 i want to make sure we are in agreement on the above first? look forward to continuing the discussion. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.237068965517241
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "38",
                    "likes": "1",
                    "time": "03/10/2022-21:00:58",
                    "content": "It\u2019s worth jumping in here to highlight what I\u2019m thinking with regards to a storage solution further here. I\u2019m in favor of an inbox style approach where it\u2019s more like wallet_store(message: JSON) call. It\u2019s still encrypted message, and by starting with storage we can build messaging primitives upwards from this design that lead to an async messaging protocol able to be built on top. E.g. think of encrypted email with an inbox style endpoint that can be managed by the wallet. Wayne Change from Spruce does a good job describing the concept briefly in this talk: Ethereum's Identity Layer - Impact of Ethereum Presentation Spitballing here as to what this might look like wallet_store() could just expose something like a decentralized web node. This way we\u2019re able to reuse a lot of the design. With that said, I\u2019ll note that we\u2019ve got a second dApp here interested in using this API, so my theory may be invalid that this is too low level to be useful. So let me add some questions if we were going to take this encrypt/decrypt API approach and run with it. (and then work on storage separately)  How would we expose to the user the encrypt API for the message flowing from the user to the dApp? What use cases would we expect to address here and more importantly what use cases are we leaving on the table by picking this design? The more specific we can be here the better. Do we leave message migration (even between wallets maintained by the same company such as Metamask mobile and metamask extension) out of scope?  ",
                    "links": [
                        "https://identity.foundation/decentralized-web-node/spec/"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.3625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "39",
                    "likes": "0",
                    "time": "06/10/2022-15:38:56",
                    "content": "    rekmarks:  In my understanding, secp256k1 is rarely if ever used for encryption / decryption.   btw, while I think this is technically true, note that P256 is often used for encryption / decryption, and the P256 and secp256k1 curves are extremely similar in spirit. In particular, both are Weierstrass curves, and are equally vulnerable to this \u201cattack\u201d (though as argued above, it appears the attack doesn\u2019t apply to ECIES). in particular, ECIES with P256 is supported by many hardware enclaves, e.g. iOS\u2019s. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.614583333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "40",
                    "likes": "2",
                    "time": "06/10/2022-16:57:56",
                    "content": "@firnprotocol thanks for proposing. Very interesting EIP. I look forward to it! I am thinking this encryption and decryption can also be leveraged by EIP-5437: Security Contact Interface ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.53125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "41",
                    "likes": "0",
                    "time": "06/10/2022-17:15:26",
                    "content": "fascinating. i agree completely! in fact, your proposal looks almost exactly like the \u201cinbox\u201d idea we discussed above. see this quote e.g.:     firnprotocol:  as far as the details of how to \u201csend\u201d: though it\u2019s probably out of scope for this EIP (and might be worth a separate EIP), one way to do it would be to create a simple contract (or extend ENS) with a mapping (address => bytes[]), essentially associating to each address / ENS name an arbitrary-length, append-only list of ciphertexts. anybody could freely append a ciphertext, i.e. a bytes, to this list\u2014it\u2019d be the \u201cinbox\u201d for that ENS. then the user can trivially go through this list and locally eth_decrypt each new message it gets. there could even be a fun extension where you have to pay someone to send them a message.   thus I think our proposals are very much complementary and glad to see you have done this  (the only difference appears to be using GPG w/ RSA vs. ECIES. though the former is somewhat more standard, the latter has smaller key sizes and ciphertexts. but it seems that your proposal is ultimately agnostic to the encryption scheme used.) really appreciate you sharing, and look forward to continuing the discussion. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.8198616600790505
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "42",
                    "likes": "0",
                    "time": "08/10/2022-11:13:44",
                    "content": "EIP-5630 + EIP-5437 sounds cost prohibitive for a generic inbox style messaging system. It also sounds like it would discourage reporting bugs. If this is done it\u2019s going to be limited in scope of usage to only high value messages. Gas fees already can touch $5+ for a transaction on L1 at peek capacity and the incentives don\u2019t align for security researchers to report vulnerabilities if there\u2019s an additional cost to submit a bug report. This seems like it would be recreating the economics of email spam protection mechanisms that were never widely used. I don\u2019t think this would be useful. Can someone explain the usefulness of this from the security researcher\u2019s perspective that would justify why this is better than a H1 bug bounty program? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.670408163265305
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cjpais",
                    "index": "43",
                    "likes": "1",
                    "time": "25/10/2022-16:31:47",
                    "content": "I am interested in this EIP and curious to help push it forward in whatever form. I think there are a large variety of use cases. I am most interested in building an encrypted filesystem primitive. The file is a well established pattern and will help bring the EVM up a level of abstraction to more users. This primitive alone enables many new use cases. A filesystem/namespace could generally looks like Upspin to start. In terms of cryptography and access control Upspin chooses to implement something very similar to what is suggested by @SamWilsn. That is: using asymmetric keys for encrypting a symmetric passcode which then encrypts a file. This method could reasonably be used to share files and do access control.     SamWilsn:  In light of my new understanding above, I guess the pattern would be to:  Create a new public/private key pair. Publish the public key using some other EIP (maybe using ENS.) Request an encryption key using eth_getEncryptionPublicKey. Encrypt the private key created in (1) using the the key from (3). Publish the encrypted private key using some other EIP.    I\u2019ve built a proto-version of this using the deprecated eth_encrypt and eth_decrypt provided by MetaMask, and it would be nice to have an EIP which is well supported across many wallet implementations. I have no preference for curves, so whatever seems most cryptographically secure seems to make sense. I think it seems like this would be curve25519 instead of secp256k1. On top of such a filesystem primitive many applications could be built. Messaging. Encrypted File Sharing. Encrypted Group Photo Albums. Encrypted GPS data. Helping to give people better ownership and control over their data using ETH address as an identifier. This may not ultimately be enough to solve UX problems, but may get us closer to revealing what is possible through mainstream adoption of asymmetric public key cryptography by the way of a decentralized system at the user level. @rekmarks in terms of supporting a new standard from MetaMask\u2019s perspective, what would be the key functionality or difference from the original EIP-1024\u2019s specification you\u2019d be looking for? Also curious from @kdenhartog, what would be required for adoption of a fairly generic encryption/decryption EIP? What is left for something like this to have approval? Choice of curve? More specific methodology? Anything else? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.7900771103896105
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "44",
                    "likes": "1",
                    "time": "25/10/2022-17:37:16",
                    "content": "hi @cjpais, thanks for the message, and glad to have you on board! i absolutely agree with the applications you proposed.     cjpais:  I have no preference for curves, so whatever seems most cryptographically secure seems to make sense. I think it seems like this would be curve25519 instead of secp256k1.   regarding the matter of curves, i have already weighed in above: see the message beginning     firnprotocol:  i want to first be clear about a few conceptual matters before we proceed.   as well as the subsequent one. as I\u2019ve already \u201cmade my case\u201d on this front, I will defer from further comment at this time, and let the community come to an agreement on this one (though if further input is wanted from me, I\u2019m happy to give it).     cjpais:  @rekmarks in terms of supporting a new standard from MetaMask\u2019s perspective, what would be the key functionality or difference from the original EIP-1024\u2019s specification you\u2019d be looking for?   my best stab at answering this question would be, \u201cavoid the reuse of the same secret key in two different curves\u201d. thus, something like our use of a KDF is perhaps what\u2019s wanted. (others have taken issue with the fact that we additionally use secp256k1 for the encryption curve, though, as I\u2019ve made clear above, I emphatically maintain that this is not a security concern.) happy to advocate for this with you, as well as discuss any questions you have. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.9877622377622375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ronaldmannak",
                    "index": "45",
                    "likes": "0",
                    "time": "26/10/2022-23:28:29",
                    "content": "I\u2019m very excited to see a follow up to EIP-1024. I\u2019m one of the developers of Moonfish, basically a GPG-like solution for email using Ethereum keys. If the decision to use a single curve was made to make the life of wallet developers easy, I have to agree with @kdenhartog. Using two curves shouldn\u2019t be an issue. I\u2019d suggest to use proven models, unless there is a good reason not to (there might be one that I missed, feel free to correct me). As I understand the proposal, the intention is to encrypt the message itself asymmetrically. While this works, I do see two possible issues:   I am not sure if it\u2019s still an issue on modern devices, but asymmetric encryption is slower than symmetric encryption. If you want to scale the solution for use with large attachments or files (as mentioned in one comment), you might run into performance issues on low-end devices. Then again, maybe it\u2019s not an issue, but I would certainly benchmark it.   The current proposal doesn\u2019t seem to support multiple recipients, a common scenario in messaging and email.   Have you considered using the GPG model where the message itself is encrypted with a one-time symmetrical session key, and the session key itself is encrypted with the recipient\u2019s public key? This would scale for multiple recipients. Another things worth considering is adding metadata to the standard, such as chainID and the public keys/addresses of the sender and all recipients to simplify replying to an encrypted message. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.5290854978354975
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ronaldmannak",
                    "index": "46",
                    "likes": "0",
                    "time": "26/10/2022-23:29:06",
                    "content": "Have you considered extending Age? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "47",
                    "likes": "0",
                    "time": "31/10/2022-08:36:03",
                    "content": "    friedtrout:  Your latter statement is correct! By Degabriele et al. , it is secure to use the same key for ECDSA and ECIES in the generic group model. Given this, we decided to take a slightly more conservative and hygienic approach by deriving a separate enc/dec keypair from the signing key. Degrabriele et al. proves that this could be done using the same keypair, but we leverage a KDF to additionally establish distinct decryption vs signing keys, just as a low-cost, conservative measure.   I\u2019d like to point out the implications of this to a MPC/TSS controlled wallet. It seems to me very difficult if not infeasible to derive a new key pair if the underlying secret key is controlled by multiple parties through some TSS scheme, like GG18/GG20 or some other similar ones. Also, if we keep using the same key pair, then the public key is available if the account had signed any messages on-chain: ECDSA allows public key recovery from signature. This will save lots of troubles of key discovery. ",
                    "links": [
                        "https://eprint.iacr.org/2019/114.pdf"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.165646853146853
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "48",
                    "likes": "0",
                    "time": "01/11/2022-02:31:37",
                    "content": "Also as Ethereum accounts are migrating to Account Abstraction / ERC-4337 contracts, maybe it makes sense to allow contracts to have an API to expose its public key for encryption purposes. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "49",
                    "likes": "0",
                    "time": "06/11/2022-14:36:49",
                    "content": "    Weiji:  Also, if we keep using the same key pair, then the public key is available if the account had signed any messages on-chain: ECDSA allows public key recovery from signature. This will save lots of troubles of key discovery.   this is an interesting point about key discovery. i am actually perfectly open to using literally the same secp256k1 keypair for both signing and decryption. as remarked above, this scheme is proven secure in the generic group model, and is probably the best from a simplicitly standpoint. cc. @kdenhartog.     Weiji:  I\u2019d like to point out the implications of this to a MPC/TSS controlled wallet. It seems to me very difficult if not infeasible to derive a new key pair if the underlying secret key is controlled by multiple parties through some TSS scheme   you\u2019re absolutely right. FWIW, it is possible to do HKDF through MPC, or, at least, 2PC, and even to do it relatively efficiently (say, using garbled circuits), but it is very difficult implementation-wise. so I agree that this would be essentially prohibitive. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.128942486085343
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "50",
                    "likes": "0",
                    "time": "06/11/2022-22:07:24",
                    "content": " Also curious from @kdenhartog, what would be required for adoption of a fairly generic encryption/decryption EIP? What is left for something like this to have approval? Choice of curve? More specific methodology? Anything else?  First off, support should be added for both encryption and decryption in a bilateral direction. It seems everyone here wants to focus on the bikeshed of which cryptographic primitives to use, without considering there\u2019s no widely deployed solution for a dApp to have a public key so we\u2019ll still be stuck with every request to the dApp being sent over TLS, but all the responses are encrypted to the ethereum account. This is effectively like building TLS where the browser only sends HTTP requests and the server only responds with HTTPS responses. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.576923076923077
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "51",
                    "likes": "0",
                    "time": "07/11/2022-01:15:55",
                    "content": "let\u2019s keep the tone respectful, please. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "52",
                    "likes": "0",
                    "time": "07/11/2022-01:47:15",
                    "content": "Happy to edit my comment since it\u2019s tone has come off in a way other than intended. Which parts would you like changed? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.6875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "53",
                    "likes": "0",
                    "time": "07/11/2022-02:10:29",
                    "content": "    kdenhartog:  support should be added for both encryption and decryption in a bilateral direction \u2026 there\u2019s no widely deployed solution for a dApp to have a public key   Could you please elaborate why this is so important or even a prerequisite? What are the use cases besides a TLS connection? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.949999999999999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "54",
                    "likes": "0",
                    "time": "07/11/2022-02:41:42",
                    "content": "Sure, the user wishes to send a confidential transaction to the mixer dApp in order to submit a private transaction where the only party they\u2019re willing to reveal the amount to is the dApp. Today, these confidentiality guarantees to send a request to a dApp is handled by the TLS session which is good enough for most people. If we believe TLS is good enough for the request then I don\u2019t see the reason it\u2019s not good enough for the response. If we don\u2019t believe TLS is good enough for the response from the dApp and therefore believe we need an additional message layer security in order to provide better confidentiality then we should also provide the same guarantees for the request. Put another way as a question, which API defined in this EIP do I as a wallet developer call in order to enable my user to send an encrypted message to firn protocol\u2019s dApp? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.166666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "55",
                    "likes": "1",
                    "time": "07/11/2022-02:45:20",
                    "content": "Thanks. This is a fair point. Maybe we need to clarify what exactly is the \u201cuser \u2192 dApp\u201d use case and why TLS not enough for some cases. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.4375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "56",
                    "likes": "0",
                    "time": "07/11/2022-02:49:16",
                    "content": "Finally, someone else sees what I\u2019m try to convey. This is what I\u2019ve been trying to convince others of for awhile and I must just not be conveying the problem clearly enough if it\u2019s only now just clicking for people. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "57",
                    "likes": "0",
                    "time": "07/11/2022-13:32:23",
                    "content": "to be honest, i still don\u2019t see the problem. it\u2019s easy to securely associate a public key to your Ethereum account:  if you\u2019re an EOA, post it as an entry in some contract, exactly like how ENS does. if you\u2019re a contract, just expose a public pure function returning the key.  this completely bypasses the need for \u201cTLS\u201d, since we\u2019re assuming that the user/client already knows your ethereum address, and has reliable access to a node. so relevant the TLS happens between the user and the node, not between the user and the dapp. meanwhile, the authenticity of the public key comes from the fact that it was posted by someone with control over that ethereum account. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.922161172161172
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "58",
                    "likes": "0",
                    "time": "07/11/2022-13:34:38",
                    "content": "    kdenhartog:  Put another way as a question, which API defined in this EIP do I as a wallet developer call in order to enable my user to send an encrypted message to firn protocol\u2019s dApp?   i\u2019m sorry, but this doesn\u2019t compute. you would call some \u201cget public key\u201d function exposed by the dapp. the dapp would deliver the public key. you would locally encrypt under that key. you would then send the ciphertext to the dapp. what\u2019s wrong with this? actually this is a much less difficult case, since the public key depends only on the dapp, not the user. so it could even be hardcoded in the static front-end. if you wanted to authenticate the public key, you would use the technique in the post above. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.6568627450980395
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "59",
                    "likes": "0",
                    "time": "07/11/2022-13:59:30",
                    "content": "i think there may be some serious misunderstandings here, so i want to step back and address these. in the cases relevant to this EIP, the \u201cdapp\u201d is a purely static front-end, containing some javascript UI / recipes which allow a user to more easily interact with some on-chain contracts, together with these contracts themselves. so there is no meaningful \u201cTLS\u201d engaged in between the user and the dapp. (rather, the TLS happens between the user and whoever serves the static content, say the IPFS gateway.) in fact, that\u2019s arguably the whole point of this EIP: if you want to send something confidentially to the \u201cdapp\u201d, where do you send it? the \u201cdapp\u201d doesn\u2019t exist as something that can live on the other end of a TLS channel; it consists entirely of contracts and static front-end code, which you can\u2019t \u201csend\u201d things to. so what do you do? essentially the only thing you can do is to obtain a public key from the front-end\u2014which you can certifiably attest is controlled by the dapp\u2014encrypt under that key, and then post the ciphertext somewhere the dapp can see it, say, on-chain. the arguably more interesting case is where a user wants to encrypt to another user. here, you can imagine a sort of \u201con-chain encrypted email\u201d Dapp. here, the encryption doesn\u2019t go to the dapp, but from one user to another. the dapp would retrieve the recipient\u2019s public key from a registry (something like ENS), obtain the message, facilitate its encryption by user to the recipient key, and then post the ciphertext for the user somewhere the recipient can find it (say, an inbox contract).     kdenhartog:  Sure, the user wishes to send a confidential transaction to the mixer dApp in order to submit a private transaction where the only party they\u2019re willing to reveal the amount to is the dApp.   in this example, the mixer would require a non-static backend server. in this case, you probably don\u2019t need this EIP; you can just use TLS. let me know if this clarifies things; apologies for the misunderstandings. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.7877435064935066
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "61",
                    "likes": "0",
                    "time": "07/11/2022-22:12:58",
                    "content": " To be honest, i still don\u2019t see the problem. it\u2019s easy to securely associate a public key to your Ethereum account:  if you\u2019re an EOA, post it as an entry in some contract, exactly like how ENS does. if you\u2019re a contract, just expose a public pure function returning the key.   Where is this defined in the EIP? Sure, there\u2019s numerous ways to do this but our wallet team can\u2019t  implement against any of this as none of this is defined.  i\u2019m sorry, but this doesn\u2019t compute. you would call some \u201cget public key\u201d function exposed by the dapp. the dapp would deliver the public key. you would locally encrypt under that key. you would then send the ciphertext to the dapp. what\u2019s wrong with this? actually this is a much less difficult case, since the public key depends only on the dapp, not the user. so it could even be hardcoded in the static front-end. if you wanted to authenticate the public key, you would use the technique in the post above.  If the dApp is a SPA running locally in my browser with only static front end code, how is the private key loaded in? Also, why do I need to encrypt a message to a dApp in that case? Who\u2019s the adversarially actor I\u2019m trying to maintain confidentiality from in that case? This architecture you\u2019ve described with a completely stateless front end and a public backend (the ETH blockchain) doesn\u2019t need confidentiality via encryption. I guess this is why I\u2019m confused is I never saw this as a usecase where this was necessary.  and then post the ciphertext somewhere the dapp can see it, say, on-chain  If the dApp is not ran in a server and is ran entirely via smart contracts for backend logic and static code for front end logic where is the dApp\u2019s private key kept?  the arguably more interesting case is where a user wants to encrypt to another user . here, you can imagine a sort of \u201con-chain encrypted email\u201d Dapp.  I\u2019ve eliminated this use case from practicality because of the inherent cost of gas fees. storing messages on chain is impractical. Assuming only SMS style messages were used with a 160 character limit and 4.1 trillion messages sent (numbers pulled from this link MMS vs SMS - Difference and Comparison | Diffen) this equates to a max bound of 656 terabytes of storage required (per year) if we were to entirely replace SMS with this. Now, I can presume the counter argument to this would be \u201cwe don\u2019t want to replace SMS it would just be used for limited use cases of X,Y,Z\u201d. So let\u2019s downscale this to say that 1 billion messages are sent per year at 160 character limit. Practically speaking this means 1/8th of the world gets to send only 1 message per year of 160 characters. That still comes out to 160GB of storage (per year) and doesn\u2019t even account for the additional demand for the mempool. Putting all this together just makes this an infeasible architecture in my eyes. I\u2019d rather handle this off chain (there\u2019s additional security/privacy benefits to this I\u2019ve highlighted above) and make the chain a mechanism for discovery on how to find another persons off chain inbox server. Hopefully, this illuminates my perspective a bit more clearly on this. This is why I was trying to get us to detail out the use cases more clearly above. I knew we\u2019d end up talking past each other if we didn\u2019t align on that first. This is just inherently how standards conversations go by the very nature of the way standards get built from what I\u2019ve learned. If I knew a faster, more fluid way to do this I\u2019d certainly jump to use it, but I don\u2019t have one so I resort to the method I\u2019ve found to build consensus and ship running code. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.423204527712723
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "62",
                    "likes": "0",
                    "time": "07/11/2022-23:32:59",
                    "content": "I have to ask you to please stop replying in this thread. I find your input to be unconstructive, and best suited for a different setting. Thank you. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "63",
                    "likes": "0",
                    "time": "07/11/2022-23:46:41",
                    "content": "hello @ronaldmannak, apologies, I missed your message when you first posted it. thanks for your contribution and glad to have you on board.     ronaldmannak:  Have you considered using the GPG model where the message itself is encrypted with a one-time symmetrical session key, and the session key itself is encrypted with the recipient\u2019s public key? This would scale for multiple recipients.   actually, this is an almost exact description of how ECIES works, and is actually the only way to use asymmetric encryption for long messages. indeed, \u201ctrue\u201d asymmetric encryption only works for short messages\u2014say, on the order of 32 bytes. everything longer than that, you\u2019ll use the \u201chybrid\u201d style of encryption you described above, which is what both GPG and ECIES use.     ronaldmannak:  I\u2019d suggest to use proven models, unless there is a good reason not to (there might be one that I missed, feel free to correct me).   the model we propose is proven (and in fact this is true regardless of whether you use the HKDF to go from signing key \u27f6 decryption key or not). the only model which is not proven secure is that of EIP-1024, in which the same secret key is used for both signing on the secp curve and simultaneously for decryption on curve25519. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "64",
                    "likes": "2",
                    "time": "08/11/2022-03:21:36",
                    "content": "I\u2019d like to mention the \" Deterministic Encryption and Storage via Snap/IPFS\" project as one of the use cases that this EIP could apply to. It is the ETH Lisbon hackathon winner #1. It is not messaging. Not sure if it falls into \u201cdApp \u2192 user\u201d category or \u201cdApp \u2192 dApp\u201d: the private key should be controlled by the same user all the time. In this case, there is no server behind the dApp. ",
                    "links": [
                        "https://eth-lisbon.notion.site/Winners-0b5e1564d84044718ec6d5be50f6d108"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.35
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "65",
                    "likes": "1",
                    "time": "08/11/2022-09:42:43",
                    "content": "    Weiji:  I\u2019d like to mention the \" Deterministic Encryption and Storage via Snap/IPFS \" project as one of the use cases that this EIP could apply to. It is the ETH Lisbon hackathon winner #1 . It is not messaging. Not sure if it falls into \u201cdApp \u2192 user\u201d category or \u201cdApp \u2192 dApp\u201d: the private key should be controlled by the same user all the time. In this case, there is no server behind the dApp.   Ahh fascinating! Thank you for this link. It appears to be achieving something quite useful which is like an encrypted personal data store pattern. Nice work @skgbafa! This is effectively what I was trying to describe in this comment but this achieves it in a way that requires less wallet code, so I\u2019m in favor of this pattern. We\u2019ll probably want to standardize a few more things to make it a bit more interoperable, but I\u2019m willing to help out on that. Others want to leave that out of scope for this EIP so probably worth defining it separately and building on this one separately. That helps me answer a ton of the questions I\u2019ve been trying to understand albeit only for the \u201cuser to themselves\u201d use case (maybe  \u201cuser \u2192 user\u201d category although I think people mean different people normally here). Up until this point, I\u2019ve not found any code for a dApp that was using these APIs (including in firn\u2019s dApp and tornado cash - I can see from the UX flow that it is being used in tornado.cash but can\u2019t find the code on GH) so I was genuinely confused how this was achieving anything. I\u2019m still a bit confused about \u201cuser \u2192 dApp\u201d category or \u201cdApp \u2192 dApp\u201d categories particularly because  I think it depends on the deployment model of the dApp as well so they can decrypt the messages they\u2019re receiving. Anyone got a code example of how that might work? Right now it seems like the way the code might work would be: fetch(url, {     method: 'POST',     mode: 'cors',      cache: 'no-cache',      credentials: 'same-origin',      headers: {       'Content-Type': 'application/json'       // 'Content-Type': 'application/x-www-form-urlencoded',     },     body: \"my message to the dApp\"    }); ...  // time to decrypt response  window.ethereum.request({   method: 'eth_decrypt',   params: [{     version: 'secp256k1-sha512kdf-aes256cbc-hmacsha256',     ciphertext   }, myEthAccount], })  window.ethereum.request({   method: 'eth_getEncryptionPublicKey',   params: [myEthAccount], })  window.ethereum.request({   method: 'eth_decrypt',   params: [{     version: 'secp256k1-sha512kdf-aes256cbc-hmacsha256',     ciphertext   }, myEthAccount], })  If we did it the opposite way where it was the dApp that initiated the message I believe the order here would just be flipped around. If we wanted to replace that fetch call with an encrypted message then we\u2019d need to define how to retrieve the dApp public key and how to post the message to it. If we don\u2019t want to define this, then I\u2019m back to my original point of why send messages to the dApp unencrypted by receive messages from the dApp encrypted? ",
                    "links": [
                        "https://eth-lisbon.notion.site/Winners-0b5e1564d84044718ec6d5be50f6d108",
                        "https://ethereum-magicians.org/t/eip-5630-encryption-and-decryption/10761/38"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.67877435064935
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "66",
                    "likes": "1",
                    "time": "08/11/2022-13:47:51",
                    "content": "    Weiji:  as one of the use cases that this EIP could apply to.   it looks like they actually invoke our EIP  (presumably as a mock at this stage.) plus additional logic for storage and retrieval. nice find. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cjpais",
                    "index": "67",
                    "likes": "1",
                    "time": "08/11/2022-15:24:06",
                    "content": "This is awesome work. It lends itself nicely to extension as well. One such way would be to use a contract as a public key registry. This effectively enables decentralized private file sharing. I was doing previous work on this here, with the former EIP-1024. I think this EIP has the potential to open up a bunch of use cases based on work like this. I think the \u201cperson \u2192 person\u201d or \u201cperson \u2192 people\u201d categories are easily opened up as well. Again using an extension to this methodology through a contract. The same code shared above has a methodology to share a encrypted file to a group of people. I think the use case for people to communicate over encrypted channels itself is very compelling and important. Not to mention in the current form it fits nicely into permissionless building. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.071296296296296
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "68",
                    "likes": "1",
                    "time": "09/11/2022-02:21:11",
                    "content": "For the key discovery or public key registry, I think it is time to summarize:  Smart Contracts could expose a function to return a public key; EOA: encrypt to the \u201cdirect\u201d public key, that is, the one corresponding to the address. Usually this could be recovered from past signatures. We need a utility for this purpose. EOA: encrypt to the \u201cderived\u201d public key as currently specified. We may need a registry, be it smart contract or ENS or something else. Fee may incur.  There are also security implications to the choice between \u201cdirect\u201d or \u201cderived\u201d public key, mostly about key management. I\u2019d like to link this to my other proposal about private key encapsulation: that is, if we rely on this EIP for file encryption or end2end encrypted messaging, we don\u2019t want to enter our seed to a messaging app. We could safely transport the needed private key (\u201cdirect\u201d or derived) to the app without endangering the entire seed. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.1607142857142865
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "69",
                    "likes": "0",
                    "time": "09/11/2022-16:52:54",
                    "content": "hi @Weiji.     Weiji:  if we rely on this EIP for file encryption or end2end encrypted messaging, we don\u2019t want to enter our seed to a messaging app.   let\u2019s back up\u2014i don\u2019t see why there would ever be a need to input your seed into a messaging app? let\u2019s take an example. in the case of e2e messaging, it\u2019d work the following way. the \u201cdapp\u201d\u2014which, i emphasize, is just some static javascript loaded into the browser\u2014will perform the following steps to send a message:  it would acquire the recipient\u2019s public key, either by doing an ECDSA recovery on an existing signature (\u201cdirect\u201d) or retrieving it from a registry (\u201cderived\u201d). it would solicit the desired plaintext message from the user, through some kind of input form. it would run some local javascript code to encrypt this plaintext to the desired recipient\u2019s key. it would prompt the user to post this ciphertext on-chain, and to pay the gas for doing that.  to receive / decrypt a message, the dapp would do as follows:  it would retrieve the relevant ciphertext(s) from an on-chain source, e.g., the user\u2019s \u201cinbox\u201d contract. the (static) dapp code would issue an eth_decrypt request to the user\u2019s wallet, with the ciphertext as argument. the user will be prompted to approve the decryption. the plaintext will now be displayed by the dapp web interface.  there is never a need to expose the seed or any private material whatsoever to the dapp, or to any remote server. hopefully this helps clarify things? thanks for your thoughts. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "70",
                    "likes": "0",
                    "time": "10/11/2022-02:16:04",
                    "content": "    firnprotocol:  it the (static) dapp code would issue an eth_decrypt request to the user\u2019s wallet, with the ciphertext as argument. the user will be prompted to approve the decryption.   Consider if the user is keeping his or her seed or private keys in a hardware wallet, yet the dapp runs in a mobile device or browser extension for convenience. If we rely on the hardware wallet to decrypt, then literally user will have to approve the decryption for every incoming message. And if he or she leaves the hardware at home, there is no way to decrypt messages for the day. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "71",
                    "likes": "0",
                    "time": "10/11/2022-13:01:05",
                    "content": "so yes, this is true. but usually we accept and even expect user approval for each sensitive action. but if you wanted to bypass this, you could use the following flow instead. to log in / create an account:  the browser client generates a fresh random secret key for the user, say nk. it locally computes the corresponding public key, say mk. the browser posts mk in a registry known to the dapp, so that other users can discover the key mk. the browser separately issues an eth_getEncryptionPublicKey  request to the wallet, which the user is prompted for; it receives the resulting stable public encryption key, say ek. it encrypts the secret nk to ek, and posts the resulting ciphertext to the blockchain somewhere belonging to the user, for recovery later. to log back in later, the browser retrieves this ciphertext, and issues an eth_decrypt request on it to the user. after the user accepts the request, the browser obtains nk, which it can use to decrypt every message.  to send a message:  after inputting the desired recipient into the dapp, the dapp retrieves the dapp-specific public key mk corresponding to this receipient. the dapp solicits the plaintext from the user, encrypts it to mk, and posts the ciphertext on-chain.  to receive a message:  once you\u2019re logged in (see above) the browser has access to nk, using which it can automatically retrieve / decrypt every message.  in this case, you do provide the secret nk to the dapp. but this secret is completely unconnected to your seed phrase hierarchy, and is not used for any purpose other than the dapp. moreover, there is no need for TLS / Diffie\u2013Hellman / key encapsulation / etc., since the dapp runs locally on the same machine as the wallet\u2014nk is never transmitted to any external machine. thoughts? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.733870967741936
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "72",
                    "likes": "0",
                    "time": "11/11/2022-03:01:48",
                    "content": "Hi @firnprotocol  Key management is a complicated issue and not a pure technical decision. Sometimes it involves uers. Let\u2019s focus on this EIP here and redirect KEM related discussion to the other thread. Do you mind if quote your comments there? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.3898809523809526
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "73",
                    "likes": "0",
                    "time": "11/11/2022-03:13:16",
                    "content": "absolutely, go ahead. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "74",
                    "likes": "0",
                    "time": "28/11/2022-04:05:31",
                    "content": "    Weiji:  EOA: encrypt to the \u201cdirect\u201d public key, that is, the one corresponding to the address. Usually this could be recovered from past signatures. We need a utility for this purpose.   @firnprotocol What do you think about this? Do you see a need to include it in 5630? It\u2019d simplify public key discovery issues in some applications/scenarios. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.583333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "75",
                    "likes": "0",
                    "time": "28/11/2022-04:24:06",
                    "content": "right, yes, i think it\u2019s a great idea. i just think we need to first decide (i.e., as a community) whether we want to include the HKDF or not (i.e., whether we do 2 or 3 in the message you\u2019re quoting from).  benefit of using HKDF: slightly stronger security (i.e., security argument doesn\u2019t rely on the GGM). benefit of not using HKDF: allow key discovery by performing ecrecover on existing signatures.  which benefit is more \u201cworth it\u201d first needs to be decided by us, on technical grounds.     Weiji:  Do you see a need to include it in 5630?   i\u2019m not quite sure what you mean. certainly the decision of whether to use the HKDF or not needs to be made in this EIP. on the other hand\u2014regardless whether or not we include the HKDF\u2014my sense is that the mechanism for public key discovery is out-of-scope for this EIP. if we don\u2019t use the HKDF, then there\u2019s not much of a problem to solve, since it\u2019s essentially trivial (at least for addresses which have signed before). If we do use the HKDF, then it becomes much less trivial, and we\u2019d need something analogous to ENS. either way though, i think that would be the territory of a separate EIP. thoughts? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.452546296296297
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "76",
                    "likes": "0",
                    "time": "28/11/2022-06:24:53",
                    "content": "I do think it is important for an EIP to be considered for its infrastructure dependencies. Public key discovery is non-trivial and subtle to manage right. And when such is lack we need to jump start this EIP. Can we support both? Then users and community could choose either or both as they see fit. I do see applications without HKDF, when people can send each other encrypted messages as long as the peer had signed any txn/msgs before. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.320767195767195
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "77",
                    "likes": "0",
                    "time": "28/11/2022-13:14:04",
                    "content": "hmm. perhaps we could support both, and use separate version tags for each. e.g., secp256k1-sha512kdf-aes256cbc-hmacsha256 and secp256k1-sha512kdf-aes256cbc-hmacsha256-nokdf. (these are getting fairly long\u2026). i\u2019d personally prefer that we pick one, just for simplicity, but maybe we can let community members weigh on on this.     Weiji:  Public key discovery is non-trivial and subtle to manage right. And when such is lack we need to jump start this EIP.   while i agree with you that it\u2019s important and subtle, I think I have to respectfully disagree that it should be included in this EIP. i would be happy to help & advise on a separate EIP treating the issue of public key distribution / advertising. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.776556776556776
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "78",
                    "likes": "1",
                    "time": "28/11/2022-16:56:58",
                    "content": "    firnprotocol:  secp256k1-sha512kdf-aes256cbc-hmacsha256-nokdf   Maybe simply secp256k1-aes256cbc-hmacsha256     firnprotocol:  while i agree with you that it\u2019s important and subtle, I think I have to respectfully disagree that it should be included in this EIP.   This has been going around a few times. I totally respect your decision here. Let\u2019s close it here. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.305555555555555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "79",
                    "likes": "0",
                    "time": "30/11/2022-11:21:08",
                    "content": "Before I submit a new pull request, let\u2019s do a little bit polling here. Do you think we need to add a new version secp256k1-aes256cbc-hmacsha256?     Yes No     0 voters     The purpose of this new version is that applications could choose to encrypt message to the original public key or one derived with sha512kdf. Please checkout earlier discussion for context. Thanks. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.442550505050505
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "80",
                    "likes": "0",
                    "time": "01/12/2022-02:23:48",
                    "content": "in the interest of clarifying the poll\u2026 do you intend that a \u201cyes\u201d vote entails that we do both? or that we only do the version without the KDF? if possible, please clarify that, and then i will vote.     Weiji:  Maybe simply secp256k1-aes256cbc-hmacsha256   btw, to clarify, the sha512kdf in the original naming suggestion refers to the KDF done within ECIES (to conver the DDH secret into an AES + MAC secret key). it has nothing to do with the KDF relating sk \u2192 dk, which is separate. just so you know. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.696428571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "81",
                    "likes": "0",
                    "time": "01/12/2022-04:22:32",
                    "content": "    firnprotocol:  do you intend that a \u201cyes\u201d vote entails that we do both? or that we only do the version without the KDF? if possible, please clarify that, and then i will vote.   both, sorry for the confusion ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.166666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "82",
                    "likes": "0",
                    "time": "01/12/2022-04:39:59",
                    "content": "    firnprotocol:  btw, to clarify, the sha512kdf in the original naming suggestion refers to the KDF done within ECIES (to conver the DDH secret into an AES + MAC secret key). it has nothing to do with the KDF relating sk \u2192 dk, which is separate. just so you know.   Thanks for the clarification. I assumed the wrong way. Then maybe the suggested additional version could be: secp256k1-none-sha512kdf-aes256cbc-hmacsha256, with none following immediately after secp256k1 to indicate that no KDF is done to derive dk from sk. The original version could also be changed to sth like secp256k1-X963-sha512kdf-aes256cbc-hmacsha256. I\u2019d also suggest that we trim the trailing cbc-hmacsha256 as there is no other option here. How do you think? @firnprotocol ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.840277777777778
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "83",
                    "likes": "0",
                    "time": "01/12/2022-13:45:53",
                    "content": "    Weiji:  I\u2019d also suggest that we trim the trailing cbc-hmacsha256 as there is no other option here. How do you think?   sure, I am happy to do this. the name is too long. good idea.     Weiji:  both, sorry for the confusion   my opinion is that for simplicity, we should choose one approach for this EIP. i am not sure yet which it should be, but I think I have a preference against doing both. so I will have to vote \u201cno\u201d in the poll I think. actually, personally, if I had to choose, I\u2019d prefer not doing the KDF (as you suggested). it\u2019s a question of whether the community will also agree\u2014the security is (very) slightly weaker, since the best known proofs require the GGM. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.022916666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "84",
                    "likes": "0",
                    "time": "01/12/2022-15:59:57",
                    "content": "@firnprotocol how about a new poll with 3 options, that is: both, with-kdf, without? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.681818181818182
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "85",
                    "likes": "0",
                    "time": "01/12/2022-16:02:43",
                    "content": "sure. (i\u2019d prefer we exclude the option \u201cboth\u201d, but let\u2019s let the poll decide that ) thanks for putting this together. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "86",
                    "likes": "0",
                    "time": "01/12/2022-16:16:52",
                    "content": "How do you think we should proceed? Please select one:     support only the original verision secp256k1(-X963)-sha512kdf-aes256(cbc-hmacsha256), a new key pair for encryption/decryption is derived from sk  support only the new verision secp256k1(-none)-sha512kdf-aes(256cbc-hmacsha256), just use sk and its corresponding public key support both versions     0 voters     ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.404829545454546
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "87",
                    "likes": "0",
                    "time": "06/12/2022-07:52:42",
                    "content": "Besides the vote, I\u2019d like to bring up another use issue here. That is, after considering how the APIs will be use by various application, I came to realize that maybe some encrypted message will be too large to be decrypted inside a hardware wallet, especially if the wallet is air-gaped and requires optical scanning to exchange data. @Lixin @Aaron Say, if this EIP becomes popular some day and people use it to encrypt large messages, for example, in several MBs, decrypting the message within a hardware wallet may not be desirable. So I am proposing that we add another API to recover the symmetric key (and IV) instead of decrypting the whole message: request({   method: 'eth_recoverSymKey',   params: [encryptionHeader, account], })  We do not need to pass in the entire cipher text. Instead, we only need sender\u2019s ephemeral public key. encryptionHeader is much similar to encryptedMessage in that it contains version and senderEphemeralPublicKey: {   version: 'secp256k1-sha512kdf-aes256cbc-hmacsha256',   senderEphemeralPublicKey: '0x03ab54...', }   Then the wallet managing the private key could derive the shared secret, sha512-kdf the shared secret to derive AES-256 key and IV, which it returns to caller, the caller may decrypt cipher text outside of the wallet. @firnprotocol how do you think? Edit: by preventing arbitrary message from being decrypted and written to memory inside a wallet managing users\u2019 seed / private keys, this new request also protects wallets from potential buffer overflow attack etc. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.6812384044526905
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TJKoury",
                    "index": "88",
                    "likes": "0",
                    "time": "08/12/2022-15:11:17",
                    "content": "There\u2019s a solution that solves this problem and is a more directive way of providing the encryption public key, or even changing it later if the original is compromised, separating the signing (identity) keypair from the encryption keypair. The EIP should be updated to include requiring an encoded message that is published in the input/data field of a transaction, which would be a prefixed text input to include the public key encoded as base64 to save space, such as: EIP5630::BDewu3qCiNOO1JpSS13JjP8+tcqCTJ+dwN/bPZzWAPKZpheZErdFHAmJbECY7KfOay5YMwZyeV6EfE1q9E4CQjA= I know everyone wants the public key to be \u201cdiscoverable\u201d from the Ether address, however you can only recover it if there\u2019s a signed transaction.  Might as well publish the public key in that transaction in a way that takes minimal gas and allows swapping keys. If you agree @firnprotocol I can add a section to the EIP. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.324999999999999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/vbuterin",
                    "index": "89",
                    "likes": "0",
                    "time": "08/12/2022-15:36:24",
                    "content": "How would this work together with smart contract wallets? IMO given that smart contract wallets are finally picking up, it\u2019s important for something like this to have a path for encrypting to smart contract wallets. The most natural approach that I can see is to have an EIP-1271 equivalent for signing, something like: encryptToAccount(bytes memory plainText) public view returns (bytes cipherText) This would be fully generic and support any algorithm that someone might want, including threshold encryption, post-quantum algorithms, etc. Have people here thought about this? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.912698412698413
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "90",
                    "likes": "1",
                    "time": "08/12/2022-15:55:07",
                    "content": "intriguing. it seems plausible that an additional parameter\u2014containing randomness/entropy\u2014would need to be supplied to this method, no? since (public-key) encryption requires ingesting randomness. a further note: this approach would essentially allow contracts to choose arbitrary encryption mechanisms\u2014which, in general, may not be compatible with eth_decrypt (i.e., the RPC call we\u2019re proposing here). this could be a bit confusing. but i guess that is a caveat emptor situation for the writer of the contract. in general, i completely support this! very much appreciate your thoughts. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.4425
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/vbuterin",
                    "index": "91",
                    "likes": "1",
                    "time": "08/12/2022-16:02:11",
                    "content": "Ah yes, adding an entropy parameter would definitely be a good idea. As for eth_decrypt, that would be up to the javascript part of smart contract wallets to implement correctly, right? So eg. Soul Wallet would give everyone ERC4337 accounts by default, and their javascript interface would implement eth_decrypt their own way based on how they know that the encryption algorithms they choose work. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "92",
                    "likes": "0",
                    "time": "08/12/2022-16:18:05",
                    "content": "very interesting. the issue is that, above, we have prescribed / suggested a specific way for eth_decrypt to operate (i.e., which algorithm / variant of ECIES etc.). maybe what we need to do is actually remove the prescription\u2014and let wallets do it however they want. there could be a \u201cstandard\u201d / default choice, but also arbitrary choices, made on a per-wallet basis. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.550000000000001
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TJKoury",
                    "index": "93",
                    "likes": "0",
                    "time": "08/12/2022-16:25:24",
                    "content": "@vbuterin I\u2019ve given this a fair bit of thought for my project.  Most immediate issue for me: have a revokable trust interface in the smart contract with assignable trust levels (like is used in PGP). That way you can set up trust rules (at least x of n keys trust this key as of block y). For implementing something like a smart-wallet that does encryption (the results being unshareable/unknowable), having a queryable, stateful \u201creputation score\u201d is essential. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.928571428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "94",
                    "likes": "0",
                    "time": "09/12/2022-04:23:19",
                    "content": "Let\u2019s pull back the discussion a little bit. Unlike on-chain signature verification, both encryption and decryption must happen off-chain because both the key and the plaintext must be kept confidential. That being said, we had considered smart contract uses before, which is to provide a function to return the public key for encryption. If multiple curves are supported or consider post-quantum security, return also the supported and/or preferred version. It could also return multiple choices.     Weiji:  Smart Contracts could expose a function to return a public key;   We could make such an API part of either 5630 or 4337. I think that should address smart contract / ERC-4337. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.175137362637363
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TJKoury",
                    "index": "95",
                    "likes": "0",
                    "time": "09/12/2022-06:22:27",
                    "content": "Would the smart contract accept an Ethereum address as an argument and then return a public key assigned to that address?  If so, I imagine the contract would act like Active Directory.  In your model then, is there a method that allows a user update / revoke a public key?  Apologies if I\u2019m misunderstanding your point. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.067460317460317
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "96",
                    "likes": "0",
                    "time": "09/12/2022-06:35:37",
                    "content": "I don\u2019t see the need for an argument. And yes to the second question, the contract owner should be able to update the public key in any way that she or he sees fit. Decryption will be carried out off-chain. Note that I am talking about a ERC-4337 style contract that is owned by individual entity, not some DAO style that could be \u201cowned\u201d collectively. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TJKoury",
                    "index": "97",
                    "likes": "0",
                    "time": "09/12/2022-16:30:09",
                    "content": "Sounds reasonable, and of course all encryption would occur off-chain, I don\u2019t think anyone is arguing otherwise, or at all. The feature I\u2019m interested in is a formalized SC EIP that can enable a smart contract to act as a trust oracle, where users can revokably signal their trust of a particular contract / address.  To me this is necessary since the operation is done off-chain, and the results are private.  If someone has reason to believe a decryption key is compromised, they should be able to signal it, like an Ethereum analog for OCSP. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.831845238095238
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TJKoury",
                    "index": "99",
                    "likes": "0",
                    "time": "10/12/2022-12:40:03",
                    "content": "This is separate from my suggestion above about publishing the public key in the data field of a transaction, which I still think is a reasonable approach per my comments. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "100",
                    "likes": "1",
                    "time": "29/12/2022-16:45:03",
                    "content": "hi all. happy to report that i\u2019ve made some updates to the EIP. the new material includes:  a specification of how a contract should advertise\u2014to the world\u2014how encryptions to it should be constructed; this is important for account abstraction (cc. @vbuterin). removed the HKDF between sk \u2192 dk; this allows on-chain public-key discovery essentially for free (cc. @Weiji). added material on why twist attacks are not applicable to this EIP (cc. @rekmarks).  hugely appreciate the community effort on this! please let me know any thoughts and comments. ",
                    "links": [
                        "https://github.com/christianlundkvist/blog/blob/master/2020_05_26_secp256k1_twist_attacks/secp256k1_twist_attacks.md"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.863636363636364
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "101",
                    "likes": "1",
                    "time": "29/12/2022-16:47:12",
                    "content": "btw, i thought of a cool idea. what if you want to encrypt to someone\u2014and also be anonymous in the process; i.e., the recipient shouldn\u2019t know who the sender was (kind of like an anonymous drop-box)? you can do this with Firn\u2014i.e., you just send the ciphertext to the recipient as data, in the usual way, except make the transaction as a private & gasless withdrawal from Firn. viola. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TJKoury",
                    "index": "102",
                    "likes": "0",
                    "time": "30/12/2022-00:16:26",
                    "content": "Thoughts on my suggestion above, sending a transaction that establishes the relationship between a public key and an address?  Can be useful to associate multiple keys with an address, revoke a key, etc. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "103",
                    "likes": "0",
                    "time": "30/12/2022-01:26:59",
                    "content": "not sure i fully understand\u2014in the quote     TJKoury:  requiring an encoded message that is published in the input/data field of a transaction   it sounds like you\u2019re suggesting that the structure of the basic transaction object be changed, i.e., a field added for public key? i assume this isn\u2019t what you mean, since it\u2019d require changing the base ethereum protocol, which seems off the table. do you mean that a specific transaction (i.e., to some given contract) be published, which contains this info? this could definitely be done, though might not be necessary\u2014see below. indeed, the problem of public key discovery seems essentially solved now that we\u2019ve removed the HKDF, since you can always grab someone\u2019s key from a transaction they\u2019ve signed.     TJKoury:  I know everyone wants the public key to be \u201cdiscoverable\u201d from the Ether address, however you can only recover it if there\u2019s a signed transaction. Might as well publish the public key in that transaction in a way that takes minimal gas and allows swapping keys.   not sure I follow\u2014recovering someone\u2019s key doesn\u2019t require gas; you only need read-access to a node. let me know your thoughts. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.603260869565217
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "104",
                    "likes": "1",
                    "time": "30/12/2022-02:18:30",
                    "content": "Excellent! Good to see that we are moving on. BTW, what do you think about the situation that cipher text might become very long and too long for some wallet to handle? My suggestion is for the wallet to only derive the symmetric key (and IV etc) necessary to decrypt the cipher.     Weiji:  request({   method: 'eth_recoverSymKey',   params: [encryptionHeader, account], })    ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.324999999999999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TJKoury",
                    "index": "105",
                    "likes": "0",
                    "time": "30/12/2022-03:02:43",
                    "content": "I mean writing to the data field.  This could be a contract call or simply raw hex with an identifier followed by the public key, I\u2019m open to suggestions. Also, not implying that reading a transaction requires gas, simply stating that among the many ways to transmit metadata about a public key, this is probably the cheapest way to do it. Thinking about this more since our last, the answer might be a new smart contract type that manages decentralized PKI.  What you have now is succinct and enforces separation of concerns. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.310530815338508
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "106",
                    "likes": "1",
                    "time": "30/12/2022-03:12:00",
                    "content": "yes @Weiji, this is an intriguing suggestion. thank you. sorry for not getting to this earlier.     Weiji:  I came to realize that maybe some encrypted message will be too large to be decrypted inside a hardware wallet, especially if the wallet is air-gaped and requires optical scanning to exchange data.       Weiji:  this new request also protects wallets from potential buffer overflow attack etc.   i think in the vast majority of cases, the caller and callee of eth_decrypt will be on the same machine, or separated by a USB-C in the case of standard hardware wallets. in this kind of case, bandwidth / communication throughput will not be not a problem. regarding buffer overflows, i am simply not versed in enough in how hardware wallets work to know whether this is a problem. maybe we can find some experts to weigh in. likewise, as far as optical scanning, this is very new to me. it could be a problem, but seems like an unusual case. overall though, i like this idea, since it really only gives us more flexibility. in particular, it allows the decryptor (and of course also the encryptor) to choose an arbitrary variant of ECIES, without re-implementing or changing what\u2019s baked into the hardware wallet (this is very slow and difficult to do). instead, the hardware wallet only does the sensitive operation, and the rest is handled outside. the only downside i see is that it makes it more complicated for implementers. it also is not compatible with the encryptTo smart contract method newly proposed, since that method requires the entire encryption to be computed, not just the ECDH. so at this point it seems to me like a tradeoff between simplicity, on the one hand, and flexibility + bandwidth improvement on the other. i am still not sure where i stand exactly. we could also do both! but i also prefer to keep the EIP as simple as possible. let me think about this for a bit. thanks again for the suggestion. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.19641290726817
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Pandapip1",
                    "index": "107",
                    "likes": "1",
                    "time": "04/01/2023-12:46:32",
                    "content": "I am fully in support of the general case that doesn\u2019t hardcode the ECIES variant, just because I prefer flexibility wherever it can be offered. I nonetheless accept that this is my opinion and that others\u2019 may differ. Note that if you choose this path, you should include validation of the elliptic curve in the spec, as there are attacks possible if it is not performed. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "108",
                    "likes": "0",
                    "time": "05/01/2023-01:48:32",
                    "content": "good to know; thanks for your feedback. I will let this bake for some more time and then make a decision. (but leaning towards agreeing with you and @Weiji right now.)     Pandapip1:  if you choose this path, you should include validation of the elliptic curve in the spec   right; i expect that i will use compressed representation in any case, so there\u2019s not as much to validate. but indeed, i will definitely include validation that the 33-byte datum passed in actually represents a valid compressed point (essentially, you just need to verify that the first byte is 0x02 or 0x03, and that the remaining 32 bytes yield a quadratic residue under the RHS of the Weierstrass equation). edit but note that this validation is essentially just a sanity check; wrong curve / twist attacks are not possible in the compressed setting. indeed, if the (compressed) point is not valid, then it becomes literally nonsensical, and doesn\u2019t make sense to proceed; it\u2019s not something that could silently go undetected and lead to an attack. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.686224489795918
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "109",
                    "likes": "2",
                    "time": "05/01/2023-18:33:45",
                    "content": "i have gone ahead and made the update to the EIP. thus, now, the wallet will only do ECDH, and the rest of ECIES is chosen / carried out by the application-level implementer. (this is actually much closer to how GPG does it, btw.) big thanks to @Weiji for the idea (maybe we should add you as an author?  ) i stipulate that all checks during deserialization MUST be carried out by the wallet; cc. @Pandapip1. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Weiji",
                    "index": "110",
                    "likes": "1",
                    "time": "06/01/2023-01:00:49",
                    "content": "    firnprotocol:  big thanks to @Weiji for the idea (maybe we should add you as an author?   Oh that is very nice and sweet. Please do, use Weiji Guo (@weijiguo). Or do I need to open a PR? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.33
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "111",
                    "likes": "0",
                    "time": "08/01/2023-20:09:29",
                    "content": "done. welcome friend! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 10.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/firnprotocol",
                    "index": "112",
                    "likes": "0",
                    "time": "22/03/2023-00:35:25",
                    "content": "intereting: Ronin Bridge Exploiter communicating with Euler Finance Exploiter using ECIES encryption on-chain. see https://twitter.com/TheDEFIac/status/1638243255941840896/photo/1 this is what we are trying to standardize. edit no endorsement of either party. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                }
            ]
        }
    ],
    "group_index": "105"
}