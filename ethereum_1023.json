{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/ethpm-v3-specification-working-group/4086",
            "title": "ethPM V3 Specification Working Group ",
            "index": 4086,
            "category": [
                "Tooling"
            ],
            "tags": [
                "ethpm"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "1",
                    "likes": "3",
                    "time": "04/03/2020-21:08:04",
                    "content": "This is an effort to consolidate various datatype specifications (ethpm, solidity & vyper compiler metadata, input/output json) into a single specification to facilitate interoperability and leverage network effects. The current V3 spec should be considered a rough draft, so now is the time for proposing any changes. Once we reach general agreement on the spec in this forum, I will update the official human & machine readable specs to reflect the changes. The timeline for this project is to have a well-defined, agreed upon specification before the Solidity Summit in Berlin (April 29). At least 3 of us (@chriseth, @gnidan, @njgheorghita) plan to be at the Summit, to discuss any final details before freezing the spec. The more the merrier if you\u2019re able to make it to Berlin! Thanks for all your input and thoughts in advance! There is a range of different interests coalescing here, and it\u2019s exciting to imagine the near-future where we all benefit from using a compatible spec. Link for the ethPM V3 rough draft can be found here. Let\u2019s keep the conversation happening here on ethmagicians, and I\u2019ll make any updates to the spec as necessary.  @jpitts: Adding more context to this discussion: Registry: http://explorer.ethpm.com/ Website: http://www.ethpm.com/ v2 Spec repo: https://github.com/ethpm/ethpm-spec/ Gitter Channel: https://gitter.im/ethpm/Lobby ",
                    "links": [
                        "http://explorer.ethpm.com/",
                        "http://www.ethpm.com/",
                        "https://github.com/ethpm/ethpm-spec/",
                        "https://gitter.im/ethpm/Lobby"
                    ],
                    "GPT-summary": null,
                    "GPT-proposal-categories": null,
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.516741071428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rumkin",
                    "index": "2",
                    "likes": "2",
                    "time": "06/03/2020-18:44:45",
                    "content": "Using version for manifest version is confusing for me, it\u2019s totally not what I\u2019d expect version to mean. Also this makes package version to be called package_version and thus the name of a package to be  package_name. I think it\u2019s better to call it manifest and remove package_ prefixes at all. This would make field names clear and obvious: {   \"manifest\": \"ethpm/3.0\",   \"name\": \"package\",   \"version\": \"1.0.0\" }  This is what I found after a quick look. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.731770833333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "3",
                    "likes": "0",
                    "time": "06/03/2020-19:35:35",
                    "content": "Agreed, but it may be impractical to change at this point because V1 sort of set these fields in stone (particularly version) so you could parse out what version the manifest is encoded in ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.833333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rumkin",
                    "index": "4",
                    "likes": "0",
                    "time": "06/03/2020-20:00:43",
                    "content": "Yep, but before Ethereum 2.0, it\u2019s ok to break things. In my opinion this time is some kind of buffer to experiment,  when you can hardfork yourself. And technologies here should be made user friendly and slick like Ruby IDK, not like C. It\u2019s important because Ethereum 2.0 would be a long-time player and it\u2019s better to invest in this period of technology life. Just not a time to create a legacy. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.770833333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "5",
                    "likes": "0",
                    "time": "06/03/2020-20:07:40",
                    "content": "I don\u2019t think this standard would be related to ETH 2.0, it sort of sits by itself in relation to current tooling. It has some adoption, so I am unsure if there would be appetite for a breaking change like this, but I could be wrong. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rumkin",
                    "index": "6",
                    "likes": "0",
                    "time": "06/03/2020-20:40:55",
                    "content": "I\u2019ve checked the doc again, and it\u2019s actually contains breaking changes. One of them is renaming manifest_version into version and version into package_version, which I\u2019m against. So it\u2019s senseless to discuss. @njgheorghita Also I\u2019d suggest to use camel case instead of underscores in JSON. While underscores has better readability, camel case is de facto standard for JSON, and solidity compiler supports this. I think that host technology style should be chosen, just couldn\u2019t find a good reason to have both of them. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "7",
                    "likes": "0",
                    "time": "06/03/2020-21:36:00",
                    "content": "@rumkin Yup, I\u2019ve gotta say I do prefer what you\u2019ve proposed, thanks for submitting! Personally, I\u2019ve never been a fan of the old naming conventions, they could be better. We do have breaking changes in this spec update, and all tooling will have to update to satisfy those changes, so now is a great time to squeeze in any breaking improvements. (afaik that responsibility lies mostly b/w myself, brownie (@iamdefinitelyahuman) , truffle, and ethpm-rs (@fubuloubu) if that\u2019s still ongoing). The primary reason I opted for the proposed changes (version, package_name, package_version) is because the solidity compiler currently supports the version keyword to define the metadata specification version - which maps nicely to what used to be the manifest_version field. I\u2019d like to hear from @chriseth his thoughts? And whether the changes proposed by @rumkin could be easily adopted by the compiler. In terms of camelCase vs snake_case - it\u2019s a more significant breaking change. I\u2019m open to the change if there is general consensus that it\u2019s important / worthwhile. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.690104166666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gh1dra",
                    "index": "8",
                    "likes": "0",
                    "time": "11/03/2020-18:44:07",
                    "content": "Is there a particular reasoning for why the devdoc and userdoc are being surfaced for a particular contract inside contract_types? From my understanding of the spec, those fields be made available if the CompilerInformationObject field is already given. Is the idea to give users the choice about what kind of information they choose to provide about the compilation? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.666666666666668
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chriseth",
                    "index": "9",
                    "likes": "0",
                    "time": "12/03/2020-13:01:31",
                    "content": "I\u2019m fine with breaking Solidity metadata with regards to \u201cversion\u201d if it is a dealbreaker for EthPM as long as it is still possible to easily determine whether the given json is a v1 Solidity metadata json. I would also prefer camelCase. Funther remarks (I\u2019m really not sure if this forum-style discussion is the best way to do this): sources: \" Paths must resolve to a path within the current virtual directory.\" - do we really need this requirement? What does it mean for a path to resolve to such a path? How do you determine if it resolves to a directory or to a file? \u201ccontract_types\u201d: If there are multiple contract types specified - is there a way to provide the \u201cmain\u201d contract in some way? For Solidity metadata, there is exactly one contract type that is the one currently being compiled. Is the expectation that in this case, there is only one item in this object? contract alias: In the Solidity compiler, we identify names by prefixing the file name (including path) followed by a \u201c:\u201d. How do contract aliases identify the actual contract in the source? Why is the compiler a sub-field of the contract type? I see that different compilers could be used for different contract, but in that case, shouldn\u2019t the sources also be a sub-field of the contract type? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.515046296296297
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rumkin",
                    "index": "10",
                    "likes": "0",
                    "time": "21/03/2020-12:28:54",
                    "content": " I\u2019m really not sure if this forum-style discussion is the best way to do this  What\u2019s the best place to do so? Let\u2019s move it there. It\u2019s possible to separate some questions into issues, but IDK where to put them.  If there are multiple contract types specified - is there a way to provide the \u201cmain\u201d contract in some way?  I think it\u2019s reasonable to define default keyword in Solidity to specify it explicitly. It would help to export things with automated tools. Libraries authors usually define single contract per file, but it\u2019s only an agreement and it\u2019s not certain for all libraries. Export such a contract as the main one doesn\u2019t seem correct due to this uncertainty. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.617772108843537
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "11",
                    "likes": "1",
                    "time": "24/03/2020-16:14:19",
                    "content": " Is the idea to give users the choice about what kind of information they choose to provide about the compilation?  @gh1dra The compiler field is for information about the compiler and its settings that were used to generate the outputs (abi, bytecodes, userdoc, devdoc) rather than containing the outputs of the compilation. As you said, this gives the user more flexibility in choosing what fields they want or are able to include in a manifest.  I\u2019m fine with breaking Solidity metadata with regards to \u201cversion\u201d if it is a dealbreaker for EthPM  It\u2019s not a dealbreaker for me, but I do prefer the scheme (\"manifest\", \"name\", \"version\") that @rumkin proposed the best. It\u2019s the cleanest / easiest to understand.  as long as it is still possible to easily determine whether the given json is a v1 Solidity metadata json.  If we adopt this scheme, I\u2019m not so sure this will be easily achieved. As @fubuloubu pointed out, there will be ethpm v1 & v2 manifests that have a \"version\" field of \"1\" (referring to the version of that specific package release, rather than the specification it conforms to). These will be impossible to simply distinguish from v1 Solidity metadata json (which also have a \"version\" field of \"1\"). Unless the tooling has the knowledge to search for a \"manifest\" field (required in all ethpm v3 manifests), validate that it is \"3\" - and then it will be able to distinguish b/w the two specifications. So it is possible reliably determine which specification a json object is, but it won\u2019t be trivial. If this is an acceptable amount of complexity for @chriseth, I\u2019ll update the spec to reflect this change.  I would also prefer camelCase.   I\u2019m also ok with this change. Unless any of the python/vyper ppl have strong objections, I\u2019ll update the spec.  sources: \" Paths  must  resolve to a path within the current virtual directory.\" - do we really need this requirement? What does it mean for a path to resolve to such a path?  For ethpm, we need the ability to faithfully recreate the original source tree. Otherwise, when users \u201cinstall\u201d a package to disk - if the paths are not the same paths of the original source tree, then they might not be able to re-compile the sources. In ethpm v1/v2 we required all paths to be relative paths that begin with ./ (the root of the virtual directory), which has worked well. Though, I understand the solidity compiler might not want to enforce such a requirement. If we relax this requirement, we\u2019ll need to define an additional mechanism (like a filesystem key) that maps the paths used to valid filesystem paths - which will be required for packages to have the capability to be written to disk (\u201cinstalled\u201d).  How do you determine if it resolves to a directory or to a file?  If the path points to a content-addressed uri, the uri must be resolved to determine whether it\u2019s a directory or a file. The only other option is for the path to point to an inlined string of the source contract which would always be a single file.  If there are multiple contract types specified - is there a way to provide the \u201cmain\u201d contract in some way? For Solidity metadata, there is exactly one contract type that is the one currently being compiled. Is the expectation that in this case, there is only one item in this object?  Yup, that\u2019s how I\u2019d see it working out.  contract alias: In the Solidity compiler, we identify names by prefixing the file name (including path) followed by a \u201c:\u201d. How do contract aliases identify the actual contract in the source?  In ethpm a contract alias is defined as <contract-name>[<identifier>]. In ethpm v1/v2 there was no mechanism to map a contract type to a source - however in v3 it seems to me as though the compilationTarget field in the compiler settings would serve this function.  Why is the compiler a sub-field of the contract type? I see that different compilers could be used for different contract, but in that case, shouldn\u2019t the sources also be a sub-field of the contract type?  I\u2019m not sure I understand this concern exactly. There are packages that would be useful with just \"sources\" and no \"contract_types\". Also, different compilers could be used to generate different \"contract_types\" for the same source. This would introduce a lot of redundancy if sources were located in \"contract_types\".  I\u2019m really not sure if this forum-style discussion is the best way to do this  Agreed, I\u2019m starting to think that it\u2019s time to move this to github, where we can have more nuanced threads around specific concerns. I\u2019ll work on migrating the changes discussed here to the ethpm-spec repository - and link it here once it\u2019s updated. ",
                    "links": [
                        "https://github.com/ethpm/ethpm-spec"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.800773809523809
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chriseth",
                    "index": "12",
                    "likes": "1",
                    "time": "24/03/2020-20:59:38",
                    "content": "Can we just schedule a call tomorrow or on Thursday and settle most of the questions in on hour?  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "13",
                    "likes": "1",
                    "time": "24/03/2020-21:29:08",
                    "content": "Good call - let\u2019s aim for 9AM CST / 3PM CET on Thursday. It\u2019s flexible so if anybody would like to join but has a conflict - we can adjust the time as needed. I\u2019ll post a zoom link here a couple minutes before the time we settle on. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 8.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "14",
                    "likes": "0",
                    "time": "26/03/2020-13:54:46",
                    "content": "Here\u2019s the zoom link for the call taking place in about 5 minutes    Zoom Video    Join our Cloud HD Video Meeting now Zoom is the leader in modern enterprise video communications, with an easy, reliable cloud platform for video and audio conferencing, chat, and webinars across mobile, desktop, and room systems. Zoom Rooms is the original software-based conference...       ",
                    "links": [
                        "https://us04web.zoom.us/j/902568522?pwd=VlFtTldGNzFFcFpOdUVjOWdlcTFkdz09"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.680555555555555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "15",
                    "likes": "0",
                    "time": "26/03/2020-14:25:25",
                    "content": "Updated zoom link    Zoom Video    Join our Cloud HD Video Meeting now Zoom is the leader in modern enterprise video communications, with an easy, reliable cloud platform for video and audio conferencing, chat, and webinars across mobile, desktop, and room systems. Zoom Rooms is the original software-based conference...       ",
                    "links": [
                        "https://us04web.zoom.us/j/355814183?pwd=OW5uWWIvZjFUZDl6c3pOUkFZN0NYQT09"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.680555555555555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chriseth",
                    "index": "16",
                    "likes": "1",
                    "time": "26/03/2020-15:54:32",
                    "content": "Thanks for the call, that was very insightful! During the call, ben was briefly talking about importing interfaces through their JSON-ABI as an interoperability measure. The relevant issue in the Solidity repo is here: https://github.com/ethereum/solidity/issues/1687 A comment by alex suggests to put these abi-json interfaces in their own files in the standard-io-input (as part of the \u201csources\u201d field) and  add a \u201ckind\u201d field for each source file where this would be something like \u201cabi-json\u201d. This \u201ckind\u201d field would also make it easier for projects spanning multiple languages. ",
                    "links": [
                        "https://github.com/ethereum/solidity/issues/1687#issuecomment-559143276"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.65625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rumkin",
                    "index": "17",
                    "likes": "0",
                    "time": "26/03/2020-19:28:12",
                    "content": "For interfaces import I\u2019d suggest to have an ability of file import, like so: interface Token from './erc20.json'  And for JSON files with custom structure it\u2019s possible to define a path inside of JSON: interface Token from './erc20.json#contracts[0].abi'  Where ./erc.json is a path to ABI file and #contracts[0].abi is a path inside of JSON object. It uses some trick as URL suppose hash wouldn\u2019t be sent with a request and should be handled on the client, it\u2019s safe to use hash in paths like so. And handle it with solidity compiler itself. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "18",
                    "likes": "0",
                    "time": "07/04/2020-00:14:17",
                    "content": "@rumkin I\u2019m not hugely familiar with how the solidity compiler handles imports - but this seems a little out of scope for the ethpm v3 specification. I could be wrong though, so feel free to bring this up at the next sync. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.525
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "19",
                    "likes": "2",
                    "time": "07/04/2020-00:23:09",
                    "content": "Hey Guys! Hope everyone\u2019s well. The ethpm docs now reflect the changes we\u2019ve discussed. http://ethpm.github.io/ethpm-spec/ There is now a machine-readable schema to validate v3 manifests - it can be found under spec/v3.spec.json in the ethpm-spec repo. The examples in the ethpm-spec repo have been updated to reflect the changes in the spec - for a visual idea of what v3 packages might look like. You can find them under their respective folders under /examples/ with the file name v3.json @ https://github.com/ethpm/ethpm-spec This spec is still a WIP - though we\u2019ll be trying to finalize it within the next sync or two - so the sooner we get any suggested changes, the better. To give everyone enough time to go over the changes / examples, let\u2019s plan our next sync for Thursday, April 16 - at 9AM CST / 3PM CET. If that time doesn\u2019t conflict with anybody, I\u2019ll post a zoom link here shortly before. Cheers! ",
                    "links": [
                        "https://github.com/ethpm/ethpm-spec"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.357142857142857
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "20",
                    "likes": "0",
                    "time": "16/04/2020-13:56:07",
                    "content": "Here\u2019s the link for the sync in 5 minutes.    Zoom Video    Join our Cloud HD Video Meeting now Zoom is the leader in modern enterprise video communications, with an easy, reliable cloud platform for video and audio conferencing, chat, and webinars across mobile, desktop, and room systems. Zoom Rooms is the original software-based conference...       ",
                    "links": [
                        "https://us04web.zoom.us/j/79099681560?pwd=S01qaDFmb0c1Z1QvM1BvMTZXNVUxZz09"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.680555555555555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "21",
                    "likes": "0",
                    "time": "30/04/2020-00:45:00",
                    "content": "Just a heads up, if you\u2019re not already attending the solidity online conference. There\u2019s going to be an ethpm discussion tomorrow at 8:55 pm central european time. The conversation will revolve around ethpm devx and the v3 technical specification. If you can make it, it\u2019d be great to see everyone there! https://interspace.solidity-summit.ethereum.org/ ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "22",
                    "likes": "1",
                    "time": "30/04/2020-19:35:07",
                    "content": "Hey all - to continue with the discussion from today\u2019s solidity summit we\u2019ll have a call next Thursday, May 7 at 9AM CST / 3PM CET. I\u2019ll post a zoom link here shortly before. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "23",
                    "likes": "0",
                    "time": "06/05/2020-20:39:34",
                    "content": "General friendly reminder / ping about the sync tomorrow. It should be the last sync before finalizing the v3 spec! Hope to see y\u2019all there - i\u2019ll post the zoom link here shortly before start time. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.53125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "24",
                    "likes": "0",
                    "time": "06/05/2020-20:56:44",
                    "content": "Sorry for any confusion, my timezone math was off. Correct times for the sync: 8AM CDT / 9AM EDT / 3PM CEST ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 2.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "25",
                    "likes": "0",
                    "time": "07/05/2020-12:58:28",
                    "content": "sync link: https://us04web.zoom.us/j/73933580804?pwd=Q3MrSDUwd2IzUVZLSUs2VDJuMnpkdz09 ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jpitts",
                    "index": "26",
                    "likes": "2",
                    "time": "07/05/2020-21:26:10",
                    "content": "Would you consider this a \u201clast call\u201d at this point? I will Tweet something out to see if there are others who would like to submit feedback. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "27",
                    "likes": "1",
                    "time": "08/05/2020-14:17:31",
                    "content": "Yeah, @njgheorghita would it be possible to draft a blog post about this so we can Tweet it out and get Last Call comments on it before you draft the EIP? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "28",
                    "likes": "2",
                    "time": "08/05/2020-14:22:14",
                    "content": "Yeah, that would be excellent. Tweet blasts are much appreciated as my twitter game is pretty weak. I\u2019ll type it up and link it here as soon as it\u2019s ready. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.729166666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "29",
                    "likes": "2",
                    "time": "11/05/2020-21:31:12",
                    "content": "ping @fubuloubu @jpitts. I wrote up a short outline of the proposed v3 changes here - thanks for the blast!    Medium \u2013 11 May 20    ethpm V3 is coming! ethpm is getting an update from V2 to V3. In a joint effort between many great teams, we have finalized a proposed set of changes for\u2026 Reading time: 2 min read       Let me know if I forgot something or got anything horribly wrong. I\u2019m also proposing a spec freeze date of May 18 - which can be delayed if there are any problems found. ",
                    "links": [
                        "https://medium.com/@nickg_82582/ethpm-v3-is-coming-500d0edd38c4?sk=79441c8f492b9d43186063915ffc7594"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.1125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "30",
                    "likes": "0",
                    "time": "17/12/2020-18:22:07",
                    "content": "Moving conversation here @njgheorghita since this isn\u2019t really about the EIP structure (which is all that should really be discussed in PRs).   I\u2019m specifically referring to the source checksum which explicitly says that it is required if there is no URI (meaning the file is not available on a content-addressable filesystem). Either you have a URI like ipfs://\u2026 or swarm://\u2026, or you don\u2019t. In the case that you do, the checksum field is redundant. In the case that you don\u2019t, the checksum field is useless.  In the case that you don\u2019t have a URI - it is required to include the contract source as a string (under the \u201ccontent\u201d key) in which case the checksum field is also required, containing a checksum object with the algorithm used to generate a hash and the resolved hash of the inlined source.  What is the purpose of including the checksum in this scenario?  What problem does it solve?  What value does it provide to the user? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.583333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "31",
                    "likes": "0",
                    "time": "21/12/2020-15:50:46",
                    "content": "If my memory serves correctly, this requirement was enforced to enable tooling / frameworks to perform additional verification of any in-lined source assets. It is possible for ethpm packages to be imported solely as a json file (for example\u2026 if a user copy/pastes the json directly from an ipfs explorer rather than importing via the ipfs uri), in which case requiring the checksum provides some extra confidence in the authenticity of the inlined sources. However, if a user is interacting with the ethpm ecosystem as it was intended, then this requirement is overkill. I\u2019d be on board to update the requirement to include a Checksum object along with inlined sources to just a recommendation, unless there are other objections. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.96875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "32",
                    "likes": "1",
                    "time": "22/12/2020-04:08:47",
                    "content": "Why not checksum the entire file in that case, as is common practice throughout the industry (serving a file hash as well as the file itself to protect users from MITM attacks)?  This way, users in such a scenario can use existing tooling rather than needing custom tooling.  This also would mean the entire file would be checksummed, rather than just part of the file. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.387499999999999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "33",
                    "likes": "0",
                    "time": "08/01/2021-18:15:23",
                    "content": "Just mandate the IPFS CID, and then allow an alternative link that would give the same file as if you downloaded it from IPFS ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "34",
                    "likes": "0",
                    "time": "09/01/2021-18:26:04",
                    "content": "Just to have some more concrete examples to work with here, these are the three ways that the spec currently allows users to include a source.  In-lined source requires a Checksum object  {\"sources\": { \t\"Owned.sol\": { \t\t\"content\": \"pragma ...\", \t\t\"checksum\": { \t\t\t\"algorithm\": \"sha256\", \t\t\t\"hash\": \"a1b2c3...\" \t\t} \t}, }}   Source identified by a content-addressed URI does not require Checksum object  {\"sources\": { \t\"Owned.sol\": { \t\t\"uls\": [\"ipfs://Qm...\"] \t} }}   Source identified by a generic URI (aka a URI without a checksum of its contents) requires a Checksum object.  {\"sources\": { \t\"Owned.sol\": { \t\t\"uls\": [\"github.com/myproject/Owned.sol\"], \t\t\"checksum\": { \t\t\t\"algorithm\": \"sha256\", \t\t\t\"hash\": \"a1b2c3...\" \t\t} \t} }}  @fubuloubu If I understand your example correctly, it would fall under the third category where the package creator could populate the Checksum object with the ipfs cid. @MicahZoltu Correct me if I\u2019m wrong, your concern is that in #1 requiring the Checksum object is redundant. I\u2019m ok with dropping the requirement for a Checksum object to a recommendation in the first scenario. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 3.2105263157894735
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "35",
                    "likes": "1",
                    "time": "10/01/2021-07:08:24",
                    "content": "    njgheorghita:  Correct me if I\u2019m wrong, your concern is that in #1 requiring the Checksum object is redundant. I\u2019m ok with dropping the requirement for a Checksum object to a recommendation in the first scenario.   Yes, in (1) the checksum provides no value because the payload source and the checksum source are the same which means it is trivial to put in a checksum that matches the provided payload. In (2) no checksum is needed. In (3) a checksum is valuable and I am OK with it being required there. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.458333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "36",
                    "likes": "0",
                    "time": "03/02/2021-22:30:27",
                    "content": "Sorry for the delay - I\u2019ve updated the EIP here. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 2.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "37",
                    "likes": "1",
                    "time": "11/02/2021-22:55:08",
                    "content": "Is this ready for Last Call? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "38",
                    "likes": "0",
                    "time": "16/02/2021-12:09:23",
                    "content": "Last Call pr is up! https://github.com/ethereum/EIPs/pull/3269 Review period ends March 2. If there are any last minute suggestions / amendments to discuss please post them here asap! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ShadeUndertree",
                    "index": "39",
                    "likes": "1",
                    "time": "10/03/2021-18:30:12",
                    "content": "I implemented a basic version of this spec for usage with brownie / vyper compilation, and overall I found it fairly natural and straightforward, the team clearly put a lot of thought into developing this spec. The only thing that was a bit confusing for me was the installPath property of the Source object. This isn\u2019t needed for Vyper and I think this may be Solidity specific? It could be helpful to add a comment to the spec specifying anything that\u2019s specific to one language\u2019s compiler vs. another, etc. Alternatively, another option would be to adjust the name of installPath to something like \u2018LocalPath\u2019 or \u2018CachePath\u2019. Using Vyper I just compile from an in-memory string, whereas with Solidity this doesn\u2019t seem possible hence the need for this property, if I\u2019m understanding correctly. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.1375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/esaulpaugh",
                    "index": "40",
                    "likes": "0",
                    "time": "11/03/2021-02:23:53",
                    "content": "I never understood the point of the 0x prefix. It seems like an attempt to mix type information into the data itself. Ironically, something like \u201c0x44\u201d is valid Base64 and valid ASCII and a million other things, yet \u2018x\u2019 is not a valid hex character. So decoders have to decide whether to reject it or require it, or allow it optionally but check whether it\u2019s actually there). I don\u2019t think it improves readability by computers or humans. And certainly not interoperability. \u20180x\u2019 is good for programming languages where multiple represenations can be used when assigning a variable. Multiple representations for the same field seems like a bad idea inside a standard. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.871031746031746
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "41",
                    "likes": "1",
                    "time": "08/04/2021-14:46:59",
                    "content": "Agreed that installPath is not the most intuitive design. If I\u2019m remembering correctly, we went with this design in order to preserve the rule that the key in the sources object can be any unique string - rather than the filepath itself. You\u2019re correct, this is important for compatibility with the solidity compiler output, which was one of the primary design goals for v3. Thanks for bringing this up though, it\u2019s really helpful feedback. I\u2019ll add a note to the spec, but personally, I\u2019m not convinced that it\u2019s worth changing the spec. If you or somebody else feels strongly about this, I\u2019m happy to give it further consideration. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.503472222222221
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/njgheorghita",
                    "index": "42",
                    "likes": "0",
                    "time": "08/04/2021-14:54:49",
                    "content": "The 0x prefix is used to identify that the following string is hex encoded. It\u2019s fairly standard encoding practice across the ethereum ecosystem. The spec and tooling supports unprefixed hex-strings, but specifies that all hex-strings should use the 0x prefix for consistency. Personally, I always use 0x prefixed hex-strings and rarely see unprefixed hex-strings in the wild. The spec also specifies that the package must use utf-8 encoding. Tooling shouldn\u2019t have a problem decoding hex-strings according to the spec, all that\u2019s needed is a simple check whether or not hex-string fields have the 0x prefix, and then handle those fields accordingly. I\u2019m not eager to change the hex-string encoding conventions of the spec at this point, especially since it\u2019s in-line with broad standard practice in the community and I\u2019ve never heard concerns from tooling developers or users. ",
                    "links": [
                        "http://ethpm.github.io/ethpm-spec/v3-package-spec.html#document-format"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.256944444444445
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ShadeUndertree",
                    "index": "43",
                    "likes": "0",
                    "time": "08/04/2021-15:17:46",
                    "content": "I\u2019d be quite happy with a note added to the spec. I understand not changing the spec itself at this point in the process. Thank you very much for your consideration on my feedback! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.8125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/esaulpaugh",
                    "index": "44",
                    "likes": "0",
                    "time": "11/04/2021-22:42:49",
                    "content": "Bouncycastle and apache commons (commons-codec) both barf on 0x (rightly, in my opinion). Seems strange that ethereum would require a bespoke implementation of hexadecimal decoding. I do know that cryptographic hashes are by convention never prefixed with 0x. So keccak256 fields are violating that convention. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.589285714285714
                }
            ]
        }
    ],
    "group_index": "1023"
}