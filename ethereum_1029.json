{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-1102-opt-in-provider-access/414",
            "title": "EIP-1102: Opt-in provider access ",
            "index": 414,
            "category": [
                "EIPs"
            ],
            "tags": [
                "provider-ring"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "1",
                    "likes": "7",
                    "time": "18/05/2018-23:13:34",
                    "content": "Hi everyone. My name is Paul Bouchon and I recently joined the MetaMask team. MetaMask and most other tools that provide access to Ethereum-enabled environments do so automatically and without user consent. This exposes users of such environments to fingerprinting attacks since untrusted websites can check for a provider object and reliably identify Ethereum-enabled clients. This proposal outlines a new dapp initialization strategy in which websites request access to an Ethereum provider API instead of relying on its preexistence in a given environment. Feedback welcome and encouraged! Proposal draft cc @danfinlay @ricburton Related to Web3 Providers for the Future ",
                    "links": [
                        "https://ethereum-magicians.org/t/web3-providers-for-the-future/380",
                        "https://ethereum-magicians.org/t/eip-1193-ethereum-provider-api/640/18",
                        "https://ethereum-magicians.org/t/the-ux-of-eip-1102/814",
                        "https://ethereum-magicians.org/t/forming-a-ring-wallet-developers/733/28",
                        "https://ethereum-magicians.org/t/web3-providers-for-the-future/380/2",
                        "https://ethereum-magicians.org/t/council-of-prague-announcement/1006/12",
                        "https://ethereum-magicians.org/t/council-of-paris-2019-call-for-agenda-topics/2442/8"
                    ],
                    "GPT-summary": "The author, Paul Bouchon, proposes a new dapp initialization strategy for Ethereum-enabled environments to prevent fingerprinting attacks. He explains the proposal and invites feedback. The post also mentions related proposals and tags relevant people. A 3rd party could give constructive criticism or ask questions about the proposal.",
                    "GPT-proposal-categories": [
                        "Privacy, Security and risk management",
                        "Interoperability and Scaleability",
                        "Smart contract updates",
                        "Community and engagement"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.944602272727273
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "2",
                    "likes": "2",
                    "time": "19/05/2018-02:21:54",
                    "content": "Since @bitpshr didn\u2019t introduce himself, I\u2019ll just briefly share that he\u2019s one of the newest members of the MetaMask team, has been doing some great work on it, and has begun driving our privacy-centric opt-in provider effort with this spec! MetaMask hopes to develop its future behavior based on this proposal, so please consider it seriously! cc @andytudhope ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving entirely positive feedback on proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.729166666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "3",
                    "likes": "0",
                    "time": "19/05/2018-03:13:02",
                    "content": "Ah! \u201cAbout me\u201d sentence added, thanks @danfinlay. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/boris",
                    "index": "4",
                    "likes": "1",
                    "time": "19/05/2018-03:51:11",
                    "content": "Welcome! Great work @bitpshr! These are all desktop web-centric examples \u2013 does some of this differ in a mobile webview context? (I don\u2019t think it does for embedded webviews, and \u201cnative\u201d clients would be \u2026 totally different, potentially, but I thought I\u2019d ask). This concerns web3 only \u2013 do you think guidance / best practices on showing different addresses for different apps or other \u201cauto address creation / switching\u201d should be included in this proposal, or handled elsewhere? Because without address switching, we\u2019re still doing 100% correlation of activities between dapps on accounts. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.597222222222222
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/andytudhope",
                    "index": "5",
                    "likes": "1",
                    "time": "19/05/2018-16:13:55",
                    "content": "Thanks @bitpshr - have shared with the Status team. I\u2019m not sure there is a big difference for us currently, as we use embedded webviews when navigating to DApps - we just care that those DApps can easily identify which provider is being used and use that for some UI info/education. I think \u201cauto address creation / switching\" should be handled elsewhere, and think it ties more into what @alexvandesande was saying about smooth logins: https://github.com/ethereum/EIPs/pull/1078 ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.916666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "6",
                    "likes": "1",
                    "time": "19/05/2018-18:51:40",
                    "content": "Thanks @boris, and great question about web vs. other platforms. This proposal intentionally omits platform-specific details like messaging protocols, and instead chooses only to detail a high-level strategy that can be applied agnostically of platform or available APIs. For example, a web3 environment built on a mobile platform without a DOM wouldn\u2019t use postMessage but should still follow the strategy outlined in this proposal to provide the same parameterized, user-approved web3 access. I updated the proposal to explicitly state that it\u2019s intended to be applied across platforms and that any code is example code. @andytudhope thanks for the feedback. I agree that address creation / switching and anything beyond user-approved web3 access is important but outside the scope of this specific proposal. This proposal is meant to serve a single purpose: to provide user-approved, parameterized web3 access in web3-enabled environments. With this proposal in place, other features can be built on top of it, such as requesting specific account types, accounts with specific balances, etc. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.680803571428572
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cfly",
                    "index": "7",
                    "likes": "3",
                    "time": "19/05/2018-23:49:59",
                    "content": "Thanks for posting this, @bitpshr. This proposal, as-is, assumes that there is only one wallet listening on the window. If opt-in web3 access indeed becomes the new standard, then there must be a way for the dapp to specify which wallet the request is intended for. Otherwise, you could get multiple wallets prompting sign-in. Have you considered adding an identifier to the request, which would specify the intended wallet? Example: window.postMessage({ type: 'WEB3_API_REQUEST', id: 'METAMASK' }); A discovery request type, which would send out a command to see which wallets, if any, are listening on the window, may be beneficial in some cases as well. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.883116883116883
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "8",
                    "likes": "1",
                    "time": "20/05/2018-03:16:26",
                    "content": "Interesting thought @cfly. While I think it\u2019s slightly contrived to think that multiple wallets would be listening on a given page in a given environment, I do think this case should be gracefully handled. For example, it\u2019s possible that a dapp browser could support the WebExtensions API and a user could have MetaMask installed. In this case (albeit slightly unrealistic) both the dapp browser environment and MetaMask would respond to a request for the web3 API. Proposal updated, good catch! As for a discovery API, I\u2019m not sure we could provide this in a way that doesn\u2019t still leave users susceptible to fingerprinting. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0892857142857135
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "9",
                    "likes": "2",
                    "time": "20/05/2018-03:53:00",
                    "content": "If there were a discovery API, this proposal would lose some of its privacy benefits. That said, this proposal is open-ended, and a client-preference parameter could easily be added later. If multiple wallets were listening at once in the meantime, I think it\u2019s nice that the user would get total control of which one they used to provide accounts with, already mitigating the \u201cmultiple colliding web3 extensions\u201d problem. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.033333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cfly",
                    "index": "10",
                    "likes": "1",
                    "time": "20/05/2018-16:27:22",
                    "content": "Good point about the discovery API. In my mind, the API would only disclose whether or not a user has a wallet type installed, but that\u2019s enough to be a cause for concern. However, the discovery API idea was just an afterthought. Mainly, I am trying to avoid 2+ sign-in windows popping up in a world of multiple web3-enabled browser extensions. Example: A dapp wants to add a Login with MetaMask as well as a Login with WalletB button. The issue is resolved as long as a wallet can filter out requests using an id. Thanks for amending the proposal, @bitpshr! I\u2019m wondering if it\u2019d be worthwhile to pass the id back in the wallet\u2019s response message as well. That way, if two requests are sent out, you know which wallet is responding. This could be excluded if you want dapps to rely on the injected provider to know who they\u2019re talking to (e.g. web3.currentProvider.isMetaMask). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.883333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "11",
                    "likes": "1",
                    "time": "20/05/2018-19:35:57",
                    "content": "@cfly I added the id property to the response, I think it makes sense given the use cases discussed. Thanks again for identifying the multiple-wallet case! ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "12",
                    "likes": "1",
                    "time": "21/05/2018-15:18:41",
                    "content": "I like the proposal, Thinking about it, could the request ask for a specific network too ? window.postMessage({ type: 'WEB3_API_REQUEST', id: 'METAMASK', networkId: 4 }); ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.166666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "13",
                    "likes": "0",
                    "time": "21/05/2018-17:15:03",
                    "content": "Yes, this proposal is deliberately forward-extensible, with an eye for requesting networks, and all kinds of specificity. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "14",
                    "likes": "1",
                    "time": "25/05/2018-15:09:42",
                    "content": "Another privacy enabling feature that would be cool would be that when the dapp asks the provider for the user\u2019s address, the provider returns a randomly generated 20-byte number.  The provider remembers this for the session and returns the same one each time.  Anytime the dapp makes a request of the provider, the provider will search and replace that 20-byte number with the user\u2019s actual address before submitting to the blockchain or returning a result to the dapp. This would allow users to use dapps without giving up their actual address to the dapp. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.85
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "15",
                    "likes": "0",
                    "time": "30/05/2018-05:43:57",
                    "content": "sounds like a good idea, but in practice, the address will be detectable through transaction/message being signed. Also if the provider replace the number with the actual address for every web3 call, you would just need a contract with a public method that return the msg.sender to get back the actual address. If it does not replace the number, then you forbid the dapp to actually get info about that address. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.583333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "16",
                    "likes": "0",
                    "time": "30/05/2018-06:32:26",
                    "content": "Hmm, good point that a dapp could get around this by creating a contract that returns the address encrypted, and the website has the decryption key.  Then MetaMask wouldn\u2019t know it needs to swap anything out, and thus return the address to the dapp. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "17",
                    "likes": "0",
                    "time": "31/05/2018-18:57:01",
                    "content": "After more discussion on the EIP pull request and valid points by @MicahZoltu and @Arachnid, this proposal shifted from defining an abstract platform-agnostic protocol to defining a concrete DOM-specific protocol for user-approved web3 access. All dapp browsers that currently expose web3 also expose a DOM, so it makes sense to make an immediately-actionable EIP to standardize existing DOM-specific implementations using uniform APIs. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 6.083333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jeluard",
                    "index": "18",
                    "likes": "1",
                    "time": "22/06/2018-12:39:45",
                    "content": "@bitpshr Have you considered extending this pattern to host specifics API? I guess it could be as simple as requesting using a different type. e.g. for status: access to whisper key, contacts, \u2026 ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "19",
                    "likes": "1",
                    "time": "04/07/2018-02:58:57",
                    "content": "Good idea for proposing 1102.  Agree that having an approval process will greatly help with privacy and, i believe it helps security in the long run. Since attacker can easily find out account balances and token holdings by simply having  account address, if the web application use the account address together with many other information available at the time of loading web app on browser, it will make it much easier for attacker to collect large amount of accounts and scan to find accounts valuable and vulnerable to exploit. Since this adds a handshake, have you considered adding API versioning information exchange at the time? In that we can allow future development to make use of it.  Again, kudos for proposing it. @xinbenlv ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.071924603174603
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/serso",
                    "index": "20",
                    "likes": "0",
                    "time": "09/08/2018-12:08:08",
                    "content": "Why reinventing the wheel and not using existing Permissions API? See, for example: https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API/Using_the_Permissions_API ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "21",
                    "likes": "0",
                    "time": "09/08/2018-14:05:09",
                    "content": "Hi @serso. While the experimental Permissions API initially seemed promising for the purposes of opt-in provider access, key limitations made it less than ideal for this specific use case. The current Permissions API doesn\u2019t offer the ability to define custom permissions and was only intended to provide a better API to request native browser permissions like \u201cgeolocation\u201d or \u201cnotification\u201d. Requesting a non-standard permission - like \u201cethereum\u201d - throws an Error. While dapp browsers could override the permissions.query method to explicitly handle a non-standard \u201cethereum\u201d permission request, malicious sites could then initiate this non-standard request and know they\u2019re in a dapp browser if no Error is thrown as expected. For example: The following non-standard permission request will immediately throw: navigator.permissions.query({ name: 'ethereum' }); // TypeError: The provided value ethereum is not a valid PermissionName.  If dapp browsers override permissions.query to handle \u201cethereum\u201d requests, it will not immediately throw: const originalQuery = navigator.permissions.query; navigator.permissions.query = (query) => { \tif (query.name === 'ethereum') { \t\t// Handle provider request...     } else { \t\treturn originalQuery.apply(navigator.permissions, arguments);     } }; navigator.permissions.query({ name: 'ethereum' }); // undefined  Because the Permissions API is meant only for predefined permissions and doesn\u2019t (yet) allow for dynamically-defined permissions in a given context, any support at all for a non-standard \u201cethereum\u201d permission would allow malicious websites to fingerprint and track Ethereum users. The Permissions API also displays a default browser confirmation dialog and doesn\u2019t allow custom confirmation UIs; this limits the type of information that can be presented to the user, but this issue is less important. Thanks for your comment, let me know if you have any other ideas around this. I agree that the Permissions API would be great to leverage if it was safely usable for non-standard permission types. We\u2019ll continue to monitor it closely for EIP-1102 applicability. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.407196969696971
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/anxolin",
                    "index": "22",
                    "likes": "0",
                    "time": "10/08/2018-08:55:23",
                    "content": "Hi! Nice proposal. In the proposal it says that: IF user rejects IF non-Ethereum environment     NOOP[4]  I think it would be a good idea to also notify the dapp when the user reject the access, so can detect the case and give a better user feedback. Also, would it make sense to allow also to request a list of provider details, so you can prompt the user with a wallet selector, then the user chooses his preferred one, so we can request the injection of that particular wallet? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 7.458333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/anxolin",
                    "index": "23",
                    "likes": "1",
                    "time": "10/08/2018-09:19:43",
                    "content": "Hi again, also I was wondering why do we need still a global variable ethereum for the new method. Could we just send it as as an argument when the extension triggers the listener? Another small detail, why the event s called message and then we check for the type ETHEREUM_PROVIDER_SUCCESS?. I think the event name can be an arbitrary name, so it can be more specific. Right? Besides I think message is kind of standard one used for websockets: https://developer.mozilla.org/en-US/docs/Web/Events WDYT? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.651154401154401
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/serso",
                    "index": "24",
                    "likes": "2",
                    "time": "10/08/2018-11:32:57",
                    "content": "Thank you for the prompt response, @bitpshr. I\u2019ll bring it up for an [internal] discussion at Opera. Maybe we can help you with the web standards. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "25",
                    "likes": "0",
                    "time": "10/08/2018-12:04:29",
                    "content": "Hi @anxolin. Thanks for your comments. Responses below:  I think it would be a good idea to also notify the dapp when the user reject the access, so can detect the case and give a better user feedback.  If dapps were notified when a user rejected provider access, that would expose enough information to allow malicious sites to continue uniquely identifying Ethereum users. For example, if a malicious site initiates a provider request, a user rejects access, and the malicious site is notified, the site now knows the user is an Ethereum user within a dapp browser. Even without provider or account access, a malicious site can still run targeted ad and phishing campaigns simply by knowing a certain IP address is associated with Ethereum use. I agree that this means dapp UX will need to change, and there are discussions around this very topic. Still, the lack of notification of rejection is a crucial piece to this protocol\u2019s privacy.  Also, would it make sense to allow also to request a list of provider details\u2026  This is a very good idea. The request protocol outlined in this proposal was intentionally designed to be open-ended so that future EIPs can build on it and add new information to the request. @danfinlay had some thoughts around this idea as well, such as requesting a specific account type on a specific network when requesting a provider.  Could we just send it as as an argument when the extension triggers the listener?  Because the provider request protocol leverages window.postMessage, it\u2019s not possible to return the provider object as an argument to the listener. Data sent via window.postMessage is serialized using structured cloning which means the provider object\u2019s functions would be lost. Additionally, while some browsers support a third transfer argument when calling window.postMessage to transfer an object between two windows, browser support is very limited. The only viable way to respond with a full provider (for now) is global injection.  Another small detail, why the event called message and then we check for the type ETHEREUM_PROVIDER_SUCCESS? I think the event name can be an arbitrary name, so it can be more specific.  The protocol makes use of window.postMessage to request a provider, and then listens for the browser to post a message using window.postMessage in response. You bring up an interesting point: the dapp browser could respond by triggering an Ethereum-specific event listener, negating the need to sort through other posted messages based on a type. Part of me likes the symmetry of posting a message, then listening for a posted message, but I will experiment with this today for security. ",
                    "links": [
                        "https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.744035594035593
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "26",
                    "likes": "3",
                    "time": "10/08/2018-14:02:52",
                    "content": "If we chose to emit an event instead of post a response message after user approval as suggested by @anxolin, dapp browsers could return the provider object to the event listener instead of injecting it globally. We could go from this: window.addEventListener('message', ({ data }) => {     if (data && data.type && data.type === 'ETHEREUM_PROVIDER_SUCCESS') {         const networkVersion = await window.ethereum.send('net_version', []);     } }); window.postMessage({ type: 'ETHEREUM_PROVIDER_REQUEST' }, '*');  To something like this: window.addEventListener('ethereumprovider', (ethereum) => {     const networkVersion = await ethereum.send('net_version', []); }); window.postMessage({ type: 'ETHEREUM_PROVIDER_REQUEST' }, '*');  There wouldn\u2019t be any immediate fingerprinting threat since an event would only be emitted after user approval. What do you think? @anxolin @ryanio @danfinlay @andytudhope @serso @brunobar79 ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 4.375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ryanio",
                    "index": "27",
                    "likes": "0",
                    "time": "10/08/2018-18:31:45",
                    "content": "Thanks for including me. Choosing to emit an event sounds nice. However, I found when coding the implementation in Mist that assigning the provider to window.ethereum is actually nice because on page load if the dapp has previously been authenticated by the user we can load the page with window.ethereum already available without needing another request. (Also in dev environments you could assume window.ethereum is available without needing to request it.) With sending an event, we wouldn\u2019t know when in the dapp lifecycle the listener would be set up to know when to emit. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.694444444444444
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "28",
                    "likes": "1",
                    "time": "10/08/2018-18:43:06",
                    "content": "Hi @ryanio, thanks for the feedback. I see your point about auto-injecting window.ethereum for already-approved sites, but this seems like an odd approach for approval caching since it requires dapps to check for window.ethereum before requesting a provider. If a domain has already been approved, rather than injecting window.ethereum automatically, why not still wait for a request, but respond immediately with the provider and show no user dialog? For reference, this is what MetaMask is doing. This approach allows domain caching (meaning users don\u2019t have to constantly re-approve the same dapp) while imposing no additional code on dapps (they still request and add a listener like normal and don\u2019t have to first check for window.ethereum.) It would also be trivial to dispatch an ethereumprovider event on the Window for local testing. I\u2019m starting to think the ethereumprovider event for success response is a cleaner API, but I\u2019m definitely open to more thoughts. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.5606060606060606
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/andrey",
                    "index": "29",
                    "likes": "4",
                    "time": "12/08/2018-08:18:16",
                    "content": "hey guys, I\u2019m Andrey , implementing 1102 in status.im. Agree with @bitpshr, ethereumprovider event looks cleaner, only one way how to get a provider, and safer, because we don\u2019t post a message for success response. We also implemented in status immediate response if the domain was allowed before. Do you plan to use CustomEvent? so it will be something like window.addEventListener('ethereumprovider', (event) => {     const networkVersion = await event.detail.ethereum.send('net_version', []); });  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dustinvs",
                    "index": "30",
                    "likes": "0",
                    "time": "13/08/2018-20:35:34",
                    "content": "So, re: The UX of EIP 1102 - looking for a way to guarantee both user control of privacy and preserve the relative ease of UX available with current Metamask/web3. My general idea to solve this is basically to find a way to automatically push a refresh and injection of window.ethereum based on an application requesting that, upon install of Metamask, their still-open tab will be able to have a pending request of availability somehow notify the user that they\u2019ve requested access, and then upon access being granted, initiate the reload and window.ethereum injection.  Doing so would not expose any user information without their request, while still allowing applications to have relatively seamless UX flow (with the workflow, 1. Request Metamask install and/or request acceptance, 2. Detect Metamask has been opened and accepted).  The en-queuing of such a request could be easily accomplished by storage of a specially keyed cookie or localStorage object (e.g., _web3_permission_pending_request).  Any risk of accidental acceptance of a website\u2019s pending permission requests could be mitigated by a combiation of (a) only showing requests originating from open tabs or domains, and (b) sufficiently clear UX on the part of the ethereum provider (e.g. Metamask).  I strongly encourage an approach like this for keeping UX simplicity. ",
                    "links": [
                        "https://ethereum-magicians.org/t/the-ux-of-eip-1102/814/16"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.823260073260074
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "31",
                    "likes": "0",
                    "time": "13/08/2018-21:49:24",
                    "content": "I like how clean this is, and would be in favor of it provided there are no major downsides we can think of. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.838541666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "32",
                    "likes": "0",
                    "time": "13/08/2018-21:50:51",
                    "content": "I prefer this kind of provider consistency even across dev environments, and I hope @ryanio is open to it. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "33",
                    "likes": "3",
                    "time": "14/08/2018-10:30:47",
                    "content": "We are currently implementing/testing provider injection of the GnosisSafe extension (safe.gnosis.io) and often have issues if we have both (the MetaMask extension and the GnosisSafe extension) installed. Since the GnosisSafe extension already uses a whitelisting approach to check if it should inject a web3 instance, we currently just override any pre-existing web3 instance (in that case the MetaMask instance). This is obviously super ugly and therefore we are quite happy about EIP-1102 and id field  I think having an event that returns the provider that should be injected is cleaner than just injecting into a global variable. It would be nice to provide the id of the wallet that emitted the ethereumprovider event. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.738095238095237
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "34",
                    "likes": "0",
                    "time": "15/08/2018-23:17:06",
                    "content": "Cross-posting this here for anyone not following the thread relating to UX around this proposal:     The UX of EIP 1102 UX Ring       Taking a step back, there\u2019s one main logic path that\u2019s made more diffuclt by the total privacy detailed in 1102: handling users who have no dapp browser installed. As many have mentioned, this is an important UX consideration, especially because it directly relates to user onboarding.  There are a few options I see:  Option 1: Total privacy  The first option is to adjust current dapp UX around web3 detection to meet the requirements set forth in EIP-1102 as written today. This option provides to\u2026     ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.755952380952381
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dustinvs",
                    "index": "35",
                    "likes": "0",
                    "time": "16/08/2018-01:41:23",
                    "content": "Has there been any discussion about simply using domain whitelisting without user requests and, say, having the Web3 provider toggle on or off for a specific domain based on clicking the navbar menu icon or a context menu therein?  You could optionally allow a side route for requests additionally such as via cookie/localStorage which would allow them to exist throughout the lifecycle of the web3 provider extension, as mentioned earlier, but a user could simply be instructed to \u201cclick the fox icon if it\u2019s gray\u201d in the Metamask example. By the way, part of me wonders if a web3 access request system opens the browser up to CPU usage measurement attacks which would negate the purpose of provider obfuscation anyway. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "36",
                    "likes": "0",
                    "time": "16/08/2018-02:54:14",
                    "content": "Hi @dustinvs. A true whitelist-based approach introduces its own UX issues by making all dapps inaccessible or unusable by default. Even if users got used to a flow of explicitly approving each new dapp they want to access, it seems odd to ask users to whitelist or approve a new dapp before they even see it. How does a user know they want to whitelist a dapp unless they can view it first? If instead you\u2019re suggesting that users can still view a dapp but the provider would be disabled unless the dapp is explicitly whitelisted, I\u2019m not sure how this UX is any better than EIP-1102 as written: dapps would still need to add fallback UX if they aren\u2019t whitelisted and need to know if they\u2019re in a dapp browser. This also requires users to know each browser-specific mechanism to enable a dapp (e.g. MetaMask may use an icon click, Status may use something different on mobile, etc.) Allowing dapps to request provider access dynamically and only when needed using a standard DOM API guarantees Ethereum user privacy in a browser-agnostic manner. It\u2019s also been suggested to use this same postMessage-based protocol for parameterized provider requests, such as requesting a specific account type on a specific network, something whitelisting can\u2019t easily support. The request / response protocol seems extensible, implementable, and safe, but the UX limitation of being unable to detect non-dapp browsers is a win for privacy but a potential loss for UX (at least based on flows that currently rely on global injection.) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.476957070707071
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dustinvs",
                    "index": "37",
                    "likes": "1",
                    "time": "16/08/2018-03:13:51",
                    "content": "It\u2019s not functionally different to, or incompatible with, any of the approaches to requesting access that have been discussed (edit, that is, besides a parameterized one).   Consider it a suggestion for implementing user-initiated requests outside of the scope of the dapp.  You\u2019re right that it\u2019s not quite a replacement. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.476190476190476
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "38",
                    "likes": "0",
                    "time": "16/08/2018-08:17:06",
                    "content": "We are currently using that approach for the Gnosis Safe Extension and in first user testing experienced that this is quite confusing for the user. UX wise I find this very complicated, since for the user it is easier if they are being told were to click and what to do. If you have to open the browser extension and enable whitelisting it makes it quite a lot harder for the users imo. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.666666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dustinvs",
                    "index": "39",
                    "likes": "0",
                    "time": "16/08/2018-16:27:34",
                    "content": "What I had in mind was simply the dapp instructing the user to install the extension and then click the icon in the navbar to enable or similar.  It\u2019s possibly worse UX than an app-initiated request, especially one based on a mouse/keyboard/touch event, although I suspect that if it\u2019s standardized and intuitive then it\u2019s an issue of training the user to perform a single action for  provider injection, as opposed to a different action for each site (if access cannot easily be requested dynamically by the app).  If the available options for whatever reason can no longer include an app-initiated request, then something like that becomes a must.  The UX issues are of course significantly different on mobile and desktop.  Anyway, this may be out of band for the discussion. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.255411255411255
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "40",
                    "likes": "3",
                    "time": "27/08/2018-21:33:23",
                    "content": "The protocol defined in EIP-1102 was originally intended to both standardize the way dapp browsers expose a provider and to do so in a way that makes it impossible to uniquely identify Ethereum users from non-Ethereum users. Despite the technical feasibility of this approach and the \u201ctotal privacy\u201d it provides, it requires a monumental shift in dapp UX: user on-boarding is made more difficult because dapps can\u2019t detect if a user has a dapp browser installed. We initially thought this level of privacy was clearly ideal, and only after the announcement of our rollout plan did the implied dapp UX receive full scrutiny. Rethinking total privacy Taking a step back, the original motivation behind EIP-1102 was to make provider exposure less obtrusive and safer. The proposal satisfies these requirements by requiring explicit user approval before exposing a provider. But the proposal goes one step further by also removing any fingerprintable API surface from the dapp context. This means that dapps aren\u2019t informed when a user rejects provider access or if they don\u2019t have a dapp browser installed. The idea behind this was to prevent malicious websites from associating IP addresses with Ethereum use and running targeted attacks. But this type of total privacy becomes less important as more browsers with unique user agents add crypto features such as Brave, Opera, or Toshi. Since these browsers are already identifiable by user agent and because they all support Ethereum use either directly or indirectly, malicious sites can already fingerprint many users as potential Ethereum users regardless of EIP-1102 or an injected provider. Considering these new UX findings and realizing that this type of fingerprint prevention is firmly stopgap in a future of maintstream, crypto-enabled browsers, it feels natural to revisit the goals and approach behind EIP-1102. An updated proposal After talking with various community members, weighing informative UX feedback, and realistically analyzing security risks around provider exposure, we drafted updates to EIP-1102 in which DOM environments expose a read-only provider until full provider access is approved by the user. By injecting a restricted provider on page load, dapps can still detect correct browser installation and initiate RPC requests to properly render their UI; by requiring user approval before fully-enabling the provider, users are still protected from unsolicited transactions and unwanted account exposure on untrusted websites. EIP-1102: Proposed updates (feedback encouraged) cc @danfinlay @andrey @serso @ryanio @dustinvs @rmeissner @JaceHensley @ricburton @dustinvs ",
                    "links": [
                        "https://github.com/bitpshr/EIPs/blob/1102-readonly-provider/EIPS/eip-1102.md"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.463383838383838
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/everton",
                    "index": "41",
                    "likes": "0",
                    "time": "28/08/2018-20:18:54",
                    "content": "Hello Paul, I am Everton Fraga from the ethereum Mist team. Great job on the proposed changes. I am glad you considered the user-agent case, as Mist users are not protected against this kind of targeting. But I thought about something that was sitting there even before you revisit this subject: if the majority of dapps happen to request {type: \u2026 id: 'metamask'} it would make no sense to non-Metamask DOM providers to take id into consideration and decide if it should respond to the request or not \u2014 they\u2019d respond positively anyway. So, to be future-proof and mitigate the risk of unnecessary fragmentation \u2013 or a potentially useless id parameter \u2014 if a dapp wants to make anything specific to metamask, instead of: DO REQUEST METAMASK_PROVIDER   SHOW FoxWithAHat END  It could perform: DO REQUEST ETHEREUM_PROVIDER   IF PROVIDER === METAMASK     SHOW FoxWithAHat   END END  Cheers! ",
                    "links": [
                        "https://github.com/bitpshr/EIPs/blob/fe4aba7221f4b3d32615d22d08ca917a93497470/EIPS/eip-1102.md#1-request"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.505303030303031
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "42",
                    "likes": "1",
                    "time": "29/08/2018-02:39:30",
                    "content": "Hi @everton, thanks for the feedback. The id property was originally intended to allow dapps to specify which wallet provider should service their request in scenarios where a user has multiple Ethereum extensions installed, but you\u2019re right: this shouldn\u2019t be codified into the proposal. If an extension or browser wishes to only respond to specific provider requests, they can establish their own proprietary API to do so (an id property being one option.) I updated the new draft of the proposal accordingly. Thanks again for the input. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.998376623376624
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "43",
                    "likes": "1",
                    "time": "03/09/2018-00:04:57",
                    "content": "After successful community iteration with additional browser teams and dapp developers alike, EIP-1102 has been formally updated to reflect the latest thinking on user-approved provider exposure: Browsers expose a provider populated with no accounts by default. Before initiating any RPC request that requires an account, like eth_sendTransaction, dapps must request a full provider by calling a new provider method, provider#enable. This method triggers the user interface that allows the user to approve or deny full provider access for a given dapp. If the user approves full provider access, the provider is populated with accounts and thus fully-enabled; if the user denies full provider access, the provider is left unchanged. This latest version of EIP-1102 avoids any previously-discussed UX issues and is now live for further review. The new protocol actively being investigated and implemented by privacy-conscious browsers including MetaMask, Mist, Status, and imToken. Additional feedback is both welcomed and encouraged. ",
                    "links": [
                        "https://ethereum-magicians.org/t/the-ux-of-eip-1102/814/30"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 6.317599067599068
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "44",
                    "likes": "0",
                    "time": "03/09/2018-08:50:11",
                    "content": "Personally I preferred the event driven solution more, since it also gave an alternative to the issue when the user has multiple web3 provider enabled. But as this might not really belong in this EIP it might make sense to remove it. (But I do think \u201cmultiple installed providers\u201d is something that needs to be thought about, especially when more standard browsers add default support, see Opera) Another question for me would be, are there any information exposed in the read-only provider, about what provider it is? I know from some of our projects that they require meta-mask right now. So currently they check isMetaMask, but by exposing this method in the read-only provider you already give out quite some info again (or maybe not?  ). I am asking this because we will probably expose a similar method for our provider and it would be nice to be consistent. EDIT: Why not make it possible that the injected ethereum object has information about all available providers. The dapp could then request which providers are installed and let the user choose (or if one is preferred just select that one). When a provider tries to inject the ethereum object it checks if it exists if not it creates it. Afterwards it adds itself as a possible provider. The flow for the dapp would stay nearly the same as right now, but it would be possible to support different providers. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.647959183673469
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "45",
                    "likes": "4",
                    "time": "03/09/2018-10:58:54",
                    "content": "Something I think was a mistake in the early designs of Ethereum was combining Ethereum network access and signing tool/credential store.  I would love to take this opportunity to split the two. A browser plug-in may provide both signing interface and Ethereum network interface, but the dapp should see them as two separate things, not a single thing. As a dapp user, I may use some public node like Infura or a semi-private node like QuikNode for getting data from the blockchain and submitting signed transactions to the blockchain.  I may then use a ledger or MetaMask for signing things. If we take this approach, then there would be no \u201cupgrading\u201d your connection to full access.  The Ethereum network provider would not know (or at least claim to not know) anything about your accounts/credentials and it would have no ability to sign anything.  The connected signing tool on the other hand would have privacy protecting features and not give up any information (even that it exists) until the user okays it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.400510204081632
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "46",
                    "likes": "0",
                    "time": "03/09/2018-14:01:10",
                    "content": "Hi @rmeissner, thanks for your feedback. An additional EIP could definitely specify that an object should be passed to the enable method that specifies things like a specific wallet ID, a specific account type, a specific network, etc. This may be one path to solving the \u201cmultiple installed providers\u201d situation you mentioned, but I think it\u2019s probably beyond the scope of this initial EIP as you suggested. Your concerns around multiple providers being injected at once are interesting; exposure protocol aside, you\u2019re right, this is a growing issue in the ecosystem. Also, a provider implementation can expose any non-standard method (like isMetaMask) in either read-only mode or full mode if they desire; for reference, MetaMask plans to expose the isMetaMask method in read-only mode so dapps can still react accordingly even before user-approved full access. Thanks again for your feedback. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.785714285714285
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "47",
                    "likes": "0",
                    "time": "03/09/2018-14:18:42",
                    "content": "@MicahZoltu I agree that an ultimate separation of blockchain access and transaction signing would be very beneficial, and I think it\u2019s a future we\u2019re all working towards. This requires a fairly large technical shift in dapp browser architecture since most rely on exposing an augmented provider that intercepts certain RPC calls to populate accounts and to show approval UIs. We\u2019re actively researching patterns to better separate signing interfaces from network interfaces, and thus the provider itself, but the ecosystem (and especially the user-facing dapp ecosystem) just isn\u2019t there yet. I don\u2019t feel that a proposal intended to standardize provider exposure and improve user privacy should determine the new paradigm for the separation of blockchain access and signers (though I\u2019m very interested in continuing to research this more.) At its core, this proposal directly strengthens user privacy by hiding user accounts and preventing unsolicited transaction requests on untrusted sites. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.913072047000618
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "48",
                    "likes": "0",
                    "time": "04/09/2018-02:03:16",
                    "content": "My understanding (which may be mistaken) is that this proposed change is a breaking change for all dapps, which is why it feels like a good opportunity to move over to a split interface. Am I wrong that this is a breaking change for dapps? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "50",
                    "likes": "0",
                    "time": "04/09/2018-03:05:25",
                    "content": "(posted from a friend\u2019s computer originally, reposting from my account) Yes, the current (and most likely final) form of the proposal is technically a breaking change in that dapps must request a fully-enabled provider before initiating account-requiring RPC requests. But this amounts to a single additional API call; and while I see the value in the long-term goal of separating network access from signing capability, the magnitude and intent of this particular breaking change doesn\u2019t seem to be a suitable platform for addressing this. In my mind, standardizing and restricting currently-unrestricted provider access doesn\u2019t seem to be a valid opportunity to rethink how transaction signing works in browsers altogether. I appreciate the feedback and hope to share ideas around the topic of network-signer separation in a new investigatory topic soon. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.828300865800866
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/JaceHensley",
                    "index": "51",
                    "likes": "1",
                    "time": "06/09/2018-23:06:05",
                    "content": "Hello again  I\u2019m really liking the new spec! Seems very smooth. Only point of feedback would be maybe adding a field to the provider. Something like provider#readonly, which is just a bool value. With that the dApp wouldn\u2019t need to ask for permission (I know the browser would cache it so you don\u2019t have to always ask permission) if the user had already granted permission and continue on with whatever flow the dapp has. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.113068181818182
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/benzap",
                    "index": "52",
                    "likes": "0",
                    "time": "12/09/2018-15:11:45",
                    "content": "I like the latest draft of the proposal, it simplifies the implementation considerably. I have a question about when to expect browser implementations. As a developer, I\u2019ve started a draft implementation of this proposal for our dApps that are in development. The cut-off date appears to be in November, but when can we expect to see the major browsers start incorporating this proposal for testing purposes? I was hoping to see an implementation of this in Mint Browser (ie. window.ethereum doesn\u2019t exist). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.104166666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/apanizo",
                    "index": "53",
                    "likes": "3",
                    "time": "14/09/2018-09:18:48",
                    "content": "Hi, congrats about this great EIP, really good job done here. So, I have read a couple of times, and correct me if I am wrong,  the main reason of this EIP is improving the user privacy and maintain user experience in a safer way. The approach followed basically allows the user to connect to \u201cethereum\u201d exposing some \u201cprivate\u201d information, having in the meantime a limited provider access (the reasoning for that has been well explained few comments above). In addition, interesting discussions on this thread (leaving aside the UX conversation) have been if this EIP should contain or not a mechanism for allowing the user to obtain this full access provider using a certain wallet, and also, a couple of indications about how to improve the protocol (relying on events). Following on the previous discussion, despite I really understand your point to keep it as simpler, effective, less intrusive, reducing at max the necessary changes to adapt dapps, I also think this EIP should provide a solution for handling multiple wallets, especially if the scope of this EIP is targeted to chrome-extensions. Or at least define how we should proceed and then stick to it. Some reasoning and spare ideas:  Right now having \u201crace\u201d conditions between providers is not just not cool, seems to be kind of weird. Modify the whole process of connecting to ethereum but leaving in a weak (in the sense of not knowing \u201cwho\u201d has provided you full access) mode the initial part does not look right Adding/defining a mechanism when having 1+ web3 providers is not a big deal right now, but defining a new EIP it is. Dapp browsers can easily ignore the listeners. One logic assumption would be if two extensions are loaded, let the user choose  Following the solutions proposed in this thread, the event-driven solution (having a way to identify the provider who fired the success event) seems to be one of the best solutions, we can create a pool (implement the event mechanism as a simple carrier state transfer) of providers easily on the frontend (we could decide if that pool should be done by wallet providers or by ourselves in the frontend) and then, apply some extensible architecture over them: like a chain of responsibility pattern or a simpler Mapper pattern. In that way:  We can create continue with the typical open to extension-close to modification way: responsibility is in one small class no big impact if changes are needed, events do not need a response and can work in a clean way. We can choose easily provider We know easily which available providers we have We have less cohesive architect solutions: not compromising implementation on providers\u2019 code, keeping them optimistic, we still code \u201cagainst\u201d more abstract solution: not specifying the id on the call when login, having third-party integrations less intrusive (events are more independent and simpler than postMessage-open-opener way)  What do you guys think? Is that something you are willing to reconsider? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.7372251931075455
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/andrey",
                    "index": "54",
                    "likes": "2",
                    "time": "14/09/2018-11:19:43",
                    "content": "    benzap:  when to expect browser implementations.   hey @benzap you can already try it in latest Status.im nightly build https://status-im.github.io/nightly/ Open Status, create account and login, go to profile tab, tap Advanced and enable Dev mode , then enable web3 opt-in option and open your Dapp, feel free to contact me if you have any questions. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.3
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "55",
                    "likes": "1",
                    "time": "14/09/2018-13:33:13",
                    "content": "Hi @benzap. In addition to the Status.im nightly build that @andrey mentioned, you can also test your dapp against MetaMask by using one of the latest builds from this pull request. We also added mock 1102 support that will be available in the next MetaMask release; this means dapps can begin to call provider.enable() to update their initialization flows prior to the MetaMask 1102 release date of November 2nd, 2018. ",
                    "links": [
                        "https://github.com/MetaMask/metamask-extension/pull/5256",
                        "https://ethereum-magicians.org/t/eip-1193-ethereum-provider-javascript-api/640/38"
                    ],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.8999999999999995
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "56",
                    "likes": "2",
                    "time": "14/09/2018-14:30:25",
                    "content": "Hi @apanizo. I agree that the issue of multiple extensions injecting (and thus overwriting) providers and Web3 instances is getting harder to ignore, especially with the growing number of extension-based wallets and signers. The issue is complex: who should decide which is the \u201ccorrect\u201d provider to use, the dapp or the user? For example, if a user has wallets A, B, and C installed as extensions and visits a dapp, should the dapp or the user choose which provider (and thus which wallet) to use for signing transactions? Since this EIP no longer changes provider injection (e.g. a provider is still injected at page load) and instead only restricts account access, I\u2019m not sure how we could easily solve the multiple-provider issue in this proposal. Still, the issue is a serious one. One possible solution would be a separate EIP that standardizes a <meta> tag that dapps should include. The presence of this meta tag would tell dapp browsers to inject a provider, and some attribute on the <meta> tag could indicate which provider should be injected. Something like: <meta name=\"ethereum\" providerID=\"metamask\">  I think this is a complex problem that\u2019s outside the scope of this proposal in its current form, but the <meta> tag pattern is one possible solution if dapps (and not users) should decide which provider and wallet to use. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.673076923076923
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/callmenick",
                    "index": "57",
                    "likes": "0",
                    "time": "17/01/2019-00:46:37",
                    "content": "@bitpshr @apanizo I think this is a pretty valid concern too! My opinion is that users should get to choose which provider they want. Maybe there can be some sort of mechanism where the EIP defines how providers inject themselves, but also how dapps consume them and display that info to users? I see it getting complex quickly, as maybe a user wants to change their provider for that dapp in the future\u2026 each dapp would need to implement that UI, or a fallback for just choosing one. Or maybe it can be twofold. If dapps want to control the provider, they use the meta tag. If dapps want to allow users to choose, they implement the UI. Thoughts? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.682291666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "58",
                    "likes": "2",
                    "time": "28/04/2019-10:28:24",
                    "content": "Hey, is there plan to finalize this EIP ? If so, it would be good to add a challenge payload option so the application can authenticate the address and be sure that the wallet really have the privateKey it claims to have. There is a proposal described here : Automatic Authentication Signature Basically the eth_requestAccount call would look like : {   \"id\": 1,   \"jsonrpc\": \"2.0\",   \"method\": \"eth_requestAccounts\",   \"params\": [\"0x55f55f5e5e6e7e867e\"] }  I would make the payload unrestricted so any data could be specified here. To prevent application from using it to sign arbitrary messages, the payload is prepended with Automatic Signature before being signed. Note that in the proposal mentioned above, I also propose to add a new json method eth_autoSign that would remove the need to add that facility in the eth_requestAccount method (since in that case authentication could be done any time afterward). Nevertheless I would still argue that having it in eth_requestAccount is a good idea since it remove the need to make another call. It will also increase the likelihood of having such authentication mechanism available for apps without having to wait for the auto_sign proposal to be accepted Note that we can make it backward compatible with existing app by making the challenge payload optional. ",
                    "links": [
                        "https://ethereum-magicians.org/t/automatic-authentication-signature/2429/17"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.471074380165289
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "59",
                    "likes": "1",
                    "time": "18/06/2019-23:58:39",
                    "content": "Hey, while dapps can requestAccounts  they currently cannot provide a UI for users to disable access (logout) without implementing it their own way (in an unreliable manner). This feature is useful for applications that want to provide access choice for different wallets, built-in vs web-based wallet like portis, bitski\u2026, as it would allow the application to disconnect from the built-in wallet, giving them back choice. You can imagine the flow this way if (isBuiltInWalletEnabled()) {   use builtin wallet } else if(iswebWalletLoggedIn()) {   use web wallet } else {   offerChoice() }  where the users could go back to the choice by closing access to the built-in accounts (if connected this way) or via the web wallet logout method (if connected this way). While this is currently achievable by storing a cookie or a value in localStorage to remember the last used wallet and let user forget it, it is unreliable as it relies on cookie/local storage. I propose thus {   \"id\": 1,   \"jsonrpc\": \"2.0\",   \"method\": \"eth_closeAccounts\" }  that would reset account access for that particular application ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.592592592592593
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "60",
                    "likes": "1",
                    "time": "04/07/2019-23:10:25",
                    "content": "I think this EIP as it stands is too restrictive for a standard.  A standard should standardize the set of things that benefit from being standard, and leave the remaining things up to individual applications.  This standard currently asserts the following:  Browsers MUST expose a provider at window.ethereum . Browsers MUST NOT populate the provider with user accounts by default. Browsers MUST define an eth_requestAccounts RPC method. Browsers MUST show an account access approval UI when eth_requestAccounts is called. Browsers MUST populate the provider with accounts if account access is approved. Browsers MUST resolve the Promise returned by eth_requestAccounts if account access is approved. Browsers MUST NOT populate the provider with accounts if account access is rejected. Browsers MUST reject the Promise returned by eth_requestAccounts with an Error if account access is rejected.  However, many of these are things that aren\u2019t necessary for as standard, and different tools may desire to make different decisions on them because they target a different demographic, or for UX reasons, or some other legitimate choice being made by a particular application. I propose change to the following:  Browsers MUST expose a provider at window.ethereum . Browsers MUST define an eth_requestAccounts RPC method. Browsers MAY wait for a user interaction before resolving/rejecting the eth_requestAccounts promise. Browsers MUST include at least one account if the eth_requestAccounts promise is resolved.  These changes make it so this EIP doesn\u2019t attempt to prescribe how signers should work/behave, but it does define how the interaction between the dapp and the signer needs to flow.  Dapps that build against this standard will be work with any signer that is privacy protecting, and they will also work with any signer that is not privacy protecting, or which chooses to protect privacy in a different way. Some examples of signers that would work with these changes but not the current draft specification:  A signer that doesn\u2019t protect user privacy.  For some users/use cases, this makes sense.  For example, I have an account I use as my \u201cglobal unique identifier\u201d and I give it out to anyone who asks for it.  I don\u2019t want to have to click a button to \u201clogin\u201d to every dapp I interface with, I never reject with this account. A signer that uses an attached hardware device. A signer that has a whitelist of approved sites, thus doesn\u2019t prompt the user for each interaction. A signer that provides every dapp a unique address (by domain) and manages assets in a permanently hidden/private account which then transfers assets (possibly through a mixer) to the individual dapp accounts as needed. A signer that presents dapps with a fake address on initial login, but then may change that address later if the user decides to reveal their true identity. A signer that spoofs being some other user when interacting with the dapp.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.123563218390804
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitpshr",
                    "index": "61",
                    "likes": "2",
                    "time": "05/07/2019-16:55:11",
                    "content": "Apologies for the delayed responses @wighawag and @MicahZoltu, I\u2019ve been heads-down on another project. I think both of your suggested proposal modifications make sense and would be happy to review PRs that modify the specification. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 9.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "62",
                    "likes": "0",
                    "time": "16/05/2020-06:07:47",
                    "content": "Are there any plans to move this to Last Call and eventually final?  I\u2019m writing a browser extension provider and would like to follow the latest standards, but I\u2019m pretty against coding against draft specifications. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.9375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "63",
                    "likes": "1",
                    "time": "16/05/2020-06:09:33",
                    "content": "If it is going to move to Last Call, it probably should be updated to match changes in stuff like EIP-1193 (no more .send, instead it is .request).  Was .enable ever part of a spec that made it to final?  If not, then consider removing the whole section on Provider#enable as it is just deprecating a thing that never technically existed (as far as specs are concerned). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.041666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "64",
                    "likes": "1",
                    "time": "24/05/2020-05:40:03",
                    "content": "In trying to implement this, I have realized that the lack of explicit error messaging makes it impossible to reliably implement a dapp that uses this while supporting older Ethereum browsers.  If you are working with a browser that does not implement this, then you will be unable to differentiate between \u201cthis method failed because it doesn\u2019t exist\u201d and \u201cthis method failed because the user denied access\u201d. I think without the ability to ask the provider for capabilities, we cannot have methods that act as gatekeepers unless we start prescribing error results (e.g., assert in the spec that an error for not approved is shaped exactly like X). Perhaps \u201cunapproved\u201d should return an empty array instead?  This way if the method doesn\u2019t exist it will hard fail and the dapp can fallback to eth_accounts or ethereum.enable and assume that the provider doesn\u2019t implement this specification, and if it does exist and returns an empty array then it will let the dapp know \u201cthe provider supports this method but has returned no accounts that the dapp has access to\u201d and the dapp can then behave appropriately in that situation.  (added below because Discorse won\u2019t let me reply 3 times in a row) I think this specification is overly prescriptive.  One can easily imagine a provider that does want to give access to the blockchain (e.g., eth_getBlockByNumber) but doesn\u2019t want to give access to the user\u2019s account.  Such a provider may even support eth_sendTransaction and eth_call by injecting the user\u2019s account into the requests before forwarding them on to the signer or backing Ethereum client so the user\u2019s address may never be exposed to the dapp (some dapps can work without ever knowing the user\u2019s account, and it will be up to the dapp to decide if it can function without that information). In general, I think that provider specifications should not specify provider behavior and instead should focus on specifying the interactions between dapp and provider.  In this case, the specification for eth_requestAccounts can describe the shape of the request and response but I don\u2019t think we should be specifying what the provider may be doing behind the scenes. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.403645833333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rekmarks",
                    "index": "65",
                    "likes": "0",
                    "time": "27/05/2020-06:39:45",
                    "content": "Thanks for the feedback on this Micah. I recently became co-author of this EIP since bitpshr is no longer actively working on it. Your points are well taken, and you can expect many of them to be incorporated in a forthcoming significant update of 1102. I can already note that:   eth_requestAccounts is staying; ethereum.enable will be removed from 1102 entirely, albeit perhaps mentioned in a comment for historical context. 1102 will require 1193 1102 will specify that the 4001 - User Rejected Request error should be returned if the user rejects the request. That error is defined in 1193.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.6726190476190474
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rekmarks",
                    "index": "66",
                    "likes": "0",
                    "time": "08/02/2021-16:43:44",
                    "content": "FYI: I\u2019m going to try to finalize 1102 sometime soon. It\u2019s unlikely to change in any material way except as noted in my previous comment. Since most EIP discussion now takes place in issues on the EIP repo, please pursue further discussion using this issue: https://github.com/ethereum/EIPs/issues/3257 ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.791666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rekmarks",
                    "index": "67",
                    "likes": "0",
                    "time": "04/03/2021-17:18:36",
                    "content": "I was wrong about where discussions are supposed to take place, so we\u2019re just going to keep it here  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 2.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "68",
                    "likes": "1",
                    "time": "12/11/2021-19:53:51",
                    "content": "HI all, there is currently some work being carried on establishing a much needed standard for \u201csign-in with ethereum\u201d : https://login.xyz/ It overlap with 1102 and the current spec add an extra layer of confirmation for the user degrading the experience. It would be great to make 1102 the main integration point so user can sign-in in one approval (See comment EIP-1102: Opt-in provider access - #58 by wighawag), instead  of having to \u201cconnect\u201d  with 1102 and then again \u201csign-ing\u201d For those interested in ensuring the best user experience, I invite you to participate in the discussion and the community: discord : Spruce current draft spec : EIPs/eip-4361.md at 9a9c5d0abdaf5ce5c5dd6dc88c6d8db1b130e95b \u00b7 ethereum/EIPs \u00b7 GitHub website : https://login.xyz/ ",
                    "links": [
                        "https://ethereum-magicians.org/t/eip-1102-opt-in-provider-access/414/58",
                        "https://discord.com/invite/Sf9tSFzrnt",
                        "https://github.com/ethereum/EIPs/blob/9a9c5d0abdaf5ce5c5dd6dc88c6d8db1b130e95b/EIPS/eip-4361.md",
                        "https://login.xyz/"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.208333333333334
                }
            ]
        }
    ],
    "group_index": "1029"
}