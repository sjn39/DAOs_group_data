{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-1985-sane-limits-for-certain-evm-parameters/3224",
            "title": "EIP-1985: Sane limits for certain EVM parameters ",
            "index": 3224,
            "category": [
                "EIPs"
            ],
            "tags": [
                "evm",
                "core-eips",
                "eip-1985"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "1",
                    "likes": "4",
                    "time": "30/04/2019-20:17:22",
                    "content": "Discussion topic for   Ethereum Improvement Proposals   EIP-1985: Sane limits for certain EVM parameters Details on Ethereum Improvement Proposal 1985 (EIP-1985): Sane limits for certain EVM parameters      ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-1985"
                    ],
                    "GPT-summary": "The post is a discussion topic for Ethereum Improvement Proposal EIP-1985, which proposes sane limits for certain EVM parameters. The author is explaining the proposal and asking for feedback, while third parties are giving constructive criticism, asking questions, and potentially auditing and reviewing the proposal.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Interoperability and Scalability",
                        "Token economics",
                        "Privacy, Security and risk management",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.071428571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "2",
                    "likes": "2",
                    "time": "07/05/2019-08:12:31",
                    "content": " Potentially however, certain contracts could fail at a different point after this change is introduced, and as a result would consume more or less gas than before while doing so.  Can you examplify? Because afaict, these changes (which I think I agree with) would have no practical consequence, so I\u2019m curious what I\u2019m missing. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 4.842261904761905
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "3",
                    "likes": "1",
                    "time": "09/05/2019-13:56:03",
                    "content": "I think that may be a remnant of an older version where more parameters were limited. Perhaps what we could do is place a calculation of how big of a gas limit could potentially allow larger CALLDATASIZE, CODESIZE, etc. for it make any difference. (4_294_967_295 + 1) * 4 = 17_179_869_184 gas could allow a larger than 32-bit calldata (32-bit + 1 to be exact) to be passed. Hence the limits introduced have no practical effect on contract developers. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.528273809523809
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "4",
                    "likes": "0",
                    "time": "20/05/2019-01:32:06",
                    "content": "Clarified the pull request. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "5",
                    "likes": "0",
                    "time": "20/05/2019-13:13:49",
                    "content": "In 2016, EIP-106 proposed a similar limits for gas. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "6",
                    "likes": "2",
                    "time": "23/05/2019-21:12:52",
                    "content": "A few thoughts:  The address limit should probably be expressed differently; eg - \u201cthe upper 96 bits shall always be unset\u201d, since addresses are not conventionally expressed as integers. Given these invariants have never been violated, why only activate them at a certain block? Without a fixed fork block, clients can simply agree to implement these changes, even retroactively, without causing a hard-fork. All of these constants would be clearer if expressed in hexadecimal.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.116071428571428
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "7",
                    "likes": "0",
                    "time": "26/06/2019-00:07:16",
                    "content": "    Arachnid:  Given these invariants have never been violated, why only activate them at a certain block? Without a fixed fork block, clients can simply agree to implement these changes, even retroactively, without causing a hard-fork.   I think that makes sense, but perhaps there are some subtleties regarding this in clients (@holiman and @karalabe probably has some opinions). For example private chains could in theory have gas limits which allow exceeding the proposed limits \u2013 arguable not very useful since the above quoted 17 billion gas limit likely would translate into a 1700 second (~30 mins) block time. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.11050061050061
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "8",
                    "likes": "0",
                    "time": "26/06/2019-11:51:46",
                    "content": "I agree about making it retroactive. I doubt there is any private network anwhere that has violated these, and if so, well, we can\u2019t support that ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "9",
                    "likes": "0",
                    "time": "26/06/2019-12:26:39",
                    "content": "If we enable this retroactively, what is the best process?  Enforce these rules in a client and sync mainnet Marking this EIP final Announcing it publicly ?  I also think we need to clearly specify which check happens first in the client, for example in the case of arguments to CALL with a really large input size, what would happen first:  gas calculation for memory expansion resulting in out of gas out of gas due to invalid parameter  Technically both have the same outcome, but tracing would differ. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.844642857142857
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "10",
                    "likes": "0",
                    "time": "26/06/2019-13:34:56",
                    "content": "Yes, those steps seem reasonable. As for CALL \u2013 my intuition says mem expansion happens in an earlier step, but I\u2019ll have too look it up. Anyway, I can PR this for geth and put on one of our benchmarking nodes. I expect most of these rules to already be in place, but perhaps only implicitly. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "11",
                    "likes": "0",
                    "time": "26/06/2019-22:45:50",
                    "content": "    holiman:  Anyway, I can PR this for geth and put on one of our benchmarking nodes.   That would be great, thanks!     holiman:  I expect most of these rules to already be in place, but perhaps only implicitly.   Yes, I think all of this enforced via gas limits already. Would be nice if we could enforce it prior to gas calculation. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 6.791666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "12",
                    "likes": "1",
                    "time": "28/06/2019-09:08:40",
                    "content": "There is really only one thing which may cause problems here, afaict (and this issue might need to be included in \u2018Security Considerations\u2019 for this EIP). Currently geth and parity allows a full uint64 as an uncle timestamp. This means that someone can intentionally mine an uncle U with timestamp 2^64-1 , and then mine a regular block within 7 blocks, and include U in the uncle set. If we redefine the allowed timestamp as max 2^ 63-1, then we\u2019re open for a consensus-attack between updated and non-updated clients. There are two ways out from this dilemma  Use 2^ 64-1 (uint64) as max timestamp, not 2^ 63-1 (int64) Ensure that we implement the change at a particular block B (hard fork). Later, if we see that nobody did ever execute this attack prior to B, we can \u201cundo\u201d the hardfork and retroactively apply the fork \u2013 basically pretending that the rule was always there.  I personally think option 1 is the best route, but I\u2019m not really up to speed with what kinds of problems that leads to on platforms without native support for uint64 ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.46875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "13",
                    "likes": "1",
                    "time": "28/06/2019-09:32:19",
                    "content": "Here\u2019s how it is in geth right now: Already enforced   block.gasLimit <= 2^63-1 enforced by https://github.com/ethereum/go-ethereum/blob/master/consensus/ethash/consensus.go#L262   block.gasUsed <= 2^63-1 implicitly enforced: https://github.com/ethereum/go-ethereum/blob/master/consensus/ethash/consensus.go#L267   address is internally represented by 20 bytes.  Not enforced   tx.gasLimit is defined as uint64 in geth. Can be safely capped as EIP suggests.  block.number is defined as a big.Int, but validation checks that it is only 1 away from the parent: here. Can be safely capped at like EIP suggests.  block.timestamp \u2013 see comment above, cannot be safely capped like EIP suggests.  Other   buffer size has no constraints, but practically I don\u2019t see any possible realistic impact of changing this to max at int32. Can be safely capped like EIP suggests.  ",
                    "links": [
                        "https://github.com/ethereum/go-ethereum/blob/master/consensus/ethash/consensus.go#L267",
                        "https://github.com/ethereum/go-ethereum/blob/master/consensus/ethash/consensus.go#L282"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.057900432900433
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "14",
                    "likes": "0",
                    "time": "28/06/2019-10:30:10",
                    "content": "    holiman:  Use 2^ 64-1 ( uint64 ) as max timestamp, not 2^ 63-1 ( int64 )   I think it would be acceptable given we do not need to represent timestamps prior to 1970 in the block headers. However, for best standards compatibility I\u2019d be in favor of striving for int64. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "15",
                    "likes": "0",
                    "time": "28/06/2019-10:32:58",
                    "content": "Isn\u2019t this an issue already if someone mines an uncle block with timestamp 2^64? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "16",
                    "likes": "0",
                    "time": "28/06/2019-11:04:23",
                    "content": "We are investigating possibility of applying this retroactively. The remaining 2 comments have been addressed in https://github.com/ethereum/EIPs/pull/2153. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "17",
                    "likes": "0",
                    "time": "28/06/2019-11:11:22",
                    "content": "As you can guess, I\u2019m very much in favor of int64 limit for timestamp. Third option to go here is to allow negative values for int64 timestamps in EVM execution. This will allow executing EVM code by mapping values above 2^63-1 to negative numbers (they are binary equivalent anyway). Can you create uncle blocks with negative timestamps in current implementations? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 4.542857142857143
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "18",
                    "likes": "0",
                    "time": "28/06/2019-11:17:23",
                    "content": "    holiman:  I agree about making it retroactive.   Thinking about this more, I really hope we can do it retroactively to reap the benefits for evm2wasm or in the proposed Eth1 EE on Eth2. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 6.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "19",
                    "likes": "0",
                    "time": "28/06/2019-11:55:30",
                    "content": "    chfast:  Isn\u2019t this an issue already if someone mines an uncle block with timestamp 2^64 ?   Well, if they do, it\u2019s not an \u2018issue\u2019 now. However, if some clients cap it lower, then we will have an issue. So there\u2019s no \u2018safe\u2019 rollout of that change, other than hardfork-then-retroactive, because going full retroactive means there a window where it can be used as an attack  Can you create uncle blocks with negative timestamps in current implementations?  RLP has no \u2018native\u2019 support for negative integers, and geth defines timestamps as unsigned. So basically there\u2019s no way geth (nor parity afaict) would interpret a timestamp as negative. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 4.4375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shemnon",
                    "index": "20",
                    "likes": "0",
                    "time": "28/06/2019-16:36:59",
                    "content": "    holiman:  I personally think option 1 is the best route, but I\u2019m not really up to speed with what kinds of problems that leads to on platforms without native support for uint64   I think the best way to ensure clients deal with it is to have some reference test cases where the relevant numbers are unit64 but not int64.   So some timestamp after 2038 should do that. To that end we should also see if test cases can be written where the first \u201cinsane\u201d value is tested.  This would only work if clients fail in a sensible fashion that the harness can detect. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.28125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "21",
                    "likes": "0",
                    "time": "03/07/2019-17:48:45",
                    "content": "    shemnon:  So some timestamp after 2038 should do that.   I think you meant the year 292277026596. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "22",
                    "likes": "1",
                    "time": "04/07/2019-08:30:38",
                    "content": "    holiman:  Well, if they do, it\u2019s not an \u2018issue\u2019 now. However, if some clients cap it lower, then we will have an issue. So there\u2019s no \u2018safe\u2019 rollout of that change, other than hardfork-then-retroactive, because going full retroactive means there a window where it can be used as an attack   I have changed my mind on this. Actually, what the EIP proposes is only from the viewpoint of the EVM. And from the perspective of the EVM, a timestamp will always safely fit within int64. Because the EVM knows nothing about uncles, and we never execute transactions within an uncle. So I think it would be fine to say that  The EVM can/should consider TIMESTAMP as fitting inside an int64.  The little devil in the details for node implementors to remember, however, is that the same rule cannot be applied to block header (uncle) validation, where timestamp can be uint64. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.752314814814815
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "23",
                    "likes": "0",
                    "time": "04/07/2019-11:51:49",
                    "content": "I actually thought uncles are also fully verified. Anyway, we intentionally assigned the limits to the EVM only, but consequences of these are also outside of EVM because a node will have to make sure the numbers being passed can fit. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.8999999999999995
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "24",
                    "likes": "1",
                    "time": "04/07/2019-14:24:59",
                    "content": "    chfast:  I actually thought uncles are also fully verified.   That\u2019s easy to think, and normally they would be, as an uncle generally exists as a head somewhere before it becomes uncled. However, on the blockchain, uncles are only headers without bodies, so it\u2019s impossible to actually execute transactions in an uncle given only the chain of canon blocks \u2013 the transactions are missing (hashes too, only the combined txhash remain). And it would be a problem of recursion. In order to validate a block, you\u2019d need to validate the uncles. In order to validate an uncle, you\u2019d neeed to validate it\u2019s uncles, and so on indefinitely.     chfast:  Anyway, we intentionally assigned the limits to the EVM only, but consequences of these are also outside of EVM because a node will have to make sure the numbers being passed can fit.   Right, but that\u2019s a simpler thing to fix within the node, just to make sure that whatever environment struct that\u2019s passed to the evm uses only 63 bits. Just as long as the node does not enforce that for uncle timestamps we\u2019re fine. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.478696741854636
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "25",
                    "likes": "0",
                    "time": "04/07/2019-14:52:44",
                    "content": "    holiman:  Ensure that we implement the change at a particular block B (hard fork). Later, if we see that nobody did ever execute this attack prior to B , we can \u201cundo\u201d the hardfork and retroactively apply the fork \u2013 basically pretending that the rule was always there.   Cannot we just go with this to simplify everyone\u2019s life in the long term (while making it worse in the short term)? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 4.589285714285714
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "26",
                    "likes": "0",
                    "time": "04/07/2019-22:54:00",
                    "content": "Side-note: @winsvega called for a similar clarification https://github.com/ethereum/EIPs/issues/604 ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "27",
                    "likes": "0",
                    "time": "06/07/2019-11:28:41",
                    "content": "In 2016, EIP-92 by @chfast proposed a similar limit. There is a long discussion there about other limits, all of which (with the exception of balance/values) are covered. I updated EIP-1985 with PC: https://github.com/ethereum/EIPs/pull/2179 ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/2179"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 4.708333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "28",
                    "likes": "0",
                    "time": "15/07/2019-13:47:40",
                    "content": "It has been also suggested that the buffer limit (2^32 - 1) should also cap the EVM memory. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MrChico",
                    "index": "29",
                    "likes": "0",
                    "time": "13/09/2019-18:04:32",
                    "content": "Although not strictly related to EVM semantics, it seems reasonable to include clarifying the range of other transaction related parameters in this EIP. There is currently a discrepancy in what geth does and what the TransactionTests enforce when it comes to nonce and gasPrice: geth uses uint64 for transaction nonces while the TransactionTests use uint256 geth uses uint256 for gas price while the TransactionTests use uint64. It seems reasonable to me to restrict both nonce and gasPrice to uint64 for transactions. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.229166666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "30",
                    "likes": "1",
                    "time": "15/09/2019-19:48:56",
                    "content": "This EIP originally aimed to describe these restrictions throughout the systems, but we\u2019ve decided to focus on the EVM only to make the EIP simpler to argue about (change was made here). I\u2019m open to making it more comprehensive as long as we can get it accepted and implemented by clients (hopefully without a \u201chard fork\u201d aka. enforcing it starting from genesis). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.6875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "31",
                    "likes": "0",
                    "time": "26/10/2019-05:04:51",
                    "content": "A 64-bit size for Chain ID was proposed during discussion of EIP-1344, but ultimately dropped for brevity of implementation during the upcoming fork. This EIP could make that limit explicit without any issues to existing choices of Chain ID of different networks. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MrChico",
                    "index": "32",
                    "likes": "0",
                    "time": "01/11/2019-15:17:47",
                    "content": "I believe my previous claim about gasPrice is incorrect. It seems both the transaction tests and geth uses uint256 for gasPrice so I guess it cannot be restricted here. For nonce the question remains though (in the transaction validation process) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 4.166666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "33",
                    "likes": "0",
                    "time": "19/11/2019-18:09:56",
                    "content": "Someone on the chat list on https://www.youtube.com/watch?v=aZ0S_oLSwhE suggested:  For 1985 I would like to have clarity on the GASPRICE opcode as well  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "34",
                    "likes": "0",
                    "time": "21/04/2020-18:45:58",
                    "content": "Recommend changing all of the 264-1 limits to 252.  I believe there would be no pragmatic difference, and by fitting in 52-bits it means you can store all possible values precisely in a double.  Since a lot of Ethereum dapp work (almost all of it) happens in JavaScript at the moment, and since JS only has double and bigint, it would be helpful to limit where we can to 2**52. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "35",
                    "likes": "0",
                    "time": "21/04/2020-19:49:56",
                    "content": "    MicahZoltu:  Recommend changing all of the 2^64-1 limits to 2^52. I believe there would be no pragmatic difference, and by fitting in 52-bits it means you can store all possible values precisely in a double. Since a lot of Ethereum dapp work (almost all of it) happens in JavaScript at the moment, and since JS only has double and bigint, it would be helpful to limit where we can to 2^52.   I think this is useful insight. I would have been in favour of this much more 1-2 years ago, but now with the advent of the native bigint API in browsers this seems to be a lesser problem. 2^52 seems like an awkward limit for any machine/language outside of JavaScript. @chfast what do you think? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.3500000000000005
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "36",
                    "likes": "0",
                    "time": "22/04/2020-02:43:36",
                    "content": "    axic:  2^52 seems like an awkward limit for any machine/language outside of JavaScript. @chfast what do you think?   What would code look like that checks to see if a number is less than 2^63-1 that would be \u201cawkward\u201d to check against 2^52 instead?  The obvious (to me) solution would be something simple like if (value > 2^63-1) throw new Error(), in which case `2^52 is actually 2 characters less typing!  Are you imagining some sort of signed-int overflow check that would be simpler or faster or something? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 4.4758522727272725
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "37",
                    "likes": "0",
                    "time": "22/04/2020-07:04:09",
                    "content": "Clarifications first.  The max integer you can store in double float type is 2^53-1. Not 2^52 nor 2^52-1. We definitely want to express this in number of bits required, so it must be in form of 2^N-1.  In general, I think we can lower the upper bound for gas. We were considering this previously in context of EIP-2045: Particle gas costs for EVM opcodes: the 2^53-1 would give as exactly space for 1000 particles per gas unit. However, I was thinking as low as 2^32-1 or even 2^31-1 \u2014 these seem to be enough for the current block gas limits. This is to be discussed. For quantities and indexes around memories / buffers we were also considering 32-bit range. For TIMESTAMP the 2^53-1 looks fine while 2^31-1 not so much. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.416666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "38",
                    "likes": "0",
                    "time": "22/04/2020-21:02:10",
                    "content": "    MicahZoltu:  Are you imagining some sort of signed-int overflow check that would be simpler or faster or something?   That was in my mind. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "39",
                    "likes": "0",
                    "time": "23/04/2020-06:24:58",
                    "content": "Can you describe how that would work in a modern language (Rust, Go, Katlin, C#, TypeScript, etc.)?  I didn\u2019t think that any of those languages exposed the CPU level overflow bit, and instead all of them would bubble an exception/error that is almost certainly more expensive than comparing two numbers. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "40",
                    "likes": "0",
                    "time": "07/09/2020-09:14:04",
                    "content": "    MrChico:  For nonce the question remains though (in the transaction validation process)   This is now handled by EIP-2681: Limit account nonce to 2^64-1 ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "41",
                    "likes": "0",
                    "time": "07/09/2020-09:16:28",
                    "content": "I wonder what is the best approach here:   Rewriting EIP-1985 in a way that it addresses all the discussed limits on the protocol/state level and clarifies the EVM opcodes.   Creating a handful of independent EIPs for the protocol clarification (could be merged where it makes sense) to get them discussed and accepted quicker. Then once those go through, apply EIP-1985 only dealing with EVM, but depending on those protocol clarifications. One example of this approach is EIP-2681 for nonces.   ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 6.666666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "42",
                    "likes": "0",
                    "time": "13/11/2020-17:29:27",
                    "content": "@MicahZoltu brought up under the EIP-2971 discussions that the number of logs in a transaction has no defined limit. It would be nice to have it explicitly limited to something like 2^32-1 or 2^64-1 logs. In practice of course it is highly unlikely to hit any of those limits. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.0476190476190474
                }
            ]
        }
    ],
    "group_index": "820"
}