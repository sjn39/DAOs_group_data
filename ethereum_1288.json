{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/erc-3450-standard-for-applying-shamirs-to-bip-39-mnemonics/5844",
            "title": "ERC-3450: Standard for Applying Shamir's to BIP-39 Mnemonics ",
            "index": 5844,
            "category": [
                "EIPs"
            ],
            "tags": [
                "cryptography"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "1",
                    "likes": "4",
                    "time": "29/03/2021-21:08:28",
                    "content": "A proposal for a standardized algorithm for applying Shamir\u2019s Secret Sharing Scheme to BIP-39 mnemonics, where the shares are also BIP-39 mnemonics. Pull request: Draft: Shamir + BIP-39 by danielstreit \u00b7 Pull Request #3450 \u00b7 ethereum/EIPs \u00b7 GitHub (Updated to apply feedback from below) Reference implementation: GitHub - danielstreit/shamir-bip39: Applies Shamir's Secret Sharing Scheme to BIP39 mnemonics Any and all feedback is appreciated! Thanks, Dan ",
                    "links": [
                        "https://github.com/danielstreit/shamir-bip39",
                        "https://ethereum-magicians.org/t/new-to-the-space-looking-to-pick-up-a-small-project/5858/2"
                    ],
                    "GPT-summary": "The post is a proposal for a standardized algorithm for applying Shamir's Secret Sharing Scheme to BIP-39 mnemonics. The author is requesting feedback on the proposal and has provided a reference implementation. A third party is welcome to provide constructive criticism or audit and review the proposal.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Interoperability and Scalability",
                        "Token economics",
                        "Privacy, Security and risk management",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None"
                    ],
                    "Sentiment": 4.6499999999999995
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/vbuterin",
                    "index": "2",
                    "likes": "0",
                    "time": "29/03/2021-21:17:20",
                    "content": "What\u2019s the polynomial modulus that you are using? Although the various 256-element fields are all isomorphic, I think you still need to pick one to get consistent answers. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "3",
                    "likes": "0",
                    "time": "29/03/2021-21:20:40",
                    "content": "   I was under the impression this was implied by the 256-element field, but I may be mistaken on that and can update the spec to clarify this. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/vbuterin",
                    "index": "4",
                    "likes": "0",
                    "time": "29/03/2021-21:59:40",
                    "content": "29, meaning $x^8 + x^4 + x^3 + x^2 + 1$? Yeah, it matters because multiplications that wrap around degree 8 will give different concrete answers. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "5",
                    "likes": "0",
                    "time": "29/03/2021-22:17:31",
                    "content": "    vbuterin:  What\u2019s the polynomial modulus that you are using? Although the various 256-element fields are all isomorphic, I think you still need to pick one to get consistent answers.   Yes, I believe that is correct. A little background: This started as a UI-focused project to make it easier to interact with existing implementations of Shamir\u2019s. I got two pieces of feedback on the initial prototype:  Ideally, the shares would be mnemonics (they were hex strings initially) Ideally, the algorithm would follow a known standard, to ensure recovery some point down the road  While I was able to find related standards (like SLIP-0039), I wasn\u2019t able to find something that would work for this case exactly (though I\u2019m open to suggestions and may have missed something obvious), so went about drafting a new standard. I\u2019ve been following several implementations closely in this, but am probably a bit over my head in math notation and finite field arithmetic, so any feedback on how to specify it more accurately is greatly appreciated . ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.94832702020202
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/vbuterin",
                    "index": "6",
                    "likes": "0",
                    "time": "29/03/2021-22:29:58",
                    "content": "One option might be to switch to GF(2048) as your field, so you can secret share over the mnemonics directly? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "7",
                    "likes": "0",
                    "time": "29/03/2021-23:04:02",
                    "content": "Yeah, that\u2019s an interesting point. I started with existing implementations of Shamir\u2019s operating on hex values and used the hex representation of the mnemonic for them. But, maybe that really isn\u2019t necessary anymore, now that I\u2019m not using an existing implementation. Could go from mnemonic to mnemonic with no hex in between  It does lean into the aspect of the project that I\u2019m lease experienced with tho. But, maybe I can find someone to work with me on it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "8",
                    "likes": "0",
                    "time": "30/03/2021-00:13:35",
                    "content": "Okay, I think I see how to do this better with GF(2048). I\u2019m going to give it a shot. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "9",
                    "likes": "0",
                    "time": "30/03/2021-05:33:55",
                    "content": "I\u2019ve updated the spec and implementation to use GF(2048) with primitive polynomial x^11 + x^2 + 1. See https://github.com/ethereum/EIPs/pull/3450 (new MR) And https://github.com/danielstreit/shamir-bip39 (same location as before) ",
                    "links": [
                        "https://github.com/danielstreit/shamir-bip39"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.340909090909091
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "10",
                    "likes": "0",
                    "time": "01/04/2021-20:43:13",
                    "content": "In my haste, I neglected that, originally, the shares were also valid BIP-39 mnemonics. By naively converting the mnemonic to shares, word for word, the shares would no longer be valid BIP-39\u2019s . They wouldn\u2019t have valid checksums. We could instead convert the entropy portion of the mnemonic to shares and calculate the checksum from for each share to recreate a valid BIP-39. But, at that point, we\u2019d need to convert the share mnemonic to hex to calculate the SHA256 to get the checksum. So, did we gain anything by using GF(2048)? We\u2019d still need to convert to hex at some point to create a valid BIP-39. Maybe then, the original solution where the initial BIP-39 is first converted to entropy is better? I might be missing something here, please correct me if I\u2019m wrong. Alternatively, if we decided that we didn\u2019t really care that the shares were valid BIP-39 mnemonics, we could use the space where the checksum is to store the share id, avoiding the need to store any data outside the mnemonic. I don\u2019t really like this later idea. I think it is important that the shares are valid BIP-39 mnemonics, indistinguishable from any others, to hide the fact that there may be something greater behind it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.466666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "11",
                    "likes": "0",
                    "time": "02/04/2021-17:08:50",
                    "content": "Summarizing current state and open questions: Thanks for looking! Any and all feedback is greatly appreciated :). Background: As an Ethereum user, I\u2019m concerned that the BIP-39 mnemonic backup of my wallet is a single point of failure. I\u2019d like to use Shamir\u2019s Secret Sharing Scheme to split it into shares that I can distribute for storage and later use to recover my original mnemonic. I\u2019d like each of the shares to also be a standard, BIP-39 mnemonic, so that if one is found/lost, the finder would not necessarily know that it was only one of a larger scheme. So far, I\u2019ve been primarily focused on building the UI for this using an existing implementation of Shamir\u2019s scheme. But, I\u2019ve gotten some feedback that in order to make this tool more broadly useful, and ensure recovery at some arbitrary point in the future when tooling may have changed, that I should use a standardized implementation of Shamir\u2019s. Or, since that doesn\u2019t exist as far as I\u2019m aware, create one. So, I\u2019ve gone down the route of creating an EIP to specify a standardized approach for splitting a BIP-39 mnemonic into shares that are also BIP-39 mnemonics. Although this isn\u2019t my core domain, I think I\u2019ve gotten a good start and am hoping to get some feedback here :). Questions:  What\u2019s a good choice for a Galois Field for this?  My spec originally converted the mnemonic to hex entropy and applied Shamir\u2019s to the hex values using GF(256). The resulting hex shares were then converted to valid BIP-39 mnemonics. Earlier in this thread, it was suggested that I could use GF(2048) instead so we could apply Shamir\u2019s directly to the mnemonic. The problem I see with this is that the resulting shares would not be valid BIP-39 mnemonics. (Unless we jumped through some hoops, only converting the entropy section of the mnemonic and calculating the checksum from there for each share. Doable, but then, what\u2019s the advantage of using GF(2048) here?) Would there be any advantage to using GF(16)? Or any other field? GF(256) seems like the most common in the wild, but not sure there are other considerations I should be thinking about in choosing the field.  Does the choice of a primitive polynomial matter?  Other than being included in the specification and consistent across implementations, does the actual choice matter? I\u2019ve been following various reference implementations and using the lowest primitive polynomial. For GF(256), I used 29 ($x^8 + x^4 + x^3 + x^2 + 1$). For GF(2048), I used 5 ($x^11 + x^2 + 1$). Are there any arguments for using a different primitive polynomial here? Thanks for reading! Links:   Draft: Shamir + BIP-39 by danielstreit \u00b7 Pull Request #3450 \u00b7 ethereum/EIPs \u00b7 GitHub (Note that the current state uses GF(2048), but does NOT output valid BIP-39s for shares. I\u2019m planning on updating this based on feedback here.)  ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/3450"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.509244227994228
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nicolas",
                    "index": "12",
                    "likes": "0",
                    "time": "03/04/2021-18:47:52",
                    "content": "The advantage of using GF(2048) is that you can map every shamir share to a valid mnemonic word. Since you are using BIP-39 you have 2048 words. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "13",
                    "likes": "0",
                    "time": "04/04/2021-23:35:42",
                    "content": "Thanks for taking a look Nicolas! Although this approach would result in shares with \u201cvalid mnemonic words\u201d, the shares would not be valid BIP-39 mnemonics. BIP-39 mnemonics have two components: entropy and a checksum (which is the first few bits of the SHA256 of the entropy). And, to make it more complicated, the divide between the two components is not between words. For example, a 12 word mnemonic has 132 bits total (11 x 12), including 128 bits of entropy and 4 bits of checksum. So, this feels like it gets pretty dirty. We\u2019d need to extract out the entropy bits from the generated shares, calculate the checksum and then create a different mnemonic, with the valid checksum. And then, we\u2019d repeat this dance going the other direction. Instead, if we convert the mnemonic to bytes of entropy before sharing, apply Shamir\u2019s to those bytes, and then convert the resulting shares to BIP-39 mnemonics (ie using the shares as the entropy bytes, calculating the checksum, and converting to words), I believe we get a valid BIP-39 with less hassle than applying Shamir\u2019s to the words directly. And, that would imply using GF(256) instead of GF(2048). There is still a bit of a dance, from mnemonic to bytes, but it seems more straight forward to me. What do you think? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.163690476190476
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nicolas",
                    "index": "14",
                    "likes": "0",
                    "time": "06/04/2021-14:25:50",
                    "content": "I agree with you about the niceness of having shares be valid BIP-39s. Therefore, I agree that you need to secret share the first 128 bit and not the full 132 bits. However, I would go for GF(2^128) instead of GF(256). There is a chance where some people would want verifiable secret sharing (computational hardness). In that scenario, you won\u2019t be able to use GF(256) the Field is small and discrete log is not hard. However, Discrete log is hard in GF(2^128) and GF(2^256). Verifiable secret sharing is needed where share holders want to verify that they got good consistent shares. A private key holder can distribute shares to individuals and each individual can check that his share is correct against a commitment to the polynomial holding the initial secret. Another place where having valid secret shares (GF(2^128) and GF(2^256)) is nice is with threshold signatures. Share holders can sign together a transaction. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.070601851851851
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "15",
                    "likes": "1",
                    "time": "07/04/2021-03:14:48",
                    "content": "One of the primary goals of this project is to make it easy for non-technical users to store their keys safely. That means a user interface is mandatory. A CLI is not sufficient. To me, that means we need an implementation in JavaScript. See, for example AirGap Vault. Its social recovery feature creates mnemonic shares using Shamir\u2019s scheme, but it doesn\u2019t follow a standard. Their code is currently written in TypeScript. It would be great if they adopt a standard like the one proposed here. Similarly, I\u2019m working on a UI that will make it easy for non-technical users to split their mnemonics in order to keep them safer. My project is also written in TypeScript. And, if it becomes a standard, maybe others will adopt it for similar workflows in their own apps as well. The point here is that it needs to be easy to implement correctly, even in a language like JavaScript. The max number in JavaScript is 2^53 - 1. So, to use a field larger than the max number would really complicate the implementation. GF(256) on the other hand is very easy to implement in JavaScript. One additional complication of a field like GF(2^128) is that we\u2019d need a different field for each supported strength of mnemonic. BIP-39 supports 128, 160, 192, 224, and 256. While not a big deal, supporting five different fields does add complexity to the implementation. For a more articulate rationale for GF(256), written by folks with a lot more experience than me, see slips/slip-0039.md at master \u00b7 satoshilabs/slips \u00b7 GitHub. The use case is very similar to this one. Key differences are: this one focuses on interoperability with BIP-39. SLIP-39 adds a variety of additional features to facilitate sharing. Regarding:  Verifiable secret sharing is needed where share holders want to verify that they got good consistent shares.   Another place where having valid secret shares (GF(2^128) and GF(2^256)) is nice is with threshold signatures. Share holders can sign together a transaction.  Both of these features sound very interesting. I had not considered them in the initial feature set for this, but am interested in learning more. Can you point me to any resources on this? What would it take to support these features in this spec? I feel like additional implementation complexity could be justified if it supports additional, useful features. Thanks again for digging into this spec with me! I really appreciate the feedback you\u2019ve given and have learned a lot from it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.152708333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "16",
                    "likes": "0",
                    "time": "07/04/2021-05:50:47",
                    "content": "Curious if you\u2019d considered Ian Coleman\u2019s approach? His also results in mnemonics. https://iancoleman.io/shamir39/ ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nicolas",
                    "index": "17",
                    "likes": "0",
                    "time": "07/04/2021-14:13:33",
                    "content": "Working in GF(2^256) can be done in Javascript. You just have to use a library to store the big (128-256 bits) numbers (and do arithmetic operations on those numbers). Metamask (written in javascript) signs your transactions on the browser (this is done in a field size of approx 2^256). When working in applied cryptography, working in \u201cbig fields\u201d is the norm (digital signatures, public key encryption, commitments\u2026 all require attackers no to be able to go through all the field in polynomial time (they would break discrete log, prime factorization \u2026)). For debugging purposes, you would start in a small field and then make it bigger. Supporting 5 different fields shouldn\u2019t be hard, the same functions would work in all 5 (Lagrange interpolation, computing inverses\u2026). I can even write the library in JavaScript and share it with you (if you want). I am convinced that working in GF(256) is easier than the bigger fields. Easier: in the sense that you will be able to fit all the numbers you have in the regular variable of JavaScript. However, you will be doing multiple parallel secret sharings. You are effectively secret sharing smaller pieces of the secret and not the secret itself. In general, by doing that you loose two things: the ability to compute multi party computation on the secret shares directly, and any computational hardness that you can leverage in the big field (commitments). Now whether someone can leverage those to build something useful, I don\u2019t know(we have shares of a seed that generates sk/pk pairs, it would have been definitely useful if we have shares of sk direclty). But we are removing the ability for someone in the future to use them. Look at how polynomial commitments work (you commit to the polynomial that you use to generate the shares). Maybe start with Feldman\u2019s scheme. For threshold signatures maybe start with the basics threshold signatures and then look at why threshold signatures is easy with https~removeMe~://medium.com/bitbees/what-the-heck-is-schnorr-52ef5dba289f. Also feel free to reach out on discord I will be happy to help. ",
                    "links": [
                        "https://www.unboundsecurity.com/blog/threshold-signatures/"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.21435508935509
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "18",
                    "likes": "1",
                    "time": "07/04/2021-15:39:37",
                    "content": "    danfinlay:  Curious if you\u2019d considered Ian Coleman\u2019s approach? His also results in mnemonics. https://iancoleman.io/shamir39/    Yeah! This was actually the project that inspired me to work on this. It has a couple of deficiencies that I\u2019m hoping to address. The resulting share mnemonics aren\u2019t valid BIP-39 shares. See open issue here: Consider making shamir mnemonics BIP39 compatible on their own \u00b7 Issue #1 \u00b7 iancoleman/shamir39 \u00b7 GitHub. The shares generated by this EIP are. There is a cost to making the shares valid BIP-39s - the share id is not encoded in the mnemonic, so the user needs to store an additional piece of data. I discuss some alternatives and justification for this in the EIP. Would definitely be interested in other\u2019s thoughts on this. Ian Coleman\u2019s approach lacks standardization. He is very clear about this. In the UI in large red font he writes, \" There are no alternative implementations, meaning you are totally dependent on this tool if you use it. That is a dangerous situation to be in.\" I don\u2019t want to be in this situation. And, this is why I\u2019ve gone down the route of trying to get an EIP and (hopefully) multiple implementations in different languages. He also hasn\u2019t fully spec\u2019d out the application of Shamir\u2019s. He\u2019s spec\u2019d out what the share format looks like, but not the field used for calculations. Looking at the code, he appears to be using GF(256) with irreducible polynomial $x^8 + x^4 + x^3 + x^2 + 1$, but that isn\u2019t defined in the spec. So, I kinda see myself taking what he started and trying to harden it into a more concrete standard (the EIP, proposed here). I\u2019m also working on a UI that I hope will have various UX benefits from Ian Coleman\u2019s prototype, including better autocomplete for entering mnemonics and a confirmation stage to ensure that users copied the mnemonics correctly. ",
                    "links": [
                        "https://github.com/iancoleman/shamir39/issues/1",
                        "https://github.com/iancoleman/shamir39/blob/master/specification.md"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.406591710758377
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "19",
                    "likes": "1",
                    "time": "07/04/2021-16:14:17",
                    "content": "    nicolas:  we have shares of a seed that generates sk/pk pairs, it would have been definitely useful if we have shares of sk direclty   It\u2019s worth noting that we never handle seeds in this EIP. Only entropy. We convert the initial mnemonic to entropy, generate shares of the entropy, then convert each share \u201centropy\u201d to a mnemonic. We never convert the initial mnemonic nor the shares to actual seeds. Not sure that actually changes anything that you\u2019ve said, but seems like an important clarification. I\u2019ll do some more research, thanks for the links! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.681818181818182
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nicolas",
                    "index": "20",
                    "likes": "0",
                    "time": "07/04/2021-18:30:02",
                    "content": "One way to think about how these wallets work: is a pseudo random generator that takes a random number s (call it a seed) extract infinite random numbers s1,s2, s_infinity. Each number is then fed into a genkey function  that take s_i and produce a public private key pair pk_i, sk_i. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 3.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "21",
                    "likes": "0",
                    "time": "07/04/2021-19:54:21",
                    "content": "I think we may be missing one another on terminology and that may be leading us to miss on the scope of this as well. I\u2019m using my terms directly from BIP-39, as interoperability with BIP-39 is the primary goal here.  Entropy - A set of psuedorandom bits Mnemonic - An encoding of the entropy into words (bips/bip-0039.mediawiki at master \u00b7 bitcoin/bips \u00b7 GitHub) Seed - Derived from the mnemonic (bips/bip-0039.mediawiki at master \u00b7 bitcoin/bips \u00b7 GitHub) Wallets or Keys - Derived from the seed, following any of a variety of specifications (not covered by BIP-39).  The current EIP, 3450, is only concerned with 1 and 2. Although BIP-39 has an opinion on 3, this EIP does not. The goal is to store the entropy more securely by creating shares of it. We use mnemonics on top of the entropy to make it more user friendly. This EIP has no opinions on how the seed is generated from the mnemonic or how wallets are derived from the seed. This is intentional. It allows us to support different wallet derivations algorithms. I\u2019m pretty intent on keeping the scope here to storing shares of the entropy as mnemonics. Anything around deriving wallets or signing is out of scope, in my opinion.  it would have been definitely useful if we have shares of sk direclty  If we shared the sk directly, we would need to have an opinion on how the keys are derived and we would only support a single wallet. Instead, we share the entropy and we can derive however many sks we want by any algorithm we want.  threshold signatures  This is very interesting, but, in my opinion, out of scope here. Once again, it would require the EIP to have opinions on how keys are derived.  verifiable shares  This is also very interesting, and while it doesn\u2019t imply any opinions on how keys are derived, it does increase the scope here. Both for this EIP and for associated UIs. I think I\u2019m fine with assuming a trusted distributor here. ",
                    "links": [
                        "https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#From_mnemonic_to_seed"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.278628117913833
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/worldlyjohn",
                    "index": "22",
                    "likes": "0",
                    "time": "22/06/2021-21:09:50",
                    "content": "Hope I\u2019m not coming out of left field here, but have you considered the downsides of key splitting? Specifically:  single point of failure. single device combining keys may be exposed to malware or malicious user of device poor auditability.  cannot tell which shares were used to recreate the key  Thoughtfully explained by jameson lopp here Shamir's Secret Sharing Shortcomings It seems some (Fireblocks, Zengo) are moving in the direction of Secure Multiparty Computation with threshold signatures. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.770238095238096
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "23",
                    "likes": "0",
                    "time": "22/06/2021-22:49:54",
                    "content": "Great article, thanks for the link! I agree with pretty much everything the article raises.  I think Shamir\u2019s Secret Sharing (and a number of other things, RNGs for example), suffer from a property where they are just complex enough that people are excited to implement them often for little good reason, and then they are complex enough (or have few enough reasons to invest significant time) they implement them poorly  Gregory Maxwell   I feel seen  The initial motivation for this ERC was a more secure way to store validator keys. Initially, the options seemed quite limited, with the eth2-cli tool only providing a mnemonic. But, I feel like things are evolving, the options for storing validator keys are improving, and this proposal may become obsolete. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.405667701863353
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/worldlyjohn",
                    "index": "24",
                    "likes": "0",
                    "time": "29/06/2021-03:27:04",
                    "content": "    dstreit:  I feel seen  The initial motivation for this ERC was a more secure way to store validator keys. Initially, the options seemed quite limited, with the eth2-cli tool only providing a mnemonic.   We\u2019re all learning out in the open!  And please don\u2019t let my comment alone dissuade you.  Hopefully we can hear from others \u2013 esp security researchers. Also stumbled on this (didnt realize Trezor has supported Shamir since 2019)   Medium \u2013 27 Aug 20    Shamir Backup\u200a\u2014\u200aA Better Way to Secure Your Keys Bitcoin is a self-custody asset\u200a\u2014\u200aYou own your private keys, you own your coins. But what if you lose your private keys backed up on a\u2026  Reading time: 3 min read       ",
                    "links": [
                        "https://blog.trezor.io/shamir-backup-the-revolution-of-private-keys-backup-is-here-858687ed7fe7"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.224489795918368
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Lixin",
                    "index": "25",
                    "likes": "0",
                    "time": "29/06/2021-06:03:09",
                    "content": "I am a big lover for Shamir Secret Sharing! I can clearly see the downside of Ian Coleman\u2019s tool as you have mentioned above. Just curious - what\u2019s the disadvantages of Trezor\u2019s implementation in your opinion?  github.com   satoshilabs/slips/blob/master/slip-0039.md # SLIP-0039 : Shamir's Secret-Sharing for Mnemonic Codes  ``` Number:  SLIP-0039 Title:   Shamir's Secret-Sharing for Mnemonic Codes Type:    Standard Status:  Final Authors: Pavol Rusnak <stick@satoshilabs.com>          Andrew Kozlik <andrew.kozlik@satoshilabs.com>          Ondrej Vejpustek <ondrej.vejpustek@satoshilabs.com>          Tomas Susanka <tomas.susanka@satoshilabs.com>          Marek Palatinus <slush@satoshilabs.com>          Jochen Hoenicke <hoenicke@gmail.com> Created: 2017-12-18 ```  ## Table of contents  * [Abstract](#abstract) * [Notation](#notation)      This file has been truncated. show original      Personally I think it\u2019s essential for different wallets adopting the same standard (just like BIP39). Then the seed(both Shamir or non-Shamir) can be compatible. ",
                    "links": [
                        "https://github.com/satoshilabs/slips/blob/master/slip-0039.md",
                        "https://github.com/satoshilabs/slips/blob/master/slip-0039.md"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 4.951923076923077
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/worldlyjohn",
                    "index": "26",
                    "likes": "0",
                    "time": "29/06/2021-18:19:28",
                    "content": "Shamir\u2019s on it\u2019s own isn\u2019t an issue (as a non-security researcher).  However, lets say you are creating a 3 of 4.  Initially all 4 shards are on a single device.  Is this device connected to the internet?  Can you be sure isn\u2019t free of malware?  Then you are sending 3 of the shards to \u201cdifferent locations.\u201d  Are you recording this on paper and physically transferring it?  Or are you sending these shards over HTTP(S)?  All this creates additional attack vectors on your key. So not bad in theory, but a poor implementation can get you in trouble. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.589285714285714
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "27",
                    "likes": "0",
                    "time": "29/06/2021-18:19:47",
                    "content": "    Lixin:  Just curious - what\u2019s the disadvantages of Trezor\u2019s implementation in your opinion?   Primarily that it isn\u2019t compatible with BIP-39: slips/slip-0039.md at master \u00b7 satoshilabs/slips \u00b7 GitHub. I do like a lot about what SLIP-39 does. But for the use case here, where I already have a BIP-39 mnemonic and no simple way of migrating to another system (like SLIP-39), I\u2019d like a standard focused specifically on BIP-39 mnemonics. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dstreit",
                    "index": "28",
                    "likes": "0",
                    "time": "29/06/2021-18:36:18",
                    "content": "Great questions! And, I\u2019ve been working on a UI in conjunction with this that I hope would make some of these interactions easier (though, I\u2019ve been swamped with work and unable to give it as much time as I\u2019d like). The UI is intended to be used on an air-gapped computer and it would provide a prompt asking for confirmation of this. I think running Ubuntu \u201clive\u201d may be a good option for this as well. I am not a security research either, and am hoping for more feedback on this before calling it \u201csecure\u201d. Then, after the initial mnemonic is recovered, I\u2019d expect the user to use it on the air-gapped machine. For example, if they wanted to add another validator, they could generate the keys and save the deposit credentials to thumb drive and then upload them from a different, connected computer. This is far from perfect though. There is still the single point of failure: the mnemonics are combined on a single computer. As well as many of the other issues raised in the link you posted. But, it may be better than having a single mnemonic. After splitting, the shares can be located in different locations and, if one is lost, not all is lost. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.983543417366946
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Lixin",
                    "index": "29",
                    "likes": "0",
                    "time": "30/06/2021-00:36:27",
                    "content": "Hm I see your point. But I am convinced by SatoshiLab\u2019s reasoning for \u201cnot compatible\u201d with BIP-39  github.com   satoshilabs/slips/blob/master/slip-0039.md#design-rationale # SLIP-0039 : Shamir's Secret-Sharing for Mnemonic Codes  ``` Number:  SLIP-0039 Title:   Shamir's Secret-Sharing for Mnemonic Codes Type:    Standard Status:  Final Authors: Pavol Rusnak <stick@satoshilabs.com>          Andrew Kozlik <andrew.kozlik@satoshilabs.com>          Ondrej Vejpustek <ondrej.vejpustek@satoshilabs.com>          Tomas Susanka <tomas.susanka@satoshilabs.com>          Marek Palatinus <slush@satoshilabs.com>          Jochen Hoenicke <hoenicke@gmail.com> Created: 2017-12-18 ```  ## Table of contents  * [Abstract](#abstract) * [Notation](#notation)      This file has been truncated. show original      ",
                    "links": [
                        "https://github.com/satoshilabs/slips/blob/master/slip-0039.md#design-rationale",
                        "https://github.com/satoshilabs/slips/blob/master/slip-0039.md#design-rationale"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/duncancmt",
                    "index": "30",
                    "likes": "0",
                    "time": "25/09/2021-23:29:35",
                    "content": " In that scenario, you won\u2019t be able to use GF(256) the Field is small and discrete log is not hard. However, Discrete log is hard in GF(2^128) and GF(2^256).  Word of warning: discrete log is not-so-hard in composite fields (like GF(2^128) and GF(2^256)). If you intend to rely on a verifiable secret sharing scheme that requires that discrete log be hard (e.g. Feldman\u2019s scheme), please choose a prime-order field.  One thing that\u2019s nice about using a large field is that you can derive the coefficients from a hash of the secret and use this fact to verify that the secret were recovered correctly. Of course, this destroys the information theoretic security of the scheme, reducing it to the security of the hash algorithm, but you were probably relying on that anyways. I\u2019ve produced a research-quality implementation of the above concept in Python: https://github.com/duncancmt/shamir . Particularly note this check here. No attempt was made to optimize for side-channel resistance or for speed. Under the (reasonable) assumption that the device on which the secret is reconstituted is fully trusted, it\u2019s probably airgapped and therefore neither performance (beyond a few seconds) nor side-channel resistance is a priority. The implementation was intended to be as simple as possible to make examination and re-implementation easy. Of course, Python\u2019s built-in bignum support and extensive standard library made this implementation much more concise than it might have been in other languages.  I chose x^256 + x^10 + x^5 + x^2 + 1 x^224 + x^12 + x^7 + x^2 + 1 x^192 + x^15 + x^11 + x^5 + 1 x^160 + x^5 + x^3 + x^2 + 1 x^128 + x^7 + x^2 + x + 1  as the primitive polynomials for this implementation. Each of those polynomials is the one with the lowest coefficients chosen from those with the lowest Hamming weight (incidentally 5 in each case) for each order. ",
                    "links": [
                        "https://github.com/duncancmt/shamir/blob/d496cab0de4881b700ef707d6752e672da3edd53/shamir.py#L85",
                        "https://github.com/duncancmt/shamir/blob/d496cab0de4881b700ef707d6752e672da3edd53/gf.py#L19"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.022127329192546
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/duncancmt",
                    "index": "31",
                    "likes": "1",
                    "time": "19/01/2022-16:31:20",
                    "content": "For anyone still monitoring this thread, I updated my research-quality implementation to implement Shao\u2019s hash-based VMSS scheme. So now the recovery process can identify which shares given are invalid. Of course, now it depends on some metadata about the shares in order to perform the recovery, but under the assumption of a computationally-bounded adversary (and that SHAKE-256 isn\u2019t broken), making this metadata public is fine. ",
                    "links": [
                        "https://doi.org/10.1016/j.ins.2014.03.025"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.027777777777778
                }
            ]
        }
    ],
    "group_index": "1288"
}