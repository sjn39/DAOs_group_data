{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-615-subroutines-and-static-jumps-for-the-evm/2728",
            "title": "EIP-615: Subroutines and Static Jumps for the EVM ",
            "index": 2728,
            "category": [
                "EIPs"
            ],
            "tags": [
                "evm",
                "eip-615"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "1",
                    "likes": "8",
                    "time": "23/02/2019-06:42:43",
                    "content": "This proposal is first of all about deprecating dynamic jumps, which play hell with formal specs,  proofs of correctness, static analysis, optimizing compilation, and a lot more.  And being rid of them, introducing subroutines and a few other operations to replace them.  This gives an immediate benefit in formal tractability, and opportunities for increased performance. EIP-615: Subroutines and Static Jumps for the EVM I\u2019m incorporating changes for later PRs into the original proposal. ",
                    "links": [
                        "https://github.com/ethereum/EIPs/issues/615#issue-224850482",
                        "https://ethereum-magicians.org/t/eip-615-subroutines-and-static-jumps-for-the-evm-last-call/3472/2",
                        "https://ethereum-magicians.org/t/eip-615-subroutines-and-static-jumps-for-the-evm-last-call/3472",
                        "https://ethereum-magicians.org/t/evm-evolution-working-group-formation/3218"
                    ],
                    "GPT-summary": "The author of the proposal is explaining the benefits of deprecating dynamic jumps and introducing subroutines and other operations to replace them. The author is also incorporating changes for later PRs into the original proposal. A 3rd party could give constructive criticism or audit and review the proposal.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Interoperability and Scalability",
                        "Change to proposal pipeline",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.15
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "2",
                    "likes": "0",
                    "time": "23/02/2019-07:14:57",
                    "content": "@AlexeyAkhunov @androlo @Arachnid @axic @boris @cdetrio @chfast @chriseth @Ethernian ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "3",
                    "likes": "0",
                    "time": "23/02/2019-07:15:32",
                    "content": "@expede @fubuloubu @fulldecent @grosu @gumb0 @holiman @karalabe @lrettig @mattlock @tjayrush ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "4",
                    "likes": "0",
                    "time": "23/02/2019-07:16:16",
                    "content": "@vbuterin @<others I\u2019m forgetting whose judgment I value, or should> (you can only mention 10 people in a post) ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "5",
                    "likes": "4",
                    "time": "23/02/2019-08:43:32",
                    "content": "(Typing from a phone\u2026 sorry for short post. Infer detail as needed ) I would maybe put a bit more nuance on it: this proposal introduces structured control flow, which makes it MUCH easier to analyze smart contracts for correctness, security considerations, and for the EVM to performance optimize (doesn\u2019t matter JIT or AOT), and do gas meter aggregation. Deprecating dynamic jumps is an excellent step in driving users to more structured flow by default. There are legitimate uses of dynamic jumps, but they\u2019re FAR into the realm of edge cases. As part of a broader strategy (what @boris and I have been calling \u201cEVM Evolution\u201d), this is the first step towards a much safer & faster EVM. Ewasm is still coming, but we should improve the EVM that we have today. This change also makes it easier to port code to wasm when the day comes. I\u2019ve spoken with a number of mainstream client implementers at Devcon IV and Standford, and these changes sound fairly uncontroversial so far. We would love as much feedback on this proposal as possible ahead of moving this proposal to Last Call! Thanks everyone  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None"
                    ],
                    "Sentiment": 6.041071428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "6",
                    "likes": "3",
                    "time": "23/02/2019-12:18:22",
                    "content": "Thank you! The reason I am interested in this is potential for more efficient concurrent execution of transaction. Provided that if the Ethereum state keeps growing at least for next couple of years, we have started exploring the ideas of storing parts of the state remotely and fetching them in batches during the execution. I have done some crude modelling here, but realised very quickly that static analysis might be used together with symbolic execution to elide locks during such executions. Any concrete hints in that direction? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "7",
                    "likes": "1",
                    "time": "23/02/2019-14:38:02",
                    "content": "Thanks @AlexeyAkhunov.  That\u2019s a difficult read that will take me a cup of coffee here as the sun rises.  Could say more about how symbolic execution would help this scheme?  I suspect @expede might even understand you! ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.541666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "8",
                    "likes": "1",
                    "time": "23/02/2019-15:35:42",
                    "content": "So yes, while it really isn\u2019t possible to get rid of dynamic jumps since they are used so heavily in current EVM programs, I would say most languages could move users over to that if a static jump option were available that was sufficiently cheap (and it should be cheaper than a dynamic jump because of how much more optimizable it would be for program flow, data loading, etc) Vyper has spoken very positively about this proposal, and as a smaller, security-focused language we would have no problems deprecating the use of dynamic jumps entirely. However, I don\u2019t think that would be possible for a larger, more powerful language that opens up to assembly instructions like Solidity, but it would be good enough if the higher level language were able to make the switch for all internal calls, which certainly seems plausible. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.151948051948052
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "9",
                    "likes": "1",
                    "time": "23/02/2019-15:53:56",
                    "content": "P.S. is there any chance that subroutines can be considered separately? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "10",
                    "likes": "0",
                    "time": "23/02/2019-15:54:43",
                    "content": "A static jump is O(1).  A dynamic jump takes a binary search of a table of every JUMPDEST in the program.  So O(1) vs O(log n) to start with, even before low-level optimizations. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "11",
                    "likes": "0",
                    "time": "23/02/2019-15:55:40",
                    "content": "Get rid of dynamic jumps and how to construct subroutines? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "12",
                    "likes": "1",
                    "time": "23/02/2019-15:57:11",
                    "content": "No I mean to put this proposal into stages and reduce implementation risk.  Add subroutines Add static jump opcodes Work on community education and reducing the prevalence of dynamic jump usage  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.09375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "13",
                    "likes": "1",
                    "time": "23/02/2019-15:59:23",
                    "content": "Would also be good to get a survey of dynamic jump usage, I\u2019m not exactly sure how prevalent it is or how many different ways it is used ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.949999999999999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "14",
                    "likes": "1",
                    "time": "23/02/2019-16:01:07",
                    "content": "    fubuloubu:  However, I don\u2019t think that [deprecating dynamic jumps\u2019 would be possible for a larger, more powerful language that opens up to assembly instructions like Solidity.   Deprecating just means that validation will reject Solidity programs that attempt to meet the new standard.  Whether a means for new code to bypass validation is maintained indefinitely will get determined after the 1st phase of optional validation. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.670454545454545
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "15",
                    "likes": "1",
                    "time": "23/02/2019-16:02:18",
                    "content": "    fubuloubu:  Would also be good to get a survey of dynamic jump usage, I\u2019m not exactly sure how prevalent it is or how many different ways it is used   Every return from a subroutine in Solidity requires a dynamic jump. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.791666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "16",
                    "likes": "0",
                    "time": "23/02/2019-16:03:02",
                    "content": "Is that the only use? Do people develop in assembly alternative uses? Where\u2019s the usage data? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "17",
                    "likes": "2",
                    "time": "23/02/2019-16:06:19",
                    "content": "Dynamic jumps also used for switch statements and virtual functions, and could be used in lots of creative ways in assembly code, I suppose.  I\u2019m not too concerned about placing a bit of a burden on creative assembly coders in return for better high-level code generation. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "18",
                    "likes": "0",
                    "time": "23/02/2019-16:07:20",
                    "content": "I just want to make sure we don\u2019t miss a geniune use case in our mission to salt the earth of dynamic jumps (sarcasm mine) ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "19",
                    "likes": "0",
                    "time": "23/02/2019-16:11:25",
                    "content": "Thus the call for introduction in two phases.  We can make validation optional if need be, but I\u2019m not sure I\u2019ve ever seen the use of unconstrained dynamic jumps in programs for other CPUs.  Or even an unconstrained dynamic jump instruction (and please someone correct me.) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.53125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "20",
                    "likes": "3",
                    "time": "23/02/2019-16:13:36",
                    "content": "Yes, they could be split into 2 (or 3) EIPs. I feel that this would be cleaner as well. I brought this up a while back, and the prevailing feeling was that since this EIP already has momentum, just let it be. TL;DR yes, but no for political reasons. Also, I don\u2019t think that any of these features are controversial. Let\u2019s just get them into the spec. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.916666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "21",
                    "likes": "1",
                    "time": "23/02/2019-16:19:18",
                    "content": "Yes, absolutely we could do that. In fact, there\u2019s nothing stopping a client from doing actor-style parallel execution for performance reasons today, without these changes, for large use cases. Invoking the same contract concurrently gets much more tricky, but yes that analysis is both possible and easier if these changes go in. As an aside, there\u2019s a lot of optimization that mainstream clients could be doing that they\u2019re not currently. From my cursory reads through several of them, they\u2019re pretty much straight out of the Yellow Paper verbatim, run interpreted, don\u2019t attempt to use natively-sized words, process sequentially, and do gas bookkeeping with at runtime on each opcode call. There\u2019s a lot of room to speed up the existing clients, without needing to wait for eWASM. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.62012987012987
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "22",
                    "likes": "0",
                    "time": "23/02/2019-16:22:07",
                    "content": "    expede:  Yes, they could be split into 2 (or 3) EIPs. I feel that this would be cleaner as well.   As mentioned above, if you remove dynamic jumps you have to at least add subroutines.  Beyond that, switch statements and virtual functions would then have to emulated slowly with a chain of comparisons, which is why real chips support jump tables.  Any other uses of dynamic jumps are too obscure for me to know about, but could probably be accomplished with jump tables. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.796875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "23",
                    "likes": "1",
                    "time": "23/02/2019-16:24:52",
                    "content": "Removing dynamic jumps is a terrible step 1. I would suggest we add features first, than propose removal in a later EIP ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.0625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "24",
                    "likes": "1",
                    "time": "23/02/2019-16:24:56",
                    "content": "Sure, but in theory it would also be done in the following sequence of separate EIPs (in this order):  Introduce static jumps [leave dynamic jumps in] Introduce subroutines [still have dynamic jumps] Deprecate dynamic jumps  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.833333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "25",
                    "likes": "3",
                    "time": "23/02/2019-16:29:11",
                    "content": "    fubuloubu:  Removing dynamic jumps is a terrible step 1. I would suggest we add features first, than propose removal in a later EIP   It\u2019s dynamic jumps that make static analyses useless-to-impossible.  They must die.  The rest of the features are the made necessary in their absence.  That is the logic of the paper. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.8359375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "26",
                    "likes": "3",
                    "time": "23/02/2019-16:32:00",
                    "content": "Also, we are trying to schedule hard forks on a 9-month schedule, and they have been taking up to 16.  Too many small EIPs and it will take years to get this work rolled out.  Seems silly when it took me 2 months to implement. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.322916666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "27",
                    "likes": "1",
                    "time": "23/02/2019-16:32:38",
                    "content": "Sure, but they don\u2019t need to be step 1. It could be a longer strategy done in a forwards-compatible way until step 3. Really it\u2019s more a question of default language-level support, so that when analyzable control flow is the default we gain the benefits. It doesn\u2019t have to be done in one shot. But again, you [Greg] made arguments the other day about political expediency. The argument about multiple EIPs is correct in theory, but not necessarily required or practical. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.767857142857142
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "28",
                    "likes": "2",
                    "time": "23/02/2019-16:41:06",
                    "content": "I definitely appreciate this as a political argument! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "29",
                    "likes": "1",
                    "time": "23/02/2019-16:44:42",
                    "content": "I do see this proposal as a logical whole, better as one proposal than three.  None of the features are visible to a high-level programmer, and the analytic and performance gains are there only for programs that do not use dynamic jumps.  But high-level compilers and assembly coders can use these features in concert to produce much better code. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.208333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "30",
                    "likes": "2",
                    "time": "23/02/2019-18:11:30",
                    "content": "    gcolvin:  Could say more about how symbolic execution would help this scheme?   The idea is to execute transactions of 1 block concurrently, stopping at a barrier whenever there is a read from the state or a write to the state. Both read and write result in one of the transactions to successfully acquire an exclusive lock on the item being read or written, whereas other transaction wanting to access the same item, would need to wait. That exclusive lock would be held until the transaction completes the execution. Deadlocks need to be detected and need to result in one of the deadlocked transactions being aborted and restarted. This model would lead to what they call \u201cSerialisable\u201d transactional isolation. I thought that symbolic execution coupled with control flow analysis can help to elide some of the locking, but I have not spent enough time thinking about it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.979166666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "31",
                    "likes": "1",
                    "time": "23/02/2019-18:22:00",
                    "content": "I\u2019m really not a fan of the new complexity that this introduces to the instruction set representation. Currently, every instruction takes one byte, with the exception of PUSHn, which depends on the value of n. This EIP introduces 10(!) new instructions, all but two of which have multibyte encodings. As an alternative suggestion, why not instead take these arguments from the stack, but require that they were PUSHed immediately before? In that event, BEGINSUB n_args, n_results would be encoded as PUSHn n_args PUSHn n_results BEGINSUB, and removes the need for everyone to adopt new instruction decoding code. It would also remove the need for two of the new instructions - JUMPTO and JUMPIF can be represented using the existing JUMP and JUMPI instructions, but with the new restrictions. PUTLOCAL and GETLOCAL introduce an entirely new type of memory and don\u2019t seem to have any direct connection to the rest of this EIP. I think they should be in a separate EIP. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.409090909090909
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "32",
                    "likes": "0",
                    "time": "23/02/2019-20:04:57",
                    "content": "@Arachnid .  So sort of a reverse polish notation with extra PUSHes.  A tiny  bit verbose, and an unusual constraint on an instruction set. It might also complicate validation a little, as it would have to look backwards from these instructions to be sure the previous pushes were valid.  Still, I\u2019m open to the change, if we thought the complication would help enough users. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.216145833333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "33",
                    "likes": "0",
                    "time": "23/02/2019-20:07:19",
                    "content": "@Arachnid  I don\u2019t see how PUTLOCAL and GETLOCAL introduce new kinds of memory, they just provide an alternative to multiple DUPs and SWAPs for getting values where you want them on the stack.  So not necessary, but useful and efficient.  But as with JUMPV and JUMPSUBV they can be emulated with slower sequences of other instructions, despite being directly supported by Wasm and most all CPUs.  If reducing the size of the proposal would make the difference to its acceptance then these would be the instructions to postpone. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.650974025974026
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "34",
                    "likes": "0",
                    "time": "23/02/2019-20:40:56",
                    "content": "    gcolvin:  So sort of a reverse polish notation with extra PUSHes. A tiny bit verbose, and an unusual constraint on an instruction set. It might also complicate validation a little, as it would have to look backwards from these instructions to be sure the previous pushes were valid.   Validators can do this fairly easily by calculating provenance on stack elements. Executors don\u2019t need to care, and can just treat them as stack arguments.     gcolvin:  I don\u2019t see how PUTLOCAL and GETLOCAL introduce new kinds of memory, they just provide an alternative to multiple DUPs and SWAPs for getting values where you want them on the stack.   I misunderstood how they work, sorry. I thought they accessed a \u2018local variable storage\u2019, but they access elements further down the stack at a location specified by a frame pointer. I do still think that this EIP specifies several different modifications, and should be split into smaller, more concise EIPs. It  would make it easier to review and approve them independently. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.238881874298541
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "35",
                    "likes": "1",
                    "time": "23/02/2019-22:44:24",
                    "content": "Fair enough.  I\u2019m still not sure I can write a regular grammar to express your idea, or how to put it in the Yellow Paper.  I guess a back reference from the appendix where BEGINSUB is described to an extra exceptional halting state in the case that BEGINSUB would be executed with arguments on that the stack that were not the results of one of the PUSHn operations. And yes, these could be three EIPs, with the condition that the second two depend on the first.  I don\u2019t know if that makes it easier or harder to evaluate the facility as a whole.  Which is to say:  This  EIP offers the control-flow primitives provided by Wasm and by most every CPU ever.  Shall we just put them all in now, or spend the next two years at it? I should maybe add a table of corresponding EVM+615/Wasm/8086/ARM operations to clarify. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.688888888888889
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "36",
                    "likes": "0",
                    "time": "23/02/2019-22:48:20",
                    "content": "I think one interesting way to think about it as 3 EIPs that exist atomically. For example, if we get the first one done for Istanbul, but not the others, that\u2019s good. If we get both the dependant ones in there for Istanbul, that\u2019s great. If we get all 3 in time\u2026 That\u2019s fantastic! It\u2019ll be good to have break points to de-risk the implementation steps and engineering (and social coordination of a fork) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 7.488095238095238
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "37",
                    "likes": "0",
                    "time": "23/02/2019-23:03:38",
                    "content": "Technical arguments aside, this has been EIP issue 615 since December of 2016, and EIP-615 Draft since April of 2017.  I designed it as a whole and implemented it as whole. I\u2019d rather move it as whole and decide what to do if fails, depending on why it fails. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.666666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "38",
                    "likes": "1",
                    "time": "23/02/2019-23:07:48",
                    "content": "One of the reasons it might fail is because it\u2019s a large, monolithic change. I think I like the political calculation of rolling out all of it at the same time and attempting to get community buy in to make the change because it reduces the amount of coordination effort long term. As a backup plan though, I am liking the 3 step approach for those of a more moderate risk appetite. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.11734693877551
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "39",
                    "likes": "1",
                    "time": "23/02/2019-23:09:02",
                    "content": "I want to see this proposal succeed, because I\u2019ve heard a lot of great feedback, but 10 opcodes definitely gives one pause, especially when we\u2019ve had months of trouble getting half that many to work lol ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.238095238095238
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "40",
                    "likes": "1",
                    "time": "24/02/2019-00:02:18",
                    "content": "    fubuloubu:  One of the reasons it might fail is because it\u2019s a large, monolithic change   True, though compared to eWasm it\u2019s tiny  I know the core devs have taken to arguing at length over individual opcodes, most of them variants on CALL with subtle security implications.  They are not accustomed to discussing a computational facility with several opcodes and no security implications except gas costs.  And even less accustomed to bringing a deficient VM up to the minimal state of the art. I would like to here from language implementers how they would implement virtual functions without JUMPSUBV or similar. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.818452380952381
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "41",
                    "likes": "0",
                    "time": "24/02/2019-00:18:19",
                    "content": "    gcolvin:  True, though compared to eWasm it\u2019s tiny    Lol, no comment\u2122      gcolvin:  I would like to here from language implementers how they would implement virtual functions without JUMPSUBV or similar.   I wouldn\u2019t? With the gas model, there\u2019s diminishing returns to more complex functionality since the expense of execution only makes certain coordination functions practical. Let\u2019s not get too far down the rabbit hole of what\u2019s possible and take the win here if we can get this implemented.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.9619708994708995
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "42",
                    "likes": "0",
                    "time": "24/02/2019-00:19:20",
                    "content": "Solidity has virtual functions. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "43",
                    "likes": "3",
                    "time": "24/02/2019-00:24:27",
                    "content": "    fubuloubu:  With the gas model, there\u2019s diminishing returns to more complex functionality   It\u2019s the gas model that makes the four \u201cextra\u201d opcodes so valuable.  They can be implemented with one cheap interpreter instruction, or compiled to one wasm or machine instruction, but require expensive sequences of primitives otherwise.  Long chains of comparisons and jumps.  Long chains of dups and swaps.  Lots of gas. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "44",
                    "likes": "2",
                    "time": "24/02/2019-01:18:13",
                    "content": "I\u2019m incorporating changes for a later PR into the original proposal.  Including this motivation: Especially important is efficient translation to eWasm. To that end we maintain a close correspondence between the operations proposed here and Wasm.     Wasm EIP-615     br JUMPTO   br_if JUMPIF   br_table JUMPV   call JUMPSUB   call_indirect JUMPSUBV   return RETURN   get_local GETLOCAL   put_local PUTLOCAL   unreachable DATA     ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.958333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "45",
                    "likes": "1",
                    "time": "24/02/2019-01:38:28",
                    "content": "@Arachnid I think the biggest problems for your disassembler are JUMPV and JUMPSUBV, which have not just multiple arguments\u2013like PUSHn\u2013but a variable number of arguments.  Wasm\u2019s corresponding  br_table and call_indirect avoid that problem by maintaining the tables of indirections separately from the instructions\u2013not inline.  I kept them inline for fear that one could write an exploit that used one table and lots of indirect jumps.  If I\u2019m being overly cautious we can copy Wasm and solve that problem. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "46",
                    "likes": "0",
                    "time": "24/02/2019-03:43:13",
                    "content": "    gcolvin:  They are not accustomed to discussing a computational facility with several opcodes and no security implications except gas costs.   Be careful; that assumption is what bought us the issues with net gas metering.     gcolvin:  I think the biggest problems for your disassembler are JUMPV and JUMPSUBV, which have not just multiple arguments\u2013like PUSHn\u2013but a variable number of arguments.   I hadn\u2019t noticed that. It seems to me that this proposal complicates the EVM a lot compared to its existing status. I agree with the goals, but I also wonder if the complexity is worthwhile, especially with plans to migrate to new VMs in the future. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.335227272727273
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "47",
                    "likes": "0",
                    "time": "24/02/2019-06:16:04",
                    "content": "@Arachnid  I\u2019m specifically wondering if (and why) BEGINSUB 1 2 would be harder to disassemble than, say, PUSH1 3?  You recognize the opcode, you skip the requisite number of bytes. I can for sure see that JUMPV n 1 2 3 ... N is harder, and suggest it\u2019s easy to fix unless that opens a security hole. ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.916666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "48",
                    "likes": "0",
                    "time": "24/02/2019-06:22:55",
                    "content": "    gcolvin:  @Arachnid I\u2019m specifically wondering if (and why) BEGINSUB 1 2 would be harder to disassemble than, say, PUSH1 3 ? You recognize the opcode, you skip the requisite number of bytes.   Because presently all opcodes except pushn are one byte long, and all the push opcodes can be handled with one special case clause. Surely you must see that this complicates the EVM ISA substantially. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.707142857142857
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "49",
                    "likes": "2",
                    "time": "24/02/2019-08:14:10",
                    "content": "    Arachnid:  It seems to me that this proposal complicates the EVM a lot compared to its existing status. I agree with the goals, but I also wonder if the complexity is worthwhile, especially with plans to migrate to new VMs in the future.   Yes, the power and simplicity of JUMP and JUMPI are such that they can be used in complex ways to emulate 7 of these 10 opcodes.  Solidity does so use them.  The price of this power is that many kinds of useful analyses become difficult or impossible.  Better, I keep arguing, to just provide the same opcodes Wasm does. As for plans to move the mainchain to other VMs.  The only eWasm EIP is a three year old issue, was never implemented, was never submitted to the EIP editors, was never publicly submitted to the core devs, and is now closed.  This simpler, much less disruptive EIP draft and its implementation have been sidelined for over two years now by eWasm plans.  Last I talked to the eWasm team they thought it was time to get it moving again. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.046850079744817
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "50",
                    "likes": "1",
                    "time": "24/02/2019-08:35:25",
                    "content": "Can I suggest putting this as an agenda item on a future All Core Devs for discussion before Last Call / Final status? I think it\u2019d be good to get input from implementers, and I don\u2019t think it will get enough attention as a discussion thread here. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.699999999999999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "51",
                    "likes": "0",
                    "time": "24/02/2019-08:47:45",
                    "content": "    Arachnid:  \u2026 alll opcodes except pushn are one byte long, and all the push opcodes can be handled with one special case clause. Surely you must see that this complicates the EVM ISA substantially.   BEGINSUB, like the PUSHns, is a one-byte opcode with fixed-length immediate data.  Seems no big deal.  Variable-length immediate data is a big deal that I want to be rid of if it\u2019s safe. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.089285714285715
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "52",
                    "likes": "3",
                    "time": "24/02/2019-09:16:49",
                    "content": "Probably a good idea, which is why I\u2019m discussing it here before going to Last Call, and why Boris and Brooke have been meeting with implementers and auditors for feedback.  And at this point Brooke has volunteered to do the Parity implementation and maybe someone (does @boris know?) has volunteered for geth. My main fear of going to the core devs with less than a rock-solid proposal is getting sent away with instructions to perform unwanted surgery.  The last time I did that C++ got auto_ptr, which then took 5 years to be deprecated and replaced by the original classes that the committee thought were too complex. (Those classes and their associated philosophy are now the bedrock of Rust\u2019s memory management too.  Much less complex than garbage collection.  And consolation for years of rejection  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.171296296296296
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "53",
                    "likes": "0",
                    "time": "24/02/2019-23:18:29",
                    "content": "DISCLAIMER: I just got off a 14-hour flight, about to step onto the next plane in a few minutes, and an jet lagged AF (ie: I\u2019m not at my sharpest at the moment). Quick thoughts that will possibly get expended later:  One of the reasons it might fail is because it\u2019s a large, monolithic change  I\u2019m inclined to agree. A few times I\u2019ve started breaking this proposal up into several sub proposals linked by the requires metadata field. As @gcolvin mentioned, EIP-615 has been in process since 2016(!), is referenced in Gavin Wood\u2019s book, people know the number, it\u2019s been discussed with lots of people that like it, &c &c &c. I do agree that some parts may be more controversial (the push/pop optimizations), and more granularity makes it easier to show progress on the portions that are absolute no-brainers. Yes, they\u2019re all part of a single strategy, but I\u2019d call adding any number of them a win.  True, though compared to eWasm it\u2019s tiny   Oh yeah: like a completely different scale of change! I think that the difference is that there is already political will to advance eWasm. Obviously I believe that there should be effort into improving the EVM, and the base changes (literally just subroutines and static jumps) are essentially uncontroversial.  Be careful; that assumption is what bought us the issues with net gas metering.  Yes, everything that goes into the spec should be solid. My views on having a formally-verified canonical spec are well known at this point  Now if there was funding for these initiatives, that would be amazing! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.558248299319728
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "54",
                    "likes": "1",
                    "time": "24/02/2019-23:28:07",
                    "content": " It seems to me that this proposal complicates the EVM a lot compared to its existing status  I agree that the number of changes per proposal (\u201c10 cpp\u201d ) is high. Would it be more palatable spread over multiple EIPs? (honest question!) My two cents worth: the current spec is deeeeeeeeeeeeep in the Turing Tarpit. The existing spec is possibly so simple that it\u2019s causing issues. Most(?) existing clients are so simple that they\u2019re not doing even the most straightforward performance optimizations. This is part of a strategy to improve that. Simple doesn\u2019t always mean small; in VM and PLT good design is generally accepted as following principles like orthogonality and extensibility. As much as I agree that less code is easier to maintain, there\u2019s a balance to be struck between few moving parts, and a machine that\u2019s easy to mechanistically optimize and verify. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.84265873015873
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "55",
                    "likes": "1",
                    "time": "24/02/2019-23:33:05",
                    "content": "    gcolvin:  And at this point Brooke has volunteered to do the Parity implementation and maybe someone   I mean,  ideally we get funding to do this  There\u2019s only so many unpaid projects that SPADE Co can take on. This one is near and dear to my heart, yes, but surely this type of core infrastructure is fundable! Let\u2019s not fall into the tragedy of the commons! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.549107142857142
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "56",
                    "likes": "0",
                    "time": "25/02/2019-01:10:37",
                    "content": "    expede:  Yes, they\u2019re all part of a single strategy, but I\u2019d call adding any number of them a win.   Actually, no.  If you remove dynamic jumps but don\u2019t add indirect jumps you make switch statements and virtual functions slower, larger, and cost more gas than they do now.  And providing stack frames for arguments and local variables but no instructions for directly accessing them is just silly.  There really is a reason that most every CPU with a stack has all of these instructions. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.694805194805195
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "57",
                    "likes": "0",
                    "time": "25/02/2019-01:12:00",
                    "content": "Of course.  I think testing the existing aleth implementation is sufficient, but the more merrier. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nevillegrech",
                    "index": "58",
                    "likes": "3",
                    "time": "25/02/2019-11:52:10",
                    "content": "Hi, Neville from contract-library.com. I support your proposal! We routinely perform static analysis of all programs deployed on the mainnet. It is very hard for a scalable analysis to precisely figure out the jump targets of some of the dynamic jumps introduced by the Solidity compiler (particularly for implementing nested returns or call-with-continuation) especially after optimizations. A good static analysis tool needs to figure out the most complete, yet also the most precise subset of jump targets. The latter reduces false positives when running security analyses. Introducing more structured jumps (private call and return) to the EVM bytecode language will facilitate the development of static analysis tools for EVM programs and will enable these tools to figure out a precise subset of jump targets. When dynamic jumps are eliminated, the bar for implementing static analysis tools for the EVM will be significantly lower. I guess most bytecode analysis tools today probably use symbolic execution techniques rather than static analysis (meaning abstract-interpretation and similar techniques) because of dynamic jumps. Another change that would facilitate the development of static analysis tools for EVM bytecode is the balancing of stack depths at control-flow joins. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.30048076923077
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "59",
                    "likes": "0",
                    "time": "25/02/2019-15:02:51",
                    "content": "Thanks, Neville.  Could you clarify what you mean by static analysis versus symbolic execution?     nevillegrech:  Another change that would facilitate the development of static analysis tools for EVM bytecode is the balancing of stack depths at control-flow joins.   I believe this is already a validity condition.  8  For every instruction in the code the frame size is constant.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.8875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nevillegrech",
                    "index": "60",
                    "likes": "0",
                    "time": "25/02/2019-16:16:51",
                    "content": "Sorry, I missed condition 8. I\u2019ve looked at validate_subroutine and indeed that condition should hold  In symbolic execution, each path is independently executed which allows targets of dynamic jumps in the case of function returns to be identified precisely in every path. Symbolic execution however misses many program behaviors (e.g. due to the problem of path explosion) and so it is limited in its applications. In other static analysis approaches, the state (e.g. values present in each stack position) is combined at control-flow joins. (Approaches exist to mitigate the loss in precision in this case, primarily context sensitivity). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None"
                    ],
                    "Sentiment": 5.444805194805195
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "61",
                    "likes": "0",
                    "time": "25/02/2019-17:32:36",
                    "content": "I don\u2019t think you get path explosion with this proposal,  (or with Wasm) @nevillegrech.  The stack must be the same at control-flow joins, so you can just mark a path as taken.  But I\u2019ll leave it to @expede to better understand. The Abstract and perhaps a bit more might need to be more clear on this distinction. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.6000000000000005
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nevillegrech",
                    "index": "62",
                    "likes": "0",
                    "time": "25/02/2019-17:52:10",
                    "content": "No problem. To be clear, I didn\u2019t suggest that path explosion had any thing to do with the proposal (or lack of it). It is just a characteristic of symbolic execution, as a technique. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.083333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "63",
                    "likes": "0",
                    "time": "25/02/2019-18:11:42",
                    "content": "Got it.  For this proposal symbolic execution is guaranteed to take linear time.  I\u2019m not sure about other static analysis approaches. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.208333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "64",
                    "likes": "1",
                    "time": "25/02/2019-23:12:04",
                    "content": "I saw Brooklyn\u2019s call for comments, so I\u2019ll send a few. But posting into https://github.com/ethereum/EIPs/issues/615 because that is the official Discussion-To location. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 4.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "65",
                    "likes": "1",
                    "time": "26/02/2019-01:08:30",
                    "content": "Thanks!  Comments are welcome in either place.  The issue thread is older, and mostly a detailed review of the semantics by Sydney, who has since published work with Yoichi\u2019s Lem formalization of the EVM, and also did a Lem formalization of this proposal.  I should probably change the draft to point here. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 7.020833333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "66",
                    "likes": "2",
                    "time": "26/02/2019-02:12:35",
                    "content": "Why we want static analysis: \"I want you to write a program that has to run in a concurrent environment under Byzantine circumstances where any adversary can invoke your program with any arguments of their choosing. The environment in which your program executes (and hence any direct or indirect environmental dependencies) is also under adversary control. If you make a single exploitable mistake or oversight in the implementation, or even in the logical design of the program, then either you personally or perhaps the users of your program could lose a substantial amount of money. Where your program will run, there is no legal recourse if things go wrong. Oh, and once you release the first version of your program, you can never change it. It has be right first time. \u201cI don\u2019t think there are many experienced programmers that would fancy taking on this challenge. But call it \u2018writing a smart contract\u2019 and programmers are lining up around the block to have a go! Most of them it seems, get it wrong\u2026\u201d    the morning paper \u2013 8 Mar 18    Zeus: Analyzing safety of smart contracts Zeus: Analyzing safety of smart contracts Kalra et al., NDSS\u201918 I\u2019m sure many readers of The Morning Paper are also relatively experienced programmers. So how does this challenge sound? I want you \u2026      ",
                    "links": [
                        "https://blog.acolyer.org/2018/03/08/zeus-analyzing-safety-of-smart-contracts/"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.415178571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "67",
                    "likes": "1",
                    "time": "26/02/2019-02:18:04",
                    "content": "@fulldecent and others have complained about the size of this proposal.  I\u2019m pulling this response from the EIP issue.  A fair comparison might be to eWasm, which provides essentially the same functionality. This spec is about 15 pages, and it took about 300 lines of C++ to add it to the aleth interpreter. It is backwards-compatible by default. There is no current eWasm EIP and implementation for direct comparison, but the Wasm spec itself is 150 pages, and only floating point and a few other non-deterministic operations aren\u2019t relevant. eWasm also requires an Environment Interface between the VM and the client, and a Transcompiler of EVM to eWasm bytecode for backwards compatibility. The ewasm/design repo, which is currently mostly empty, gives a feel for the scope of the effort remaining. ",
                    "links": [
                        "https://github.com/ewasm/design"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.215909090909091
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "68",
                    "likes": "0",
                    "time": "26/02/2019-02:30:36",
                    "content": "Thank you! Yes, good to keep the deeper discussion together in one thread  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 8.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/latrasis",
                    "index": "69",
                    "likes": "0",
                    "time": "26/02/2019-21:04:52",
                    "content": "I would second @arachnid\u2019s request to keep instruction set representation constant. Unless I misunderstand the proposal, as a user, having multibyte encodings would make on-chain code validation and decoding harder to deal with since it would not be possible to know the immediate stack values. Example Validation. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 4.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "70",
                    "likes": "0",
                    "time": "26/02/2019-23:03:24",
                    "content": "    latrasis:  I would second @arachnid\u2019s request to keep instruction set representation constant.   Nick convinced me too, and the current draft moves the jump tables into the data section.  So all of the proposed instructions now take a fixed number of inline bytes, if any. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "71",
                    "likes": "0",
                    "time": "28/02/2019-15:55:42",
                    "content": "I don\u2019t agree that having this new encoding scheme for opcodes make it \u201ca lot\u201d more complex. It\u2019s trivial to implement. Using PUSH as some kind of prefix might look that you don\u2019t have to do any changes to EVM implementations, but if you want a fast EVM you probably will have to do something about it anyway. I\u2019d like to see code diffs implementing both variants. So maybe we will save some developers time in EVM code, but this pattern would have be recognized by all analysis tools, tracers, and finally smart contract developers. I\u2019m not sure it is worth it. That wasn\u2019t the case for me before, but now I prefer to add new opcodes instead of trying to extend the semantics of existing ones as we did e.g. with SSTORE or CALL. Anyway, I\u2019d like to propose to leave the opcode encoding issue until the end. I\u2019m sure we will find a way to encode new opcodes in a way that satisfies everyone. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.987898465171192
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "72",
                    "likes": "1",
                    "time": "28/02/2019-16:52:32",
                    "content": "    chfast:  Anyway, I\u2019d like to propose to leave the opcode encoding issue until the end. I\u2019m sure we will find a way to encode new opcodes in a way that satisfies everyone.   I\u2019m recommending the same scheme that Wasm uses, which has been thoroughly reviewed and tested by now.  And it satisfies @Arachnid\u2019s  problems with multibyte encodings.  And we are getting very near the end  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.9579545454545455
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nevillegrech",
                    "index": "73",
                    "likes": "0",
                    "time": "28/02/2019-17:14:42",
                    "content": "A few more thoughts: I also think the complexity of having this feature is manageable, especially compared to something like ewasm. E.g., one shouldn\u2019t underestimate the complexity of building a transpiler (which ideally is backed by formal proof) that will convert existing EVM to eWASM and preserve exactly the same semantics (incl. gas). It would be interesting to document the required effort to implement EIP-615 for a static analysis framework like we use in contract-library.com and also quantify the benefit in fidelity we get at some point on a few large experimental programs. My estimate is that it would around a week to implement and test properly (with bytecode parsing being insignificant in terms of effort). The improvement in fidelity of the analysis would be well worth the effort in larger contracts. Interestingly, it also seems like semantic-preserving conversion from EVM bytecode to YUL and vice versa should be easier after this change. My impression is there is hardly much difference in the abstraction level after EIP-615, except for types. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.113839285714286
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MrChico",
                    "index": "74",
                    "likes": "0",
                    "time": "28/02/2019-17:16:09",
                    "content": "Can you explain what this encoding looks like? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "75",
                    "likes": "0",
                    "time": "28/02/2019-19:23:46",
                    "content": "Which encoding?  The encoding of the instructions is laid out in the [proposal] (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-615.md)  I\u2019ve changed JUMPV and JUMPSUBV so that they have fixed-length immediate data. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "76",
                    "likes": "0",
                    "time": "01/03/2019-05:24:52",
                    "content": "I like the change; it provides for reuse of jump tables too, which is nice.  The vector is stored inline at the  jump_targets  offset after the BEGINDATA bytecode as MSB-first, two\u2019s-complement, two-byte positive integers.  Why specify that they\u2019re twos-complement if they must always be positive? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.757575757575758
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "77",
                    "likes": "1",
                    "time": "01/03/2019-17:08:05",
                    "content": "    Arachnid:   The vector is stored inline at the jump_targets offset after the BEGINDATA bytecode as MSB-first, two\u2019s-complement, two-byte positive integers.  Why specify that they\u2019re twos-complement if they must always be positive?   They want to reserve the top most bit for future use. I think it should be \u201ctwo\u2019s-complement, signed, two-byte positive integers\u201d. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.401515151515151
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "78",
                    "likes": "1",
                    "time": "01/03/2019-19:04:58",
                    "content": "Two\u2019s complement implies signed. But if you want to reserve the most significant bit, why not say so, instead of specifying signed numbers and then requiring them to be always positive? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.837121212121212
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "79",
                    "likes": "0",
                    "time": "01/03/2019-19:06:19",
                    "content": "I am inclined to agree with @Arachnid here. IMO reserving the top bit is more straightforward. Thoughts @gcolvin? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.291666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "80",
                    "likes": "0",
                    "time": "01/03/2019-20:06:34",
                    "content": " If the index is greater than or equal to  n - 1  the last (default) offset is used.  Why not have the same behavior as INVALID or STOP? I suppose that would make it harder to prove the absence of an exceptional halting state, but it might be better than having a more nuanced bug. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.141203703703704
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "81",
                    "likes": "0",
                    "time": "01/03/2019-20:11:36",
                    "content": "Maybe I have an answer to my own question. If you treat JUMPV as an optimized version of a tree of JUMPIF, having all 1\u2019s as conditions would jump to the last leaf in the tree. But that is not really an explanation of JUMPSUBV because it cannot be an optimization of JUMPSUBI (because it is not in the proposal). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.833333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "82",
                    "likes": "1",
                    "time": "02/03/2019-07:31:05",
                    "content": "What is the wording you want @Arachnid?  Is there existing wording in the YP that fits?  MSB-first, unsigned, highest bit set to 0.     charles-cooper:   If the index is greater than or equal to n - 1 the last (default) offset is used.  Why not have the same behavior as INVALID or STOP?   I\u2019m following Wasm\u2019s semantics here.  I should probably say so. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "83",
                    "likes": "2",
                    "time": "02/03/2019-07:52:01",
                    "content": "    nevillegrech:  It would be interesting to document the required effort to implement EIP-615 for a static analysis framework like we use in contract-library.com   Sidney Amani extended Yoichi\u2019s work to handle this EIP in Lem.  We worked on it off-and-on from Nov '17 through Jan '18.  https://github.com/seed/eth-isabelle/tree/evm15 ",
                    "links": [
                        "https://github.com/seed/eth-isabelle/tree/evm15"
                    ],
                    "GPT-discussion-categories": [],
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "84",
                    "likes": "1",
                    "time": "02/03/2019-09:41:16",
                    "content": "They are integers, not arbitrary bit patterns, whether they are described as @chfast does or as @Arachnid does.  And the same bit patterns.  So \u201cMSB-first, twos-complement, signed, two-byte positive integers\u201d, or \u201cMSB-first, unsigned, two-byte integers less than 2^63.\u201d  I don\u2019t have an opinion, @expede. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.138257575757575
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/montyly",
                    "index": "85",
                    "likes": "5",
                    "time": "15/03/2019-20:07:49",
                    "content": "I am really enthusiastic about the use of static calls and subroutines. At Trail of Bits, we spent a lot of effort building static analyzer and reverse engineering tools for EVM, and we always struggle because of the lack of clear stack-frame definition. These changes will clearly make EVM more suitable for code analysis and help anyone doing program analysis. Is there any blocker for pushing this EIP? What are the next steps/deadlines? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.527777777777778
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "86",
                    "likes": "0",
                    "time": "17/03/2019-14:16:34",
                    "content": "In a discussion on AllCoreDevs Martin Swende noticed problems in the Backwards Compatibility section that are probably going to require some a versioning scheme. Greg Colvin @gcolvin 01:42 @holiman I think you are right. A proposal for versioning code upfront is probably needed. eWasm will need one too, if it hasn\u2019t proposed one already. Noel Maersk @veox 02:44 @gcolvin I vaguely remember @Arachnid proposing a contract versioning scheme (with a VERSION operation IIRC); not sure if this was just chat or a forum topic. Here: EM thread 2440 (but see ensuing discussion, next few comments at least). Also with keyword \u201cversioning\u201d: EM thread 2286 (which I haven\u2019t seen before). Noel Maersk @veox 02:49 There\u2019s also ethereum/EIPs#1712 (draft, \u201cDisallow Deployment of Unused Opcodes\u201d; discussion: sorpaas/EIPs#4) which may be tangentially related. Noel Maersk @veox 02:59 And issue ethereum/EIPs#154 from 2016; and pull ethereum/EIPs#1707, linked therein\u2026 In short: there\u2019s 3-5 proposals on versioning, in various states of \u201cstuck draft\u201d. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.4642857142857135
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/veox",
                    "index": "87",
                    "likes": "3",
                    "time": "17/03/2019-16:50:02",
                    "content": "The links in above copy-paste (in order of appearance):  Immutables, invariants, and upgradability EVM instruction set versioning https://github.com/ethereum/EIPs/pull/1712 https://github.com/sorpaas/EIPs/issues/4 https://github.com/ethereum/EIPs/issues/154 https://github.com/ethereum/EIPs/pull/1707  ",
                    "links": [
                        "https://ethereum-magicians.org/t/evm-instruction-set-versioning/2286?u=veox",
                        "https://github.com/ethereum/EIPs/pull/1712",
                        "https://github.com/sorpaas/EIPs/issues/4",
                        "https://github.com/ethereum/EIPs/issues/154",
                        "https://github.com/ethereum/EIPs/pull/1707",
                        "https://ethereum-magicians.org/t/evm-instruction-set-versioning/2286/6"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "88",
                    "likes": "0",
                    "time": "17/03/2019-17:10:04",
                    "content": "Thanks, Noel @veox. (Post must be at least 20 characters.) ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "89",
                    "likes": "0",
                    "time": "18/03/2019-10:43:45",
                    "content": "And https://github.com/ethereum/EIPs/issues/178. So yes, a number of proposals for EVM versioning have been made. None of them reached a proper EIP draft. I also believe this is prerequisite for static jumps. ",
                    "links": [
                        "https://ethereum-magicians.org/t/evm-instruction-set-versioning/2286/6"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "90",
                    "likes": "2",
                    "time": "18/03/2019-11:47:25",
                    "content": "    montyly:  Is there any blocker for pushing this EIP? What are the next steps/deadlines?   Main blocker has been lack of Foundation funding. (Edit: not so much blocker as slower-downer.) Next step will be Last Call once issues are resolved here. Deadlines are tracked at https://en.ethereum.wiki/roadmap/istanbul  2019-05-17 (Fri) hard deadline to accept proposals for \u201cIstanbul\u201d 2019-07-19 (Fri) soft deadline for major client implementations  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.1484375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "91",
                    "likes": "1",
                    "time": "19/03/2019-14:36:06",
                    "content": "    gcolvin:  In a discussion on AllCoreDevs Martin Swende noticed problems in the Backwards Compatibility section that are probably going to require some a versioning scheme.   @chfast @veox @holiman Most of the existing versioning proposals involve starting the contract with a currently invalid bytecode and interpreting what follows as some sort of version name or number.  If we don\u2019t want to sort through them all, reopen their discussions, and get consensus on a general scheme, then we can solve the problem just for this proposal. We can insist in EIP-615 that the implicit main routine that begins each contract must instead start with an explicit, BEGINSUB 0,0.  That marks post-615 code and makes it invalid to pre-615 VMs. In Phase One only post-615 code must be valid.  In an optional Phase Two we stop allowing pre-615 contracts at all, except as created by pre-615 contracts. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.597222222222222
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "92",
                    "likes": "0",
                    "time": "28/03/2019-19:05:10",
                    "content": "    gcolvin:  We can insist in EIP-615 that the implicit main routine that begins each contract must instead start with an explicit, BEGINSUB 0,0 . That marks post-615 code and makes it invalid to pre-615 VMs. In Phase One only post-615 code must be valid. In an optional Phase Two we stop allowing pre-615 contracts at all, except as created by pre-615 contracts.   Well, what if I, today, deploy a contract that starts with BEGINSUB 0,0. It won\u2019t be executable now, but after the fork, it will look like one of the new contracts. The difference being that my jumps have not been validated, and any deploy-time validations that should have been done have thus been skipped. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.505050505050505
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "93",
                    "likes": "0",
                    "time": "28/03/2019-21:53:14",
                    "content": "Damn.  Do we really do that little checking now?  I shudder to go look in the Yellow Paper.  And fear this is why all of the versioning EIPs are in some state of stuckness.  But yes, it would be a breaking change to cause a program that used to stop immediately with an invalid instruction to instead do something unintended. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.020833333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "94",
                    "likes": "0",
                    "time": "29/03/2019-07:02:01",
                    "content": "@holiman One way out (and we start getting into solving the whole versioning problem here) is to follow the leading new bytecode with something that is statistically highly unlikely to be there, like a hash of the rest of the contract\u2019s code. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.7272727272727275
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "95",
                    "likes": "0",
                    "time": "29/03/2019-08:34:29",
                    "content": "    gcolvin:  with something that is statistically highly unlikely to be there, like a hash of the rest of the contract\u2019s code.   Well, that won\u2019t stop a malicious coder from doing the same thing, right? Unfortunately, we don\u2019t have address namespaces, that would have been great to have from the beginning. So that certain address spaces have different mechanics. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.214285714285714
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "96",
                    "likes": "0",
                    "time": "29/03/2019-13:45:59",
                    "content": "Not sure what the malicious coder gets besides marking a contract as post-Istanbul.  The rest of the bytecode still has to be valid, and the hash still has to be right. The idea is just to be sure that no pre-Istanbul contracts accidently look like post-Istanbul contracts. Not sure what you mean by address namespaces. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None"
                    ],
                    "Sentiment": 4.973214285714286
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "97",
                    "likes": "0",
                    "time": "30/03/2019-04:32:18",
                    "content": "@holiman @sorpaas @chfast None of the proposals listed above take note of the problem you found.  But this proposal doesn\u2019t have that problem.  EIP-1707: Use Version Byte Prefix for Contract Account Versioning It uses 0x00 as the leading byte, in combination with there being sufficient following bytes to hold the version identifier.  But this assumes that a contract beginning with STOP can not have any following bytes, which I\u2019m not sure is true. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.1
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ajsutton",
                    "index": "98",
                    "likes": "0",
                    "time": "30/03/2019-06:12:00",
                    "content": "    gcolvin:  But this assumes that a contract beginning with STOP can not have any following bytes, which I\u2019m not sure is true.   I don\u2019t believe there\u2019s any restrictions on what the code for a contract can be. Whatever is returned from the creation transaction is stored without question. So there is no way to embed the version in the code itself without it being possible to deliberately set that up in a contract. I believe you\u2019d have to add a field to the account state entry to indicate the code version being used by the contract (if the field isn\u2019t present it\u2019s assumed to be the version we\u2019re running now). Transactions would either be assumed to be the latest or could potentially have a similar version field added. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "99",
                    "likes": "0",
                    "time": "30/03/2019-19:30:45",
                    "content": "I don\u2019t believe there\u2019s any restrictions on what the code for a contract can be. [/quote] That was my fear.  I do think my idea of using a hash of the contract might work, despite @holiman\u2019s worries. To be concrete:  A new type of contract (EIP-615, eWasm, or whatever) has this layout. a. the code length is at least 21 + TBD bytes b. the first byte is null c. the next TBD bytes are a valid version identifier d. the following bytes up to the DATA section are valid code e. the last 20 bytes are the correct RIPEMD-160 hash of all the preceding bytes Anything else is an old type of contract.  The problem we want to prevent is an old contract accidently looking like a new contract.  I\u2019m not up for the calculation right now, but the odds of the last 20 bytes just happening to be the right hash of the preceding bytes look to be vanishingly small. (Please correct me if I\u2019m being stupid.)  And in that case the version identifier and the code would also have to be valid. I\u2019m not sure what an exploit would look like.  An attacker can only deploy code that either looks like old code and is run as such, or looks like new code and is validated and run as such.     ajsutton:  I believe you\u2019d have to add a field to the account state entry to indicate the code version being used by the contract   This would work fine, of course.  The disadvantage is that you couldn\u2019t tell from the bytecode itself what kind of bytecode it is.  This makes it harder on tools that only have the bytecode to work with. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.19943722943723
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "100",
                    "likes": "0",
                    "time": "30/03/2019-23:03:15",
                    "content": "I want to repeat my argument that treating contract code as data is problematic (both that it may break things we currently have, and it will be roadblocks for future hard forks). So far I don\u2019t see any other uses of it than Solidity\u2019s behavior of metadata postfix. I suggest we put that behavior to a stop.     gcolvin:  The problem we want to prevent is an old contract accidently looking like a new contract.   I don\u2019t think you even need the 20-bytes RIPEMD postfix. The chances of an old contract accidentally look like a new contract wouldn\u2019t be higher than the scenario where we add new opcodes to EVM, and some old contracts\u2019 data accidentally contains the new opcode, then drastically change the old contract\u2019s behavior. We have deployed many new opcodes and it doesn\u2019t seem like anyone\u2019s complaining. So I argue that from risk assessment perspective adding a new type of contract wouldn\u2019t be an issue. And to be honest, all of this is caused by the fact that we allow code as data, while we actually did not intend it to be (EVM\u2019s JUMPDEST analysis treats all code as code), and did not provide any basic guarantee (like in ELF format) that data section won\u2019t be accidentally executed. I suggest we just disallow this behavior (using EIP-1712 or some sorts) to clear paths for our future hard fork. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.4477931488801055
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "101",
                    "likes": "1",
                    "time": "30/03/2019-23:40:04",
                    "content": "    sorpaas:  I want to repeat my argument that treating contract code as data is problematic   I agree.  That\u2019s why EIP-615 adds a DATA section and disallows invalid contract code elsewhere.  I think @holiman\u2019s concern is that in current contracts there may be bytes after a leading STOP opcode which look like a valid version identifier followed by executable bytecode, so the contract will no longer stop immediately, but will run the code. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "102",
                    "likes": "0",
                    "time": "31/03/2019-00:01:47",
                    "content": "    gcolvin:  I think @holiman\u2019s concern is that in current contracts there may be bytes after a leading STOP opcode which look like a valid version identifier followed by executable bytecode, so the contract will no longer stop immediately, but will run the code.   Yeah, so my second argument in the previous post is that the risk of this wouldn\u2019t be higher compared with the risk of adding new opcodes. When adding new opcodes, there is always a similar risk where a contract has \u201cdata\u201d bytes that accidentally equal to the new opcodes. We have been adding new opcodes just fine, so from the risk assessment point of view, it also shouldn\u2019t be a problem for versioning prefix. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.475206611570248
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "103",
                    "likes": "0",
                    "time": "31/03/2019-00:31:17",
                    "content": "I understand your argument. I\u2019m not sure whether to ban the practice, or simply admit that such programs are and will be in trouble.  With EIP-615 they\u2019ll be deprecated, probably banned later. But I also think there are contracts that immediately stop on purpose. Edit:  One reason would be to store data after the leading null. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.55
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "104",
                    "likes": "0",
                    "time": "31/03/2019-12:47:10",
                    "content": "    gcolvin:  I think @holiman\u2019s concern is that in current contracts there may be bytes after a leading STOP opcode which look like a valid version identifier followed by executable bytecode, so the contract will no longer stop immediately, but will run the code.   No, I see now I must have been to vague. So my concern is that the EIP (note: this may be a misunderstanding on my part, I might just have missed something) vaguely says things like \u201c\u2026 then the contract/ code is invalid\u201d. And it emerges that at some point, there is a validation performed, saying \u201cyes ok, this code is fine for deploying\u201d.  So the EIP premise is that you can\u2019t throw any code up there, only \u2018valid\u2019 code.  Now, here\u2019s my concern: At any time before this \u2018validity\u2019-check becomes enforced, I can place valid-looking (magic bytes, hashes, the works) on chain, but the actual code contains \u2018invalid\u2019 things, like static jumps into data-sections, or generally breaking any of the invariants that the EIP promises. And, needless to say, unless this behaviour is well defined, we have an immediate chain split here. So, if an attacker does put such code there, it\u2019s not sufficient to say \u201coh that\u2019s invalid\u201d \u2013 because how will we know it is invalid? The only way to detect that we just jumped into a data-section, violating the invariants promised by this eip, is \u2026 jumpdest analysis! PLUS basically redoing the entire validity-check that supposedly was done at deploy-time. So, basically, as far as I see it, that removes any speed-gains that the new EIP static jumps would have brought to the EVM. For program flow analysis during development, this EIP offers nothing (because a superior flow analysis can be done using AST), and the only tangible gain is analysis/decompilation of evm bytecode. Now, there are ways to solve this, but the only way I can think of is to modify the state storage; add flags or something to signify that this is \u2018validated code\u2019. The same bitflags could be used to signify \u2018this is ewasm\u2019. So, please let me know what I missed, because I really don\u2019t understand how this is intended to work. Oh, and one last thing: I don\u2019t think the current jumpdest analysis is that bad. It\u2019s a one-time pass over the code, and the actual analysis size needs only be one eiigth of the code size \u2013 if using a bitmap for code/data sections. Checking that the destination is JUMPDEST can be done at the time of the jump. In geth, a jumpdest analysis is far faster than e.g. calculating the code hash.The entire jumpdest analysis is also lazily done at the first jump. For reference \u2013 the jumpdest analysis in geth: https://github.com/ethereum/go-ethereum/blob/master/core/vm/analysis.go ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.250473484848484
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "105",
                    "likes": "2",
                    "time": "31/03/2019-14:31:32",
                    "content": "    holiman:  Oh, and one last thing: I don\u2019t think the current jumpdest analysis is that bad.   Not commenting on the rest of the argument provided by @holiman, but I fully agree that jumpdest analysis is not bad. The bitmap can even be cached in state. One thing I want to point out is that a lot of reasons why we lack more EVM optimizations are not because it cannot be optimized, but because we had the inexplicit intuitions shared among teams that it\u2019s I/O, not EVM, that is the actual bottleneck for performance. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "106",
                    "likes": "2",
                    "time": "31/03/2019-14:56:20",
                    "content": "I\u2019m not much concerned about the cost of JUMPDEST analysys, although it will be done statically in EIP-615     holiman:  Well, what if I, today, deploy a contract that starts with BEGINSUB 0,0 . It won\u2019t be executable now, but after the fork, it will look like one of the new contracts. The difference being that my jumps have not been validated, and any deploy-time validations that should have been done have thus been skipped.   This was your original concern.  I saw here a more general concern that we wouldn\u2019t know whether this contract was valid, but would run it anyway, with indeterminate results.  So I started looking at schemes for identifying whether a contract was an EIP-615 contract, which led into general schemes for identifying and versioning contracts. I think @sorpaas argues that this is just a special case of a bigger problem: that adding opcodes can change the execution of any program that contains them, so there is no reason to worry about this case in particular. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.852873977873978
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "107",
                    "likes": "1",
                    "time": "31/03/2019-15:03:22",
                    "content": "    sorpaas:  One thing I want to point out is that a lot of reasons why we lack more EVM optimizations are not because it cannot be optimized, but because we had the inexplicit intuitions shared among teams that it\u2019s I/O, not EVM, that is the actual bottleneck for performance.   This is likely true, though part of my work on optimizing the C++ interpreter was eventually stymied by dynamic jumps.  And we hear many complaints from formal analysts about things like recognizing the contortions Solidity goes through to implement subroutines. Edit:  Also, compilers can produce good machine code from unstructured bytecode, but given structured bytecode (like Wasm) they can produce it in a single n log(n) pass.  Compilers that can go quadratic are an attack surface. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.236607142857142
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "108",
                    "likes": "0",
                    "time": "31/03/2019-17:31:54",
                    "content": "    gcolvin:  This was your original concern. I saw here a more general concern that we wouldn\u2019t know whether this contract was valid, but would run it anyway, with indeterminate results. So I started looking at schemes for identifying whether a contract was an EIP-615 contract, which led into general schemes for identifying and versioning contract   Ok good, then we\u2019re on the same page. I thought we were on different tracks when you wrote \u201caccidentally looking like\u2026\u201d and \u201cthe odds of the last 20 bytes just happening to be the right hash\u201d, then it sounded like you were not addressing intentional attacks.     gcolvin:  I\u2019m not sure what an exploit would look like. An attacker can only deploy code that either looks like old code and is run as such, or looks like new code and is validated and run as such.   So then I guess the EIP is missing a lot of details on exactly how to deal with invalid \u201cnew\u201d code. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.6936327561327555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "109",
                    "likes": "0",
                    "time": "31/03/2019-17:40:38",
                    "content": "    holiman:  So then I guess the EIP is missing a lot of details on exactly how to deal with invalid \u201cnew\u201d code.   Exactly.  I think we need some way to distinguish old and new code.  Are we on the same page there? None of the existing proposals for doing that with versioning work, except for adding a field to the account state, which has other problems. Thus I\u2019m asking @holiman whether a scheme that uses a hash of the bytecode can serve the purpose. ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.2938311688311686
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "110",
                    "likes": "0",
                    "time": "31/03/2019-18:42:19",
                    "content": "    gcolvin:  None of the existing proposals for doing that with versioning work, except for adding a field to the account state, which has other problems. Thus I\u2019m asking @holiman whether a scheme that uses a hash of the bytecode can serve the purpose.   I was about to answer \u201cNo, because how can you prevent me from adding the same hash to my malicious contract\u201d \u2026 but then i figured out a scheme. Note, though, that it\u2019s a hacky scheme that I wouldn\u2019t recommend. But it would work, so I\u2019ll present it even so. So if we fork at block N, we could do hash= keccak(code_hash + hx)  where hx is blockhash for block N-1. The attacker wouldn\u2019t know beforehand what hx is, and can\u2019t put the right hash in place. It\u2019s butt-ugly because we\u2019ll have to always remember/lookup hash hx every time we execute a contract (eventually hardcode it). Also, the codeHash in the trie won\u2019t help us here, since the codeHash is the entire thing - includign the prepended hash. So we\u2019d basically have to hash the code[32:] at every execution to check if it\u2019s \u2018legit\u2019 or not. My overall impression at this point though, is that the very high complexity of this EIP overshadows the gains. But then I\u2019m coming from the evm-perspective, where I don\u2019t see that it will speed things up that much (for the reason @sorpaas pointed out). Perhaps there are other perspectives than evm speed that are very important for other people \u2013 if so, I\u2019d very much like to learn about those usecases more in-depth. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.7495408163265305
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "111",
                    "likes": "1",
                    "time": "31/03/2019-18:59:26",
                    "content": "Just throwing this random idea out there: what if we use a 31-byte codeHash for new code. Where\u2026 codeHash := version(byte) ++ keccak256(code)[:30] . That means we\u2019d lessen the actual hash strength from 32 bytes to 30, but we\u2019d get a versioning method that can contain 256 variants. And we\u2019d sacrifice one byte to signifify that this is versioned_codehash and not oldstyle codehash. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.393939393939394
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "112",
                    "likes": "0",
                    "time": "31/03/2019-19:16:31",
                    "content": "This isn\u2019t a just block N thing.  It\u2019s \"was it deployed with the EIP-615 validator\u2019\u2019.  If it was, then it is interpreted by those rules.  Simple enough. So the problem is how to tell if it was.  This a general problem that needs to be solved regardless.  One solution is EIP-1707 which says \u201cafter block N contracts will be deployed with a header containing a version identifier.\u201d  Simple enough. But EIP-1707 may have a problem\u2013old code that begins with STOP followed by data bytes can be mistaken for new code and executed with indeterminate results.  One solution is to append a footer with a hash of the code.  Whatever the scheme, it\u2019s a bit of complexity.  I think it\u2019s not that much complexity in practice\u2013we are pretty used to dealing with hashes, and the clients have a few at hand anyway. If we are on the same page then getting EIP-1707 in place takes care of the version problem, so we know how to interpret the code.  And it pushes this complexity out of EIP-615. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.218181818181819
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "113",
                    "likes": "1",
                    "time": "31/03/2019-19:41:36",
                    "content": "    gcolvin:  This isn\u2019t a just block N thing. It\u2019s \"was it deployed with the EIP-615 validator\u2019\u2019. If it was, then it is interpreted by those rules. Simple enough.   How are those two not the same thing? Anything after block N is deployed with the EIP-615 validator, no? (N has nothing to do with the contract deployment block, it\u2019s the fork block number) The problem with 1707 is that it\u2019s not exclusive. Any contract can opt-in on that. And EIP-615 requires exclusivity. Hashes won\u2019t give you that, unless you use a scheme like mine where the forkblock-1 hash becomes magic. So IMO 1707 does not help 615 (at least not the aspect I\u2019m concerned about). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.2
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "114",
                    "likes": "0",
                    "time": "31/03/2019-19:56:17",
                    "content": "    holiman:  How are those two not the same thing? Anything after block N is deployed with the EIP-615 validator, no?   Aha.  No, the spec must allow for unvalidated new code, if only to support old code that deploys unvalidated code itself.  It currently allows users to deploy unvalidated code in order to allow for a smooth transition. I\u2019m not sure what you mean by exclusivity, but I like magic.  Please explain? It seems that an sort of hash lets you tell whether code was deployed with 1707 versioning or not. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.3188131313131315
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "115",
                    "likes": "0",
                    "time": "31/03/2019-20:27:55",
                    "content": "I think I may understand what @holiman might mean by exclusivity (correct me if I\u2019m wrong!). The issue is that we validate EIP-615 contract code on contract deployment, but an attacker can pre-deploy something that looks like it has that version, but is actually invalid. Throwing an idea here: EIP-1891: Contract-based Account Versioning by sorpaas \u00b7 Pull Request #1891 \u00b7 ethereum/EIPs \u00b7 GitHub I think if we want to make sure version bytes cannot be faked, then we just cannot save it in account code. Changing account RLP structure to have an extra item definitely works (like EIP-1702 or some sorts), but why don\u2019t we just store those extra items in a known contract\u2019s storage?  ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/1702"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 4.6875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "116",
                    "likes": "0",
                    "time": "31/03/2019-21:57:13",
                    "content": "Aha.  I see the problem, @sorpaas, whether it is what @holiman  worries about or not. Let\u2019s say that the deployment mechanism always prepends a version identifier, including for code deployed at runtime by contacts that have already been deployed. So the runtime can know that anything deployed after blocknumber N has a version identifier and run the appropriate VM. No hash needed.  Am I missing something? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "117",
                    "likes": "0",
                    "time": "31/03/2019-22:08:21",
                    "content": "    gcolvin:  So the runtime can know that anything deployed after blocknumber N has a version identifier and run the appropriate VM.   It still needs something like EIP-1891 or EIP-1702, because otherwise you have no way to know whether a contract is deployed before or after block N. ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/1702"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "118",
                    "likes": "0",
                    "time": "31/03/2019-22:21:12",
                    "content": "Storing info in state or storage works for deployed code, but not otherwise.  Seems good if we can just extend the existing Wasm header. I\u2019d suggest starting at  0x00evm0x010x000x00  for unvalidated code and  0x00evm0x010x050x00  for validated EVM-615 code.  So we have asm.1.0.0,  evm.1.0.0  and evm.1.5.0 to start with, and plenty of room for more. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 7.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "119",
                    "likes": "0",
                    "time": "31/03/2019-23:06:47",
                    "content": "    sorpaas:  It still needs something like EIP-1891  or EIP-1702 , because otherwise you have no way to know whether a contract is deployed before or after block N.   We are into parts of the runtime that I don\u2019t understand.  My assumption was that the runtime would have some way to know the block number of the transaction doing the creation of a block. Apparently I\u2019m wrong. In which case you are right.  EIP-1702 makes the most sense to me, though I think that also maintaining a version header in the source code (as Wasm does anyway) makes sense. ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/1702"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.419642857142857
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "120",
                    "likes": "0",
                    "time": "31/03/2019-23:09:54",
                    "content": "TBH if you let me choose from EIP-1702 and EIP-1891, I would choose EIP-1891. They both accomplish the same thing, but EIP-1702 is comparably more complicated to implement. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "121",
                    "likes": "0",
                    "time": "31/03/2019-23:57:32",
                    "content": "    gcolvin:   In a discussion on AllCoreDevs Martin Swende noticed problems in the Backwards Compatibility section that are probably going to require some a versioning scheme.    @chfast @veox @holiman @sorpaas @ajsutton @axic @expede We\u2019ve had a few days of discussion on this, and I think the upshot is that we need to solve the general versioning problem now.  Wei Tang has a few proposals worth considering, plus the discussion so far has surfaced a number of problems and ideas. For EIP-615 I think that the spec should just state that versioning is needed and require a wasm-style version header. For a versioning solution I think work needs to continue on Wei Tang\u2019s existing EIPs, or a new one that supersedes them.  What do you think, @sorpass?  And are people able to help? EIP-1702: Generalized Account Versioning Scheme EIP-1707: Use Version Byte Prefix for Contract Account Versioning EIP-1891: Contract-based Account Versioning ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/1707",
                        "https://github.com/ethereum/EIPs/pull/1891"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.49025974025974
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "122",
                    "likes": "0",
                    "time": "01/04/2019-00:51:08",
                    "content": "I would of course prefer EIP-1891. That\u2019s the best I can come up with so far, and what I really like about it is that it nicely solved many of the immutability / invariant issues, and in the mean time, doesn\u2019t have all the complexity of adding another RLP field to state. I\u2019m definitely biased so I would be really happy if someone can check whether I missed some important things. The downside, as @gcolvin pointed out, is that only deployed contract will have versioning, while contract creation transaction will stuck at the legacy version. I don\u2019t think this is an issue \u2013 most of contract creation transactions are just to emit the contract code. This might complicate deployment strategy (because it requires to call VCREATE and VCREATE2 instead of a plain contract creation transaction). But still, we can always introduce new transaction types in the future to make it easier. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.324849257884972
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "123",
                    "likes": "0",
                    "time": "01/04/2019-01:04:24",
                    "content": "I think I prefer a combination of 1707 and 1702.  But there is too much I don\u2019t understand about the requirements and the information available at deployment and runtime to be sure. ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 6.833333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ajsutton",
                    "index": "124",
                    "likes": "0",
                    "time": "01/04/2019-01:11:02",
                    "content": "Personally I\u2019d lean towards adding a field to the account state.  I may be missing some complexities, but state fields were added as part of the state rent proof of concept I built and they were straight-forward to implement. The field in the account state feels like the right thing to do as it keeps all the account meta-data in one place. The contract based versioning incurs additional overhead to walk the contract storage trie, plus the additional complexity of VCREATE & VCREATE2. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.142857142857142
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "125",
                    "likes": "0",
                    "time": "01/04/2019-02:05:47",
                    "content": "A possible problem with EIP-1702 is  When a version 0 account issues a CREATE, it always uses the newest version of the virtual machine, so it only creates version 1 new accounts.  But a version 0 contract is not likely to want to create version 1 contracts, it\u2019s going to want to create version 0 contracts like it always did. That\u2019s why I\u2019d prefer that version 0 accounts always create version 0 contracts, and later versions create the kind of contract indicated by the version header. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.613636363636364
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ajsutton",
                    "index": "126",
                    "likes": "0",
                    "time": "01/04/2019-02:19:41",
                    "content": "    gcolvin:  But a version 0 contract is not likely to want to create version 1 contracts, it\u2019s going to want to create version 0 contracts like it always did. That\u2019s why I\u2019d prefer that version 0 accounts always create version 0 contracts, and later versions create the kind of contract indicated by the version header.   Yes, I\u2019d agree with that change. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "127",
                    "likes": "1",
                    "time": "01/04/2019-12:29:32",
                    "content": "Yes @sorpaas correctly interpreted me. In a more general sense, the versioning scheme must be able to handle two different types of versionings, I\u2019d like to call them declarations and certfications.  declaration: I am a contract of type X, want access to features Y, certification: This contract is validated to comply with Z.  EIP-615 requires the versioning schema to handle certifications, and I assume ewasm will aswell. Whereas other new cool features may only need declarations. Declarations can be used to modify evm behaviour without breaking backward compatibility. Regarding state field, my concern is about bloating the data size even more. Also, won\u2019t adding a new field to the rlp require a full rehashing of the entire state trie at the fork-block? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.999053030303029
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "128",
                    "likes": "0",
                    "time": "01/04/2019-13:06:30",
                    "content": "The declaration and certification is good description of this. Yes, both Ewasm and EIP-615 require certification that moves some validity checks from execution time to deployment time. The code prefix with version does not work for this because you can bypass deployment-time certification. We discussed some options internally. So far I don\u2019t see any other promising solution than extending RLP of an account by an optional field with \u201ccode version\u201d. We want to do it in \u201cdynamic\u201d way so accounts\u2019 RLP will contain either 4 or 5 items. For 4 items we assume code version 0. This removes the need of rehashing everything and saves some space (although I haven\u2019t considered state size until today). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.09375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "129",
                    "likes": "0",
                    "time": "01/04/2019-15:29:38",
                    "content": "I was wanting both the version header (I am a contract of type asm.1.0.0) and the state field (I have been validated and deployed as asm.1.0.0).  Is that what you had in mind @holiman? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "None of the topics listed match."
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "130",
                    "likes": "0",
                    "time": "01/04/2019-16:08:04",
                    "content": "If that\u2019s the intention, then yes, that alleviates my concerns about malicious contracts. However, if you want to enable 615-features without validation in a first step, then we\u2019re back to the same problems again\u2026(?) If it will only be used when the certification is in place, then I guess the EIP needs a specification of the versioning scheme that it requires. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.3125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "131",
                    "likes": "0",
                    "time": "01/04/2019-17:56:34",
                    "content": "    holiman:  However, if you want to enable 615-features without validation in a first step, then we\u2019re back to the same problems again\u2026(?)   EIP-615 code has to be validated up front. I don\u2019t think this EIP should spec the versioning scheme, but it needs to refer to an EIP that does.  From the last few messages EIP-1702 looks to be the best starting point, plus the version header taken from the Wasm spec. Do you agree, @sorpass? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "132",
                    "likes": "0",
                    "time": "01/04/2019-19:49:51",
                    "content": "    chfast:  So far I don\u2019t see any other promising solution than extending RLP of an account by an optional field with \u201ccode version\u201d.   Just wonder, have you checked EIP-1891 where we can store it in contract storage?     gcolvin:  From the last few messages EIP-1702 looks to be the best starting point, plus the version header taken from the Wasm spec.   I still hold some similar reservations as @holiman, that adding RLP item can complicate things (especially for big clients like geth and parity, where we (accidentally or on purpose) made assumptions that account RLP is 4-item). But anyway, It looks like going with an additional RLP field is the current rough consensus. I\u2019ll try to finish updating the spec for EIP-1702 around tomorrow to fix some current issues @gcolvin and others pointed out.     gcolvin:  plus the version header taken from the Wasm spec.   @gcolvin Can you explain why you think version header is still necessary if we have RLP version field already? ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/1702"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.3125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "133",
                    "likes": "0",
                    "time": "02/04/2019-00:16:04",
                    "content": "    sorpaas:  @gcolvin Can you explain why you think version header is still necessary if we have RLP version field already?       gcolvin:  I was wanting both the version header (I am a contract of type asm.1.0.0) and the state field (I have been validated and deployed as asm.1.0.0). Is that what you had in mind @holiman?   So when bytecode is going onto the chain the header tells the client how to validate it, and when bytecode is off-chain the header tells tools how to handle it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "134",
                    "likes": "0",
                    "time": "02/04/2019-13:27:28",
                    "content": "    holiman:  Regarding state field, my concern is about bloating the data size even more. Also, won\u2019t adding a new field to the rlp require a full rehashing of the entire state trie at the fork-block?   The new fields would be introduced \u201clazily\u201d, i.e., the contracts that do not have the new field, are assumed pre-change. The old contracts would have 4 fields, whereas the new ones would have 5. This is my understanding ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.934659090909092
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "135",
                    "likes": "0",
                    "time": "02/04/2019-13:40:14",
                    "content": "    gcolvin:  So when bytecode is going onto the chain the header tells the client how to validate it, and when bytecode is off-chain the header tells tools how to handle it.   I see, but I think that\u2019s rather up to each VM version to define how it wants to be handled. For the legacy VM version we cannot have any headers anyway, because otherwise it would be backward incompatible. I updated EIP-1702 to include some of the above comments/suggestions: https://github.com/ethereum/EIPs/pull/1702/files ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "136",
                    "likes": "1",
                    "time": "02/04/2019-17:27:53",
                    "content": "    holiman:  Yes @sorpaas correctly interpreted me. In a more general sense, the versioning scheme must be able to handle two different types of versionings, I\u2019d like to call them declarations and certfications.  declaration: I am a contract of type X, want access to features Y, certification: This contract is validated to comply with Z.        gcolvin:  I was wanting both the version header (I am a contract of type asm.1.0.0) and the state field (I have been validated and deployed as asm.1.0.0). Is that what you had in mind @holiman?       holiman:  If that\u2019s the intention, then yes, that alleviates my concerns about malicious contracts.       sorpaas:  I see, but I think that\u2019s rather up to each VM version to define how it wants to be handled. For the legacy VM version we cannot have any headers anyway, because otherwise it would be backward incompatible.   It think it is up to the VM, and using the same scheme as Wasm makes sense to me.     sorpaas:  I updated EIP-1702 to include some of the above comments/suggestions: https://github.com/ethereum/EIPs/pull/1702/files   This looks good, thanks.  Shall I go ahead and merge it? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.194444444444445
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "137",
                    "likes": "0",
                    "time": "02/04/2019-17:41:00",
                    "content": " The transaction would be executed in version supplied. If version is not supported or validation does not pass, return out-of-gas.  I think the version needs to supplied by the VM during the validation phase. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "138",
                    "likes": "0",
                    "time": "02/04/2019-19:14:21",
                    "content": "    gcolvin:  I think the version needs to supplied by the VM during the validation phase.   I think that would still have the certification / validation issue. We may have innocent looking legacy code that just happen to have the header of a later VM. It would be better supply the version through external methods (an extra field in contract creation transaction or account state), and then in validation phrase, check whether the version provided in VM header matches. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "139",
                    "likes": "0",
                    "time": "02/04/2019-21:06:54",
                    "content": "How about this.  New contract creation transactions will use the new version item. CREATE and CREATE2 will use the version from the caller\u2019s state field or 0. Versions above 0 are validated, which returns the version to deploy. Validation may return a different version than it is given. The deployed version is stored in the contract state.  So the VM should not be handed legacy code to validate,  but remains free to use it\u2019s internal versioning system as it will.  If the validator does not override the input version the effect is the same as for your deployment families. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.48051948051948
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "140",
                    "likes": "1",
                    "time": "02/04/2019-22:52:40",
                    "content": "Yeah sounds like a good idea! As long as we assert that all non-legacy versions must contain a version prefix, and legacy VM can only deploy legacy version, then certification works. This will also mean that we can just make contract creation transaction always use one single version which simplifies things that need to change at that part.  I added this in section \u201cContract Deployment\u201d \u2192 \u201cAlternative Design\u201d. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.441071428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "141",
                    "likes": "0",
                    "time": "03/04/2019-10:06:57",
                    "content": "    gcolvin:  Validation may return a different version than it is given.   I\u2019m not convinced, that may have side-effects we\u2019re not aware of. I think the conservative choice here would be to have the validator be an oracle, delivering Yes or No. EDIT: maybe I misunderstood the quote. Did you mean that it may return different code, or different version bytes? I thought you meant code, that code would be mutated during the validation process. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.5625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "142",
                    "likes": "0",
                    "time": "03/04/2019-17:54:01",
                    "content": "    holiman:  Did you mean that it may return different code, or different version bytes? I thought you meant code, that code would be mutated during the validation process.   No, just different version bytes.  Otherwise it becomes difficult-to-impossible for older contracts, (say evm.1.5.1) to deploy newer code (say evm.1.5.2).  That is, the version argument  is saying, \"I need to deploy a contract of at least level 1.5.1, and the validator says, \u201cno problem, this code is level 1.5.2\u201d. Note that the version field in the state knows nothing about the semantics of the field or how the version is stored in the code\u2013thats up to the VM.  It just stores what the VM gives it and passes it back to the VM when asked. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.681547619047619
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "143",
                    "likes": "0",
                    "time": "03/04/2019-20:30:06",
                    "content": "I would suggest we pin the version. That is, if the version argument is saying \u201cI need to deploy a contract of version 1.5.1\u201d, then the validator either reject it, or say \u201cokay, the code is version 1.5.1\u201d. I\u2019d say it\u2019s a feature that older contract cannot deploy newer version code. The code is fixed, so it won\u2019t use any new features anyway. This also makes sure the semantic of the contract will not change. Otherwise we can have subtle backward compatibility issue. We\u2019ll at most have 1 or 2 new EVM versions per year. Plus supporting different versions of one VM type is easy (via feature flag) and has nearly no performance impact. So I don\u2019t see much reason why we need to drop support for version 1.5.1 when 1.5.2 is added. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.849747474747476
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "144",
                    "likes": "0",
                    "time": "04/04/2019-07:12:18",
                    "content": "We can never drop any version of a VM. So suppose a VM doesn\u2019t put version numbers in the header, just validation rules in the VM that get stricter with each release.  Then you\u2019d expect newer code to go on validating by older rules unless it uses new features. The use case I have in mind is where you have a contract that deploys code that it gets from elsewhere.  It might not care that the code it deploys is the same version that it is, just that it be compatible, which the validator can tell it.  It can also tell what is highest version it can validate as, which is what you would want to put in the state field. This sounds more complicated than it is, but I\u2019m too sleepy to be more clear. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.645021645021645
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "145",
                    "likes": "1",
                    "time": "14/04/2019-18:08:05",
                    "content": "Moving discussion of general versioning mechanism to  EIP-1702: Generalized Account Versioning Scheme.  Have put link in Draft and explanation. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "146",
                    "likes": "0",
                    "time": "14/04/2019-18:34:36",
                    "content": "To discuss here. I\u2019ve specified a version header of \u2018\u0000evm\u0001\u0005\u0000\u0000\u2019\u2013semantic versioning\u2013and that the BEGINSUB for main immediately follows this header.  So the bytecode is completely delimited into header, subroutines, and data, and the version of the bytecode is given by the header.  The validator knows what rules apply, and can tell the client what version of the VM to use in the state field. (The Wasm header is \u2018\u0000asm\u0001\u2019) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.666666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "147",
                    "likes": "1",
                    "time": "15/04/2019-10:59:30",
                    "content": "    gcolvin:  The use case I have in mind is where you have a contract that deploys code that it gets from elsewhere.   I think the current spec (newer section in \u201cAlternative Design\u201d) covers this. If a contract A deploys code B that it gets from elsewhere, the version prefix it gets is from B. This means the code deployed will always deploy with the intended version of B and does not care what version A is running on.     gcolvin:  It can also tell what is highest version it can validate as   I still suggest that we use version exactly specified, and do not go any higher. If B has the version prefix that asks to use evm 1.5.1, then we always use evm 1.5.1 and never evm 1.5.2. The use case I have in mind is that I want to make account versioning help us in avoiding bugs like EIP-1283 re-entry. Semantic versioning doesn\u2019t help us much for this case \u2013 we thought EIP-1283 was backward compatible and I can easily imagine that if we used semantic versioning, we might have bumped only patch version for it. This will not be an issue if the version is pinned to exactly what is requested. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.988095238095238
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "148",
                    "likes": "0",
                    "time": "21/04/2019-05:44:41",
                    "content": "Sorry for the belated response.  I was busy finding and am now busy preparing for a new job. (Yes, actually getting paid.) I still think the flexibility I\u2019m proposing for EIP-1702 is worth having @sorpaas   How a particular VM uses that flexibility, if at all, is another question.  Maybe no VM will or should ever need it, but I\u2019m not convinced.  Or maybe it would be easy enough to add later if it is needed, I don\u2019t know.  But with no EIP for eWasm to go by I don\u2019t want to foreclose the possibilities. Maybe @axic can shed some light. For EVM 1.5 I\u2019m afraid that if a contract asks for valid 1.5.0 code then it will not be allowed to run 1.5.1 code.  Or if it is allowed to run it, the state field will incorrectly say that it is 1.5.0 code-which would seem create a sort of race condition @holiman.  But since 1.5.0 is the only version there will be at first, the question doesn\u2019t really arise for this VM until there is a 1.5.1. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.328787878787878
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "149",
                    "likes": "0",
                    "time": "26/04/2019-21:21:31",
                    "content": "Reviewing this I\u2019m wrong about the change I requested for EIP-702.  So everything about that from me is blather, and (alternative)  EIP-702 is fine as it is. I think the main issue for this PR is just whether the proposed header is reasonable. @sorpaas, I heard @axic mention that you were also discussing this with the eWasm team.  Is there a link to those discussions?  Are we on the same track? ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/1702"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.283333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sorpaas",
                    "index": "150",
                    "likes": "1",
                    "time": "29/04/2019-16:10:45",
                    "content": "    gcolvin:  So everything about that from me is blather, and (alternative) EIP-702  is fine as it is.   Great!     gcolvin:  I heard @axic mention that you were also discussing this with the eWasm team.   No, I wasn\u2019t directly discussing this with eWasm team. But @axic if there\u2019s anything I can help to make account versioning on eWasm a reality, I\u2019m really happy to do! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 8.145833333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "151",
                    "likes": "1",
                    "time": "12/07/2019-08:40:16",
                    "content": "I\u2019ve started a new topic for last call. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.340909090909091
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "152",
                    "likes": "0",
                    "time": "12/07/2019-08:44:35",
                    "content": "I\u2019ve started a new topic for last call. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.340909090909091
                }
            ]
        }
    ],
    "group_index": "717"
}