{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/create-a-new-opcode-for-counting-leading-zeros-clz/10805",
            "title": "Create a new opcode for counting leading zeros (CLZ) ",
            "index": 10805,
            "category": [
                "EIPs"
            ],
            "tags": [
                "opcodes"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/Vectorized",
                    "index": "1",
                    "likes": "2",
                    "time": "11/09/2022-02:50:57",
                    "content": "Count leading zeros (CLZ) is a native instruction in many processor architectures (even in RISC architectures like ARM). It is a basic building block used in many important fixed point and binary operations:  lnWad powWad (due to lnWad) sqrt log2 most significant bit (msb) least significant bit (lsb) (can be easily implemented with CLZ by isolating the smallest bit via x & -x)  Code examples:  solady/FixedPointMathLib.sol at main \u00b7 Vectorized/solady \u00b7 GitHub solady/LibBit.sol at main \u00b7 Vectorized/solady \u00b7 GitHub  For more applications see: Find first set - Wikipedia Emulating this opcode is very wasteful in terms of runtime gas and bytecode size (due to the need to store large constants like 0xffffffffffffffffffffffffffffffff or De Bruijn lookups like 0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f). Given that most processors have this opcode implemented natively, which can be used to efficiently implement the opcode in EVM, it feels even more wasteful not to have it available in the EVM. Having this opcode in the EVM will enable cheaper runtime gas, cheaper validator computation, and smaller bytecode.  For the implementation of CLZ, I\u2019d propose a gas cost of 3 (to keep in line with the gas cost of shl, shr, not, xor, etc). This CLZ opcode will take in a single variable on the stack, and output a single variable onto the stack. For the case of 0 as the input, CLZ returns 256 (the bit width of the input) to stay consistent with how it behaves in most processors, and for lesser bytecode required to handle the output.  CLZ has the following advantages over other bit counting operations:   log2(x) can be computed via 255 - clz(x), which automatically reverts for the case of 0 if using checked arithmetic. This makes it preferred over find first set (FFS).   Count trailing zeros (CTZ) is way cheaper to emulate with current Yul opcodes compared to CLZ. See the LibBit.sol. Inclusion of CLZ will make CTZ easy to compute, but not vice versa.   Basically, CLZ is the most common bit counting operation in processors because other bit counting operations can be easily implemented with CLZ. ",
                    "links": [
                        "https://github.com/Vectorized/solady/blob/main/src/utils/LibBit.sol",
                        "https://en.wikipedia.org/wiki/Find_first_set#Applications",
                        "https://ethereum-magicians.org/t/gather-for-an-eip-useful-bit-manipulation-instructions/9751/4",
                        "https://ethereum-magicians.org/t/gather-for-an-eip-useful-bit-manipulation-instructions/9751/6"
                    ],
                    "GPT-summary": "The author proposes to create a new opcode for counting leading zeros (CLZ) in the EVM, which is a basic building block used in many important fixed point and binary operations. The author argues that having this opcode in the EVM will enable cheaper runtime gas, cheaper validator computation, and smaller bytecode. The author proposes a gas cost of 3 for the implementation of CLZ and explains its advantages over other bit counting operations. A 3rd party could ask questions about the proposal or give constructive criticism.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Interoperability and Scalability",
                        "None",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.992043992043992
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "2",
                    "likes": "0",
                    "time": "11/11/2022-17:57:16",
                    "content": "Can you leave an example of an efficient ctz implementation using clz?     Vectorized:  log2(x) can be computed via 255 - clz(x), which automatically reverts for the case of 0 if using checked arithmetic. This makes it preferred over find first set (FFS).   Well, not automatically, but with code generated by the compiler  Would you be able to rewrite the solady code using the hypothetical clz opcode? It would be a good way to see the complexity reduction. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 7.416666666666667
                }
            ]
        }
    ],
    "group_index": "114"
}