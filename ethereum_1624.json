{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/framework-library-standard/8432",
            "title": "Framework Library Standard ",
            "index": 8432,
            "category": [
                "Tooling"
            ],
            "tags": [
                "NONE"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/vigilance",
                    "index": "1",
                    "likes": "0",
                    "time": "26/02/2022-07:00:23",
                    "content": "           eip    title Framework Library Standard   author Tyler R. Drury vigilstudios.td@gmail.com (www.twitter.com/StudiosVigil)   discussions-to    status Idea   type Standards Track   category ERC   created 2022-02-26   requires (*optional) EIP-165      Table of Contents  Abstract Motivation Terms Specification Benefits Implementation Rationale Security Considerations References Copyright Citation    Abstract Frameworks are libraries which only encapsulate the internal or private constants of the framework and the functions associated with some standard interface implementation, to be executed on an arbitrary address which may provide support for standard run-time interface detection. Framework functions must either accept an address as their first argument or otherwise implicitly operates on the calling contract context or both, then executes transactions on the external contract\u2019s address as defined by a some standard interface. All ERC standard interfaces could natively support an accompanying framework in order to allow for the implementation of a standardized approach to external contract calls. Additionally, such a fundamental abstraction, if proven useful, could have a convenient, native keyword (like library, interface or contract) added to future compiler versions, so as to make the process of declaring, writing or using frameworks more convenient, intuitive and explicit, along with providing compiler enforced behavior on frameworks as specified by this proposal.   Motivation Currently, there are two primary methods for executing external calls on contracts. The first approach: Use low level operations to execute functions on the contract address, such as .call, .staticall and .delegatecall. While this approach grants immense flexability, there is usually a high barrier of entry to new developers unfamiliar with such operations since it also requires repeated calls to low level functions such as to abi.encode or abi.encodeWithSignature, often preceeded by executing some introspection function to ensure the contract supports the desired function. As with all low level coding, this ultimately becomes cumbersome quickly and leads to unnecessary code bloat and code repetition, especially in circumstances where functions which do not accept arguments (such as getter/read-only functions) can precompute their encoded function signature and cached after calling abi.encodeWithSignature, since they accept no arguments, the encoded function signature is guaranteed to remain the same indefinitely, thus making repeated calls to the same function needlessly call abi.encodeWithSignature each time the function is executed, causing unnecessary gas consumption on repeated calls. The second approach: Declare a contract or interface, then cast the target external contract address to the appropriate type. This instance can then execute the functions of that interface or contract, however there is no guarentee the casted address is in fact a contract of the desired type or supports the intended functions. This can lead to issues, such as attempting to execute code on a wallet address, instead of a contract address. Additionally, the concept of instantiating an Interface (while currently supported by the EVM), is not intuitive from the perspective of those with back ground in similar languages. Interfaces should only declare the external ABI of a contract, to be explicitly overridden in derived contracts and should not be instansiatable, as is commonplace with almost all other languages which implement such an abstraction and is ubiquitous with how the concept of interfaces are generally perceived as being a means to declare a related set of functions to be overridden by the implementer of an interface. This interpretation is further supported by a related construct to interfaces, the Abstract Base Contract (or ABC). In Soliditiy, while ABCs can not be instansiated/deployed, interfaces can, contrary to standard coding practices in other languages. As such frameworks are a convenient abstraction which unifies both approaches, while also adding flexibility, reusability and composibility while also reducing complexity by providing a standardized approach where the end-user is not concerned about the underlying low-level implementation, since frameworks facilitate the exact same calls to an external contract as if it were a fully realized instance of an interface.   Terms The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.           function A named collection of opcodes which can be executed by a smart contract which may accept a list of arguments.   interface defines a collection of related external functions a smart contract supports.   library Similar to Contracts but generally contains functions which other contracts utilize, intended for reusability. Unlike Contracts, Libraries do not have their own storage and thus cannot have state variables, nor can they inherit nor be inherited from.   framework library with functions which either exclusively accept an address as its first argument or implicitly operate on the calling contract context or both then executes functions on the external contract\u2019s address which may support a standard interface      Specification Leveraging the native language level mechanics of libraries, frameworks allow adding utility for various interfaces natively to generic addresses, allowing convenient access to interface functions as if a raw address were an instance of the interface without casting it to an instance of that interface, while offering the potential for built-in support for run-time interface introspection as well. Since a framework is merely a library which accepts as its first argument a contract\u2019s address, An arbitrary number of frameworks may be attached to the native address type with the using framework... for address; statement within an implementing contract. If a framework function instead does not accept an address as its first argument, it must implicitly operate on the calling contract context, which the associated function should be accessed via dot (.) notation through the framework name without relying on a using statement. contract ERC20Token is iERC20 {     using frameworkERC173 for address;     using frameworkERC20 for address;          address _target;          constructor(address target){         _target = target;     }     function example()external     {         //call to .owner() automatically performs ERC-165's `supportsInterface` check for ERC-173 on target before attempting execution         //reverting state if the address is either target is not a contract or does not support the desired interface         require(address(this) == _target.owner(), \"this contract does not own target contract\");         //         _target.renounceOwnership();         _target = address(0);     }     ///caller approves this contract to transfer `swappedTokenAmount`     function targetTokenApprove(         uint256 swappedTokenAmount     )external     {         approve(msg.sender, swapTokenAmount);     }     /// @dev swap this ERC20 token for target's ERC20 token     function swap(         uint256 thisTokenAmount     )external     {         require(_target.owner() != address(0), \"Target contract is null\");         require(_target.owner() == address(this), \"This contract does not own target\");         //         // todo: get price feed for token pair from oracle to verify price of exchange is at fair market value         uint256 swapTokenAmount = poolPriceRouter.getConversionrate(symbol(), _target.symbol(), thisTokenAmount);         //         require(_target.balanceOf(address(this) >= swapTokenAmount);         require(allowance(msg.sender, address(this)) >= thisTokenAmount);         //this contract transfers `thisTokenAmount` from this contract to caller performing the swap         transferFrom(msg.sender, address(this), thisTokenAmount);         //if approved, this contract transfers `swapTokenAmount` from msg.sender to this contract         //reverts if address is not a contract or does not support ERC-20         _target.transfer(msg.sender, swapTokenAmount);     } }    Benefits By leveraging the using statement (where \u2026 could be any EIP standard as necessary): using framework... for address;`  a framework\u2019s implementation can be attached to an arbitrary address while the nature of libraries preserving the calling context of the executing contract and is guaranteed to perform all appropriate introspection to ensure the address supports such execution, otherwise state is reverted and the transaction fails with no side-effects. Additionally, this technique provides the benefit of reducing the executing contract\u2019s bytecode, leading to vast gains in terms of allowable contract functionality, as enforced by the bytecode size of 24kb in the Spurious Dragon hard fork. This approach also reduces or eliminates the need (and associated gas fees) of both:  casting and instansiating an address as an interface/contract instance having to call abi.encodeWithSignature repeatedly when executing multiple low-level calls to interface functions which do not accept any arguments  since the framework\u2019s implementation would be attached to the address data type at compile time. This technique also allows for significantly less complex and straightforward contract code, since the framework allows an arbitrary external address to be used within another contract as if the framework\u2019s target address were a fully instansiated contract. With the above example, the swap function only occupies 4 lines of code, is simple to read, understand or modify. Explicitly casting the address to a contract or interface type, not only requires extra operations but is made unnecessary with the more convenient syntax of the using statement: using framework... for address;  approach of frameworks in this proposal and is much more concise. Where as, if the approach of explicitly using low-level .call methods were used, the swap function would be almost twice as bloated, thus consume more gas while also requiring additional calls to check if the address is a contract, multiple calls to abi.encodeWithSignature and explicit calls to ERC-165 before other type checking operations occur for the desired interface. Not only is the framework approach much more versatile and succinct than either of these alternative approaches, this techniques also leaves an almost negligible byte-code foot print for each call.   Implementation Currently frameworks must be implemented as libraries, with internal or private function which should accept a contract address as their first argument or implicitly operate on the calling contract context or both. An example framework for ERC-165 might look similar this example: // SPDX-License-Identifier: Apache-2.0  pragma solidity >=0.6.4 <0.8.0;  import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.3.0/contracts/utils/Address.sol\"; import \"https://github.com/vigilance91/solidarity/libraries/address/addressConstraints.sol\";  import \"https://github.com/vigilance91/solidarity/ERC/ERC165/iERC165.sol\"; /// /// @title Framework for ERC-165 Interface Support Introspection Library /// @author Tyler R. Drury <vigilstudios.td@gmail.com> (www.twitter.com/StudiosVigil) - copyright 5/4/2021, All Rights Reserved /// library frameworkERC165 {     using logicConstraints for bool;     using addressConstraints for address;     using Address for address;          bytes4 internal constant _INTERFACE_ID = type(iERC165).interfaceId;     string internal constant SUPPORTS_INTERFACE_STUB = 'supportsInterface(bytes4)';     ///     ///read-only interface     ///     ///does target support ERC-165     function supportsInterface(         address target     )internal view returns(         bool ret     ){         target.requireNotNull();         target.isContract().requireTrue(             \"ERC-165: target is not contract\"         );         // ERC-165 requires supportInterface calls to consume no more than 60,000 gas         (bool result, bytes memory data) = target.staticcall{gas: 60000}(             abi.encodeWithSignature(                 SUPPORTS_INTERFACE_STUB,                 _INTERFACE_ID             )         );         result.requireTrue('call failed');                  (ret) = abi.decode(data, (bool));     }     ///does target support ERC-165 AND the interface specified by interfaceId     function supportsInterface(         address target,         bytes4 interfaceId     )internal view returns(         bool ret     ){           supportsInterface(target).requireTrue(             \"ERC-165: not supported\"         );                  (bool result, bytes memory data) = target.staticcall{gas: 60000}(             abi.encodeWithSignature(                 SUPPORTS_INTERFACE_STUB,                 interfaceId             )         );         result.requireTrue(             '\"ERC-165: external call failed'         );                  (ret) = abi.decode(data, (bool));     }     function requireSupportsInterface(         address target     )internal view     {         supportsInterface(target).requireTrue(             \"ERC-165: interface not supported\"         );     }     function requireSupportsInterface(         address target,         bytes4 interfaceId     )internal view     {         supportsInterface(             target,             interfaceId         ).requireTrue(             \"ERC-165: interface not supported\"         );     }     function requireNotSupportsInterface(         address target     )internal view     {         supportsInterface(target).requireFalse(             \"ERC-165: target supports interface\"         );     }     function requireNotSupportsInterface(         address target,         bytes4 interfaceId     )internal view     {         supportsInterface(             target,             interfaceId         ).requireFalse(             \"target supports interface\"         );     } }  Additionally, it may be convenient in future EIPs, should this technique show large adoption, to include a framework keyword in future compiler versions, to abstract much of these idioms into compiler-defined and enforced behavior, so as to differentiate between the use and purpose of traditional libraries such that frameworks:   Must support only private variables for that specific framework. Functions must only be either internal or private. Functions must accept an address as its first argument or implicitly operate on the calling contract context or both.    Rationale Abstracting the concept of executing low-level operations on external contracts into a single cohesive coding standard (or even built-in primitive type) would greatly enhance not only development of smart contracts but also easy the barrier of entry to new comers who do not yet fully grasp the more subtle low-level operations of the EVM, while allowing the the power and flexibility such techniques provide without the need for intimate knowledge of such semantics. With frameworks, new developers only needs to be familiar with how libraries operate in order to take advantage of this powerful proposal.   Security Considerations The only obvious concerns are those common to executing external functions of contracts which can\u2019t be trusted, such as the underlying EIP the framework is built on or selector clashing concerns, as is the case with any approach to implementing external contract calls. In this regard, a malicious contract could define a function which matches a specific framework selector to an interface function, providing a malicious implementation which has nothing to do with the intended operation. These concern can be alleviated by:  Ensuring the Context contract and the Target contract are never the same address. Ensuring view/pure getter framework function calls use .staticcall to ensure state immutability in both Context and Target do not modify the executing call context. Ensuring care is taken that mutable function should only modify the Target contract being called and not the calling Context, since the intention of framework functions is to operate on the Target contract, which should never modify the calling Context contract. Ensure all modifications to the calling Context state occur entirely with itself and never as the result of a framework call to a target. .delegatecall must never be used to implement framework functions since, any potential malicious code should only affect the executing target contract (not the Context contract), so long as the Context contract implements a ReentrancyGuard (or a similar technique), this should prevent any potential of the target contract attempting to call back into the Context contract maliciously.    References  EIP-165: Standard Interface Detection EIP-897: Delegate Proxy EIP-1967: Proxy Storage Slots EIP-1613: Gas Station Network    Copyright Copyright and related rights waived via CC0.   Citation Tyler R. Drury, \u201cEIP-TBD: Framework Library Standard [DRAFT]\u201d, Ethereum Improvement Proposals, no TBD, February 2022. [Online serial]. ",
                    "links": [],
                    "GPT-summary": null,
                    "GPT-proposal-categories": null,
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.14145703197901
                }
            ]
        },
        {
            "thread_link": "https://ethereum-magicians.org/t/mixin-library-standard/8434",
            "title": "Mixin Library Standard ",
            "index": 8434,
            "category": [
                "Tooling"
            ],
            "tags": [
                "NONE"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/vigilance",
                    "index": "1",
                    "likes": "0",
                    "time": "26/02/2022-07:43:34",
                    "content": "           eip    title Mixin Library Standard   author Tyler R. Drury vigilstudios.td@gmail.com (www.twitter.com/StudiosVigil)   discussions-to    status Idea   type Standards Track   category ERC   created 2022-02-26   requires (*optional) EIP-165      Table of Contents  Summary Motivation Terms Specification Benefits Implementation Rationale Security Considerations References Copyright   Citation    Summary This proposal allows for a standardized approach when implementing the common eternal/external storage slot pattern in libraries and contracts. Mixins are libraries that are atomic units which are composable with other mixins and encapsulate the internal state variables and associated logic of a single, concrete, concept, providing internal constants and internal or private functions, which may be (typically) be associated with some structured data storage. Mixin libraries support internal functions to be called by an implementing contract and private constants, functions or modifiers for internal use. Mixins result in a library\u2019s bytecode being inlined to all call sites within the callin Context contract which, by the transitive property of inheriting the inlined byte-code, effectively makes the Context \u2018inherit\u2019 the internal data structure and logic provided by the mixin, without the additional overhead associated with external library calls. It is convenient to reuse and compose various mixins, since they load unique storage slots specific within the Context of an individual implementing contract, and since they are atomic structures with all necessary operations provided for that data type, functionality of contracts can not only be simplified by breaking them down into atomic components, but also allows for greater flexibility and reusibity, since multiple differing contracts can implement the same Mixin, or a single contract can utilize any number of additional storage slots while reusing the same library code. For example, the ERC-20 token and EIP-1753 License standard both implement a name function which returns a string, a single Mixin can be declared which loads a contract\u2019s storage slot with the desired structure and provides the appropriate getters and setters for the data as necessary. This technique allows both ERC-20 and EIP-1753 implementations to utilize the exact same code in both contracts, without the unnecessary duplication of code by developers (although during compilation, the inlined internal functions will be injected into the contract directly at all call sites), while each individual contract manages its own unique storage slot. Another example would be the ERC-721 and ERC-1155 metadata uri functions. Both contracts could easily adopt the same Mixin providing functionality, while also expanding on that functionality as required by each unique contract, usually by implementing multiple other related Mixins as desired. This technique also provides the distinct advantage that the Mixin\u2019s storage utilized by the implementing Context contract is not contained within the contract itself (but rather is stored in an external, constant storage slot location, for each unique contract), thus dramatically reducing contract code size to be effectively only that of the compiled contract\u2019s functions, by eliminating local internal contract storage within a contract. This approach effectively allows an unlimited amount of data storage within a single contract, irrespective of contract bytecode size limit imposed by the Spurious Dragon hard fork, without actually violating it, since none of the storage space is contained within the contract, none of the data contributes to the implementing contract\u2019s bytecode size, similar to how public libraries reduce code size by internally delegating calls to a separately deployed, public library. This effectively reduces all contracts to only the size of their function\u2019s bytecode, allowing for larger, more robust contracts, while also being incredibly small and gas efficient, with minimal overhead, while also making the implementing contracts much more easy to read and manage.   Motivation Currently, the Spurious Dragon hard fork enforces a maximum contract bytecode size of ~24kb. This limit effectively means that contracts significantly larger or more complex than a standard ERC-20 token hit this limit quickly during development. This has lead to several interesting approaches to address the size limit, such as Proxies and Diamonds. This proposal is based on EIP-2535 standard, providing a much more detailed standard for diamond storage specifically, for implementations of such a storage technique for general purpose use, beyond just Diamonds or Proxies. When it comes to the need to reuse contract code and data contracts often inherit from other contracts, however, this technique causes the inherited code to be directly injected into the derived contract, meaning the larger a contract is, the larger its children\u2019s bytecode will also be also. Mixins are libraries and thus, can not be instanstiated/deployed or inherited from, instead they define atomic operations on specific data structures, which can be called by an implementing contract context. These structures and their functions can then be used in a contract (being inlined directly in the contracts), providing the data and functionality to the implementing contract as if it directly contained the data and functions, while minimally affecting overall bytecode size, providing the same functionality as inheritance but, with far higher benefits of both more complex and more efficient contracts, due to the reduced bytecode size since no data and minimal code exists within the deployed smart contract itself.   Specification Since a Mixin is an internal library which operates on its own storage slot(s) by default, often Mixins don\u2019t require a using ... for bytes32; statement in their implementing contracts, since all operations are executed directly through the Mixin, implementing contracts access functions through the Mixin directly as defined by the library. Alternatively, if a Mixin supports using non-default storage slots, due to the nature of libraries the libraries functionality can be attached to a storage slot with a using ... for bytes32; statement is the implementing contract. An arbitrary number of Mixins may be implemented by any contract through its library functions, so care must be taken to avoid clashing of function selectors. Conversely a single contract may only implement a single version of any one Mixin for a specific storage slot, since multiple calls to the same Mixin\u2019s storage slot from within the same contract map to the same place in storage.   Terms The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.           bytecode The compiled EVM compatible binary representing a smart contract\u2019s executable code to deployed on the blockchain at the contract\u2019s address.   struct A single data type representing a collection of other related data types.   library Similar to Contracts but generally contains functions which other contracts utilize, intended for reusability. Unlike Contracts, Libraries do not have their own storage and thus cannot have state variables, nor can they inherit nor be inherited from.   mixin A Library which generally accepts a storage slot as the first argument, which provides functionality for accessing and manipulating a structured data at a storage slot location.   storage slot A unique bytes32 identifier for a storage location within a contract      Benefits By leveraging the using ... for bytes32 statement, a mixin\u2019s implementation can be attached to an arbitrary storage slot, allowing for great reuse and flexibility. By moving variable storage out of the contract and into external storage slots, this technique provides the benefit of reducing the executing contract\u2019s bytecode, leading to vast gains in terms of allowable contract functionality, as enforced in the Spurious Dragon hard fork. This technique also allows for much more simple and straightforward contract code which is highly versatile.   Implementation Mixins must be libraries which adhere to the following axioms:  All constants must either be private or internal All functions must either be declared as either internal or private   Must declare or operate on at least one unique storage slot identifier, represented as a bytes32 hash At least one pure function (either private or internal) which loads a data structure from the location of a unique storage slot, to be accessed or manipulated as defined by its interface by an implementing contract.  May declare one or more data structures and associated operations for accessing or mutating that structured data  May declare modifiers for use with its other functions  A trivial example Mixin implementation for the ERC-173 Contract Ownership Standard: // SPDX-License-Identifier: Apache-2.0  pragma solidity >=0.6.4 <0.8.0; pragma experimental ABIEncoderV2;  import \"https://github.com/vigilance91/solidarity/libraries/address/addressConstraints.sol\"; import \"https://github.com/vigilance91/solidarity/ERC/ERC173/eventsERC173.sol\"; /// /// @title ERC173 Mixin Library /// @author Tyler R. Drury <vigilstudios.td@gmail.com> (www.twitter.com/StudiosVigil) - copyright 2/4/2021, All Rights Reserved /// library mixinERC173 {     using addressConstraints for address;     using eventsERC173 for address;          struct ERC173Storage {         address owner;     }          bytes32 internal constant STORAGE_SLOT = keccak256(\"ERC-173.mixin.storage\");          function storageERC173(         bytes32 slot     )internal pure returns(         ERC173Storage storage ret     ){         bytes32 position = slot;                  assembly {             ret_slot := position         }     }     ///     ///read-only interface     ///     function owner(         bytes32 slot     )internal view returns(         address     ){         return storageERC173(slot).owner;     }          function requireOwner(         bytes32 slot,         address sender     )internal view     {         address O = owner(slot);                  O.requireNotNull(             \"owner can not be NULL\"         );         O.requireEqual(             sender             \"caller not owner\"         );     }     ///     ///mutable interface     ///     function transferOwnership(         bytes32 slot,         address newOwner     )internal     {         addres owner O = owner(slot);                  O.requireNotEqual(newOwner);         O.emitTransferOwnership(newOwner);                  storageERC173(slot).owner = newOwner;     }     function renounceOwnership(         bytes32 slot     )internal     {         transferOwnership(             slot,             addressLogic.NULL         );     } }  Additionally, it may be convenient in future EIPs, should this technique show large adoption, to include a mixin keyword in future compiler versions, to abstract these axioms into compiler-defined and enforced behavior, in order to eliminate human error and so as to differentiate between the use and purpose of traditional libraries in contrast to external storage Mixins, such that:  Constants should only be private or internal, to prevent deploying a public library. Functions should only be private or internal, so as to allow for the inlining of the internal code for loading the storage structure from the specific storage slot, within the context of the implementing contract (this technique does not work properly with public library functions). At least one data structure may be defined along with an associated, default storage slot, which the compiler could generate in future versions by default based on the name of the Mixin library which could be accessible using standard EVM type() introspection. Code for loading a data structure from a storage slot (which is trivial assembly similar to a compiler generated default constructor) could easily be automatically generated by the complier in future version, along with the corresponding automatically generated storage slot identifier, similar to how contracts may have auto-generated default constructors, if one is not explicitly declared.    Rationale With the byte-code limit for the Spurious Dragon hard-fork of 24Kb is incredibly limiting, utilizing external storage slots in a standardized manner via mixins is not only convenient but incredibly powerful and flexible, allowing for more complex contracts without imposing massive restrictions on contract size. This proposal also allows for the distinction between internal library code which defines the mixin\u2019s functionality on a specific type or storage slot and the implementing contract which should utilize the mixin\u2019s functionality while also being responsible for managing state logic associated with external callers of a public interface, providing a clean distinction between these two approaches and what constructs have responsibility for what functionality. Additionally having a single, reusable Mixin library allows for greater flexibility as a developer by easily allowing code reuse in multiple contracts which implement the same structures or logic without having to duplicate code or the associated bytecode bloat of declaring contract variables.   Security Considerations There are no immediate security concerns regarding Mixins (since they are abstractions for atomic data structures) beyond any concerns specific to a particular standard implementation however, as this technique further develops there is a possibility this proposal may have unforeseen security issues. Since each individual Mixin (with a unique storage slot) loads its data structure within the Context of an implementing contract, multiple contracts which implement the same Mixin do not conflict, conversely, accessing the same Mixin internally from a derived Context contract will load the same storage as if called from the base contract. Similar to the Black Diamond pattern in languages which support multiple inheritance, if a single contract that inherits from multiple various base contracts but which also happen to implement the same Mixin utilizing the same storage slot the potential exists for conflict and unintentionally overwrite storage intended for use by the other Mixin. Since the contracts don\u2019t have the variables declared locally, the compiler will most likely not generate any warning that multiple contracts are modifying the same storage location. The simple solution to this concern is to just use a unique storage slot for each derived implementation when it is unavoidable to have a contract inherit from two or more contracts which implement the same Mixin. Another concern is that there may be storage conflicts between Proxies and their implementations if the layout of a storage slot is updated or slot locations between the two differ. There are currently no other major issues regarding the use of Mixins.   References  ERC-165: Interface Support EIP-897 Delegate Proxy EIP-2470: Singleton Factory EIP-2535: Diamonds EIP-1613: Gas Station Network    Copyright Copyright and related rights waived via CC0.   Citation Tyler R. Drury, \u201cEIP-XXX: Mixin Library Standard [DRAFT]\u201d, Ethereum Improvement Proposals, no XXX, February 2022. [Online serial]. ",
                    "links": [],
                    "GPT-summary": null,
                    "GPT-proposal-categories": null,
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.334009888108248
                }
            ]
        }
    ],
    "group_index": "1624"
}