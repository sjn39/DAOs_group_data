{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-draft-multi-chain-governance/9284",
            "title": "EIP Draft: Multi-chain Governance ",
            "index": 9284,
            "category": [
                "Governance"
            ],
            "tags": [
                "governance",
                "chain-agnostic"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "1",
                    "likes": "10",
                    "time": "17/05/2022-16:58:36",
                    "content": " EIP Draft: Mult-chain Governance This EIP aims to standardize a multi-chain governance system. The specification iterates on the original Compound Governor by separating proposal execution from consensus.  EIP Draft is available here Reference implementation   Background Many projects in the space have benefitted from the excellent Compound governance system; whether by using the original contracts, forks, or the compatible OpenZeppelin Governor. Thanks to this inadvertent standardization, we\u2019ve seen impressive projects like Tally that were able to build governance aggregators. Standardization allowed Tally to put their efforts into a deeper feature set rather than integration details. The next step for many protocols is to go multi-chain.  At the moment this means having a multi-sig act in accordance with a Snapshot vote. While this works, there is no recourse if the multi-sig goes rogue or dormant. We need multi-chain token signalling. By combining our efforts we can create a multi-chain governance standard that elevates the entire ecosystem, and allows us to leverage common infrastructure.  Rationale The above implementation is the best next step for PoolTogether. We have token holders on multiple chains, and we have contracts on multiple chains. We need:  To allow voting on every chain we are deployed to To support state changes on every chain we are deployed to  Additionally, our existing governance system is a fork of the Compound Governor on Ethereum. Our solution must include a migration path for the legacy governance system. I believe our best bet is to iterate on the Compound Governor to support multiple chains.  Call to Action My goal is to find others in the community with similar issues, and develop a standard that we can all move forward with. I\u2019m sure that there are others that need multi-chain governance. Having a common effort will allow all of us to safely and rapidly expand to new chains. I\u2019ve written a draft EIP and implementation, but the specification is a community effort. I want to hear any and all feedback! In particular:  Who else wants multi-chain governance? Is the spec unclear? How can the spec be improved? Is there more we should add? Less?  Have a read and let\u2019s start the conversation! ",
                    "links": [
                        "https://github.com/pooltogether/multichain-gov-contracts"
                    ],
                    "GPT-summary": "The author of the post is proposing a multi-chain governance system and is seeking feedback from the community. The proposal aims to standardize a multi-chain governance system and create a multi-chain governance standard that elevates the entire ecosystem. The author is asking for feedback on the proposal and is looking for others in the community with similar issues to collaborate on the proposal.",
                    "GPT-proposal-categories": null,
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "3rd party or author wants to collaborate on proposal",
                        "None"
                    ],
                    "Sentiment": 6.319159335288367
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/auryn",
                    "index": "2",
                    "likes": "4",
                    "time": "18/05/2022-12:47:03",
                    "content": "    Brendan:   Who else wants multi-chain governance?    Me me me! We, Gnosis/GnosisGuild, have been working on several version of this for a while as part of Zodiac. We see Multichain organizations as one of the really awesome things that Zodiac unlocks with the pattern of decoupling account and control logic. We have a few different iterations of this, solving for slightly different but related of problems in various ways. Starting with our Reality module coupled with SafeSnap and  multichain strategies on Snapshot, followed by our Bridge Module, and our as-of-yet-unannounced Gnomad module.     Brendan:   How can the spec be improved?    I see four distinct problems:  How to govern assets on multiple chains? How to account for votes held on different chains? How to make voting cost effective? How to account for votes held in different systems (AMMs, vesting contracts, staking, etc)?  The spec and solution you describe solves nicely for 1-3, assuming there is an acceptable bridge between root an branch. But, as with the current implementations Governor (and, indeed, all on-chain voting that I\u2019m aware of) it does not solve for 4. Meaning that, if vote weight is defined by a liquid token, there is always an opportunity cost for users to hold vote weight compared with using the token productively (often in ways that would be beneficial to the ecosystem, like providing liquidity to an AMM). To solve for 4, GnosisDAO makes use of our Reality module coupled with SafeSnap and multichain strategies on Snapshot, that leverage subgraphs to account for GNO held in many different places (GNO, LGNO, MGNO, SGNO, and GNO held in Uni V2 and V3, and Balancer V1 and V2 on mainnet and Gnosis Chain). Oracle-based-governance like this setup seems like the only viable way to account for this kind of ever-changing range of places that you might want to account for vote weight. If accounting for votes in more places that just the voters\u2019 wallets is a priority, then I\u2019d suggest that the spec should leverage some oracle-based governance mechanism. If not, then I think the current spec looks great.     Brendan:   Is there more we should add? Less?    IAvatar The spec states  This system is can be easily adapted to support the original Compound Governor Timelock contract, which protocols to swap out the old Governor Alpha for this spec.  However I think it would be more flexible and composable if it were built to support IAvatar from Zodiac. Essentially, replacing the timelock with a Gnosis Safe (or some other programmable account that exposes the same interface). You could achieve similar functionality to Timelock by leveraging the Delay modifier, without restricting the DAO\u2019s future flexibility. At the very least, I\u2019d encourage DAO\u2019s to use their timelocks to control a safe that holds their assets and controls their systems, rather than having the timelock do that directly. ",
                    "links": [
                        "https://github.com/gnosis/zodiac-module-reality",
                        "https://github.com/gnosis/zodiac-module-bridge",
                        "https://github.com/gnosis/zodiac-module-gnomad/",
                        "https://github.com/gnosis/zodiac-module-reality",
                        "https://github.com/gnosis/zodiac/blob/master/contracts/interfaces/IAvatar.sol",
                        "https://github.com/gnosis/zodiac-modifier-delay"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.964957264957265
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "3",
                    "likes": "1",
                    "time": "18/05/2022-19:04:57",
                    "content": "Hey Auryn! Appreciate your input here. You\u2019ve raised some good points.     auryn:   How to account for votes held in different systems (AMMs, vesting contracts, staking, etc)?    I 100% agree here. We have the same problem with our DAO, in that people stake their POOL tokens but lose the voting power. We\u2019ve \u201csolved\u201d it by adding all of the derivatives that map 1:1 with POOL to the Snapshot vote. It\u2019s pretty hacky, but the bandaid is holding for now. It\u2019s just signalling to a multisig to vote accordingly with delegated voting power. We need to incorporate Zodiac here  Ideally, the spec is minimal enough to allow implementations to measure voting power in their own way. Rather than try to solve the problem of multiple voting tokens, as you described, we could instead make space for people to develop the right solution for them.  More Modular Voting Ideally, the spec is minimal enough to allow for different implementations to measure voting power in their own way. Voting can be measured in so many different ways:  a staking contract that combines multiple token balances a veCurve-style lockup token COMP-like tokens that use block numbers  Among many others. COMP-like tokens are particularly interesting: users for many projects on Ethereum have already delegated their voting power. We don\u2019t want them to have to delegate again, so ideally the solution supports these tokens. Really, the voting interface just answers the abstract question: how much voting power does this user have for this proposal. This question can be answered in many different ways. Right now the spec has the voting module use the start epoch to measure voting power.  However, to answer the above question properly the module needs the complete proposal info. I\u2019m thinking the Epoch Voter could be less prescriptive, and instead be abstracted as a mechanism that just returns a users voting power for a proposal: Instead of: interface EpochVoter {     function votesAtEpoch(address _account, uint32 _epoch) external view returns (uint112); }  We\u2019d have: interface Votes {     function getVotes(address _account, bytes32 proposalHash, uint32 startEpoch, uint64 endTimestamp, bytes calldata branchData, bytes calldata rootData) external view returns (uint112); }  The branchData blob and the rootData blob could be additional blobs of data that are \u201cnotarized\u201d as part of the proposal hash. This would allow implementations to include additional data, such as block numbers, so that votes can be computed properly.  Execution     auryn:  However I think it would be more flexible and composable if it were built to support IAvatar from Zodiac.   This is interesting; do you mean the Governor Branch would implement the IAvatar interface? Or that it would know how to speak to one? Either way, I think implementations could tackle execution in different ways. Some may queue the list of calls in a Timelock, others may queue them in a Gnosis Safe. Ideally, the spec is minimal enough that users can tackle this in their own way. Where the spec does need to support different implementation is in the Call struct. Each proposal has an array of calls, each of which is: struct Call {     uint256 chainId;     address caller;     address target;     uint256 value;     bytes data; }  The chainId and caller identify who should start the call, and the target, value and data identify who should be called. Looking at the IAvator interface, it seems it additionally can have a \u201cdelegation\u201d flag to denote whether to do a delegate call or a regular call. I wonder if we should add this to the Call struct so that it\u2019s fully compatible with IAvator-style execution? Like a delegateCall flag or something. What do you think? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.185347011144884
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/auryn",
                    "index": "4",
                    "likes": "1",
                    "time": "18/05/2022-23:41:10",
                    "content": "    Brendan:  wonder if we should add this to the Call struct so that it\u2019s fully compatible with IAvator-style execution? Like a delegateCall flag or something. What do you think?   Yeah, I think adding this flag would be useful.     Brendan:  Or that it would know how to speak to one?   Ideally that it would know how to speak to IAvatar. Essentially, when it attempts to execute a transaction, it should call execTransactionFromModule() or execTransactionFromModuleReturnData(). This might be to opinionated for the spec and something that is defined in specific implementations. However, the point of Zodiac is to standardize this interface so that we can make all for this rolling easily composable. So building this standard on top of Zodiac could certainly help encourage that.     Brendan:  We\u2019ve \u201csolved\u201d it by adding all of the derivatives that map 1:1 with POOL to the Snapshot vote. It\u2019s pretty hacky, but the bandaid is holding for now. It\u2019s just signalling to a multisig to vote accordingly with delegated voting power. We need to incorporate Zodiac here    Yeah, this is why I tend to think that oracle-based governance is likely to win out. It\u2019s just not viable to track all of these different places POOL might live in an on-chain voting contract. Especially when you factor in multiple chains. I do think that on-chain governance is still well suited to situations where vote weight is illiquid, consumptive, or very strictly defined. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.166869588744589
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "5",
                    "likes": "0",
                    "time": "19/05/2022-16:27:54",
                    "content": "    auryn:  Yeah, this is why I tend to think that oracle-based governance is likely to win out.   One of the reasons I\u2019m excited about the root & branch approach is that it affords us the ability to integrate new voting strategies in the future. While the voting strategy may change, the need to coordinate state updates across chains will remain. I see this current effort as being the next logical step for us. It won\u2019t be the last, however. This EIP must allow for continued evolution! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.867424242424243
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/auryn",
                    "index": "6",
                    "likes": "0",
                    "time": "20/05/2022-06:08:16",
                    "content": "Have you seen Usul, btw? cc @nginnever Seems like there are a lot of similar design goals.    GitHub    GitHub - SekerDAO/Usul Contribute to SekerDAO/Usul development by creating an account on GitHub.      ",
                    "links": [
                        "https://github.com/SekerDAO/Usul"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nginnever",
                    "index": "7",
                    "likes": "2",
                    "time": "20/05/2022-19:25:05",
                    "content": "Thanks for tagging me @auryn!! @Brendan great work, it\u2019s cool to see such a similar protocol to the one I developed. Usul aims for the same targets. Rather than an \u201cEpochVoter\u201d connected to a \u201cRoot/Branch\u201d we have \u201cStrategies\u201d connected to \u201cUsul\u201d (which acts as the connecting piece to the Safe and state machine for general proposal state). Strategies simply define the logic for tallying vote weight in whatever abstract way (even non-timeboxed methods like conviction voting). We also pass arbitrary data to the Strategy if Usul gets a valid proposal so that proposals can add unforeseen extra data. Usul is audited with a Strat that works like Compound using OpenZeppelin like governor, one-member-one-vote, and NFT strats. It has a working FE in beta that is bridging mainnet and Gnosis Chain, but we have ambitions to use Nomad mentioned by Auryn for access to more chains. Feel free to reach out to me anytime! ",
                    "links": [
                        "https://sekerdao.com/"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving entirely positive feedback on proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.075892857142858
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "8",
                    "likes": "1",
                    "time": "21/05/2022-20:35:51",
                    "content": "Hey @nginnever! Thanks for chiming in. I had a look at Usul; looks useful as a way to make voting modular. However, it doesn\u2019t appear to capture any multi-chain logic. I believe the multi-chain aspect of the EIP is distinct, in that it affords these two things: 1. Token holders can agree on state changes across multiple chains 2. Token holders across multiple L2s and chains can vote on the proposals The first is enabled because the proposal hashes encode calls along with the caller chain id and address. It\u2019s very similar to the OZ Governor contract, but with the caller chain and address it makes the proposal hash cross-chain. I\u2019m curious to hear both of your takes on how to coordinate state updates across multiple chains, as this is the meat of the proposal. As for the voting, I\u2019d like to keep it on-chain and leverage blockchains for data availability. I don\u2019t want Oracles to control our protocol, at least not yet. This is why each branch aggregates the votes and bridges them to the root.  There is a branch on each chain, and the root lives on Ethereum (or whichever is serving as the base chain).  That being said, if voting was modular (as in Usul) then each implementation can decide how it wants to Tally the votes. The EIP might be a little hard to read; I wasn\u2019t stoked on the format but perhaps it just needs more ancillary information. Here is the boiled-down version:   Multi-Chain Governance in a Nutshell  1. A new proposal is recorded in a Governor Root. The proposal hash includes state change across the chains as an array of Call structs: struct Call {     uint callerChainId     address caller     address target     bytes callData }  proposalHash = keccak( Call[], ...other proposal data )  The above is simplified, of course there is more data.  2. Users vote through Governor Branches Users vote by presenting the proposal data, which is hashed to tally the users vote. function vote(uint support, Call[], ...other proposal data)  This is cool, because the Governor Root doesn\u2019t need to signal the Governor Branch. Users can discover proposals off-chain, then submit their vote along with the proposal contents. The contents is hashed to determine the proposal hash.  3. Governor Branches submit their aggregate votes to the Governor Root Once the proposal end time has elapsed, the Governor Branch can submit it\u2019s total votes to the Governor Root: Governor Branch \u2192 addVotes \u2192 Governor Root addVotes(uint for, uint abstain, uint against, bytes32 proposalHash)  This is the first time that we need a bridge. The Governor Branch will send its votes over a bridge to the Governor Root.  Branches that have votes will send them over.  4. Governor Root Queues Proposals that Pass After the Governor Root receives all of the votes, the root can determine whether a proposal passes. If a proposal passes, then the Governor Root can queue the proposal hash in the Governor Branches: Governor Root \u2192 queue \u2192 Governor Branch queue(bytes32 proposalHash)  The queue message needs to be bridged, but only to branches that require execution. We may not need to bridge to all branches.  5. Proposal is executed on Governor Branches Once a proposal hash is queued on a branch, anyone can execute it by submitting the full proposal data: execute(Call[], ...other proposal data)  The data will be hashed, and if the proposal has been queued it will be executed.  Summary In this way, we can easily coordinate state changes across multiple-chains with minimal bridging. Multi-chain proposals are efficiently encapsulated in hashes, and we minimize the number of bridged messages.  The only bridged messages are: Governor Branch \u2192 addVotes \u2192 Governor Root Governor Root \u2192 queueProposal \u2192 Governor Branch  I hope this illustrates the concept better; the EIP contains a lot of information and needs to be cleaned up. It might even need to be broken out into several pieces! Does this make things clearer @nginnever and @auryn? I do believe the multi-chain aspect is distinct. I\u2019m curious to hear your thoughts on it as well as how you\u2019d envision tackling it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.369440371456501
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nginnever",
                    "index": "9",
                    "likes": "2",
                    "time": "22/05/2022-22:16:19",
                    "content": "Usul was built to be another tool in a set of composable tools. With the SekerDAO app we targeted only bridging two chains for scalability purposes (vote on the cheaper chain and bridge the execution to the more expensive one where you need state updates). We also only targeted the Gnosis Chain because there wasn\u2019t a canonical solution for bridging every chain that would make it easy, which is were Nomad comes in. \u2026But composing Zodiac modules together I believe we can achieve the multichain governance you are suggesting. I think it requires just adding one more module to our ecosystem (or voting strategy contract), something like a simple \u201caggregator\u201d module that just waits for each chain to signal consensus that a FOR vote has passed. After collecting all of the chains approval it would then unlock a multisend transaction to various bridge contracts to engage the receiving endpoints with calldata to enact state changes for each chain.  Deploy Gnosis Safes on every chain that will participate in governance. Deploy Usul modules on every chain that needs to vote. Give this module full control of the safe. Deploy Bridge Module endpoints on every chain that needs to receive the outcome of a cross chain vote. Give this module full access to the safe. The bridge sender must be the aggregator module to avoid rogue proposals from injecting calls into the safes. Proposals are submitted to each chain to send a bridge tx to one gnosis safe that simply says (yes, consensus was reached from the voters on this chain to signal a FOR vote for proposal hash 0x\u2026). These transactions hit the aggregator contract, and once all of the configured chains have signaled approval to the aggregator contract, it will then unlock the multisend transaction to bridge back to every chain that needs state updates. The bridged data could just be a message stating that an aggregate proposal is passed in Usul, where each call can then be made, or the actual data just sent directly to the Safe.  I would need to spend a bit more time thinking if I missed anything (particularly with the trust assumptions introduced with multichain governance) or if this can be done without introducing an aggregator module (I\u2019m pretty sure this can also be done with Usul voting strategy that acts as the aggregator actually, which would just be one simple contract that needs to be audited). Some suggestions for your method\u2026     Brendan:  2. Users vote through Governor Branches Users vote by presenting the proposal data, which is hashed to tally the users vote. function vote(uint support, Call[], ...other proposal data)  This is cool, because the Governor Root doesn\u2019t need to signal the Governor Branch. Users can discover proposals off-chain, then submit their vote along with the proposal contents. The contents is hashed to determine the proposal hash.   This seems to require every voter to supply the proposal data for every vote, I wonder if there is a cost tradeoff of having every voter do the hashing calculation vs having one proposer store the data on-chain and create an identifier that everyone votes with.     Brendan:  addVotes(uint for, uint abstain, uint against, bytes32 proposalHash)   Should be able to set the quorum correctly on each chain and simply send a \u201csignal\u201d to the Root by calling chainPassedProposal() and save some data. This might actually be necessary if you use OZ or Comp code directly since they read the totalSupply() from the token contract, which might be only the bridged token and not the actual totalSupply across all chains. Thanks again for taking the time to think about how this can be done in multiple ways, ideally we could find a standard that doesn\u2019t require using one implementation, which is one of the main motivations for Zodiac. You don\u2019t need to use Usul as the governance module and could use any set of contracts that interface with an \u201cAvatar\u201d. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.995495495495495
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "10",
                    "likes": "1",
                    "time": "23/05/2022-22:11:01",
                    "content": "    nginnever:  ideally we could find a standard that doesn\u2019t require using one implementation,   I completely agree! The need for a standard is what is driving this proposal. A common spec will encourage an ecosystem of governance interfaces, analytics, aggregators, and whatever else people can dream up. Tally and other DAO aggregators will be able to scale with us into our multi-chain future. Let\u2019s keep this conversation going. Based on what you said, it sounds like the Gnosis Safe has a lot of modules that will make implementing the spec pretty straightforward.  Having many reusable parts allows developers to move much more quickly. However: what is the \u201cwhole\u201d that these parts form? If we view it like a vehicle, then we see that Gnosis has a great engine and nice wheels but what is the driving experience? How are the engine and wheels controlled? This is what we need to determine. This is the \u201caggregator\u201d module you mention.  Finding the Abstraction The specification needs to capture the right level of abstraction; it needs to be narrow in scope such that it is useful but also composable. To me there are two important features to multi-chain governance: 1. Proposals include state changes across multiple chains 2. Token holders across multiple L2s and chains can vote on the proposals Given that we don\u2019t fully agree on how to tackle voting, let\u2019s put voting to the side for the moment and focus on the first point: how can we standardize multi-chain proposals. This is where we have the most commonality right now. No matter how you vote, code needs to be agreed upon and executed on multiple chains.  Multi-Chain Proposals At a bare minimum we should have a common interface to introspect multi-chain state change proposals. A user of the spec must be able to:  Easily find proposals View the state changes Know whether a proposal has been executed  All signalling should be done through events and on-chain data (this is an EIP after all).  Find Proposals Proposal data should not be stored on-chain. There could be many state changes in a proposal, which would make storage prohibitively expensive. Instead, we can identify proposals using a content hash: the contents of the proposal is hashed to form a unique and verifiable identifier. Let\u2019s call this identifier the proposal hash. Depending on the implementation, proposal data includes state change data as well as consensus data. However, being a multi-chain system, execution and consensus may occur on different chains. We should separate that data. Let\u2019s introduce another content hash for the state change data called the state change hash. We now have: stateChangeHash = hash( stateChangeData ) proposalHash = hash( stateChangeHash, consensusData )  To make this data available off-chain we\u2019re going to need two events. Let\u2019s emit the first event from a contract we will call the StateChangeOrigin: interface StateChangeOrigin {     event StateChangeCreated( stateChangeHash, ...stateChangeData ); }  This event includes the computed stateChangeHash as an indexed topic to make proposal discovery easier. The second event captures the consensus data. By its nature, consensus must occur in a single place, so let\u2019s call the second contract the ConsensusRoot interface ConsensusRoot {     event ProposalCreated( proposalHash, stateChangeHash, ...consensusData); }  The ProposalCreated event emits the proposal hash as an indexed topic as well. By listening for events from a group of StateChangeOrigin and ConsensusRoot contracts a viewer will be able to put together the whole picture of the proposal. These contracts may or may not live on the same chain, or they could even be the same contract!  View State Changes Users must be able to see what the state changes are. We need to standardize the data format for multi-chain calls. What do we need to know for a call? At a minimum, we need to know:  The chainId on which the call is occurring The caller who is the one doing the calling The target of the call The calldata for the call  We can define the \u201cstate change data\u201d as being an array of structs of the above: struct Call {     uint chainId;     address caller;     address target;     bytes callData; }  interface StateChangeOrigin {     event StateChangeCreated( bytes32 indexed stateChangeHash, Call[] calls ); }  Now users can see what changes a proposal is going to make. For now, let\u2019s hand-wave the details of stateChangeHash = hash(calls).  Know the Proposal State Users need to know whether a proposal was successfully executed. This data should be available both on-chain and off-chain through events. Given that a proposal can be executed on multiple chains, we\u2019ll need to track execution per caller. The Caller contract is the one that executes the proposal, so it must provide an event and on-chain accessor: interface Caller {     event Executed(bytes32 indexed proposalHash);      function wasExecuted(bytes32 proposalHash) external view returns (bool); }  The Executed event must be emitted when the execution occurs.  The wasExecuted function allows on-chain contracts to determine if a proposal passed, and behave accordingly.  Summary Let\u2019s bring the above all together: struct Call {     uint chainId;     address caller;     address target;     bytes callData; }  interface StateChangeOrigin {     event StateChangeCreated(         bytes32 indexed stateChangeHash,         Call[] calls     ); }  interface ConsensusRoot {     event ProposalCreated(         bytes32 indexed proposalHash,         bytes32 indexed stateChangeHash,         bytes consensusData     ); }  interface Caller {     event Executed(bytes32 indexed proposalHash);      function wasExecuted(bytes32 proposalHash) external view returns (bool); }   These interfaces will allow a third party to:  Find proposals (via indexing) View the state changes (by interpreting encoded event data) Know whether a proposal has been executed (by looking at multi-chain callers)  Open Questions  Is this enough for a multi-chain proposal MVP? Does this spec need more? Is it too much? what details are missing?  Add value and delegateCall on the Call struct? Add bytes extraData on the event StateChangeOrigin for extensibility?   Is this spec flexible enough to support multiple voting EIPs?   Note on Gas     nginnever:  I wonder if there is a cost tradeoff of having every voter do the hashing calculation vs having one proposer store the data on-chain and create an identifier that everyone votes with   You can ballpark the gas usage using evm.codes. The most expensive part will be the hashing of calldata, so let\u2019s calculate the hashing costs:  Estimate 6 words per Call struct Estimate 6 calls per Proposal Estimate each proposal has 4 words of consensus data  Total bytes per proposal: (6*6+4) * 32 = 1280 Plug that into the SHA3 opcode and it costs 393 gas (worst-case). A cold SLOAD is 2100, so it\u2019s cheaper than loading from storage.  Summary This pared-down version of the EIP keeps the proposal standard, but is flexible enough for implementations to tackle consensus their own way. What do you all think of this? Is this more narrow scope a better starting point? ",
                    "links": [
                        "https://www.evm.codes/"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "3rd party or author wants to collaborate on proposal"
                    ],
                    "Sentiment": 5.770444167704442
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/mintcloud",
                    "index": "11",
                    "likes": "3",
                    "time": "24/05/2022-12:11:17",
                    "content": "Thank you @Brendan for kicking this off, and Auryn and Nathan for your contribution thus far. Just wanted to signal our interest from 0x protocol on the topic. We have deployed the protocol on 7 different EVM-compatible blockchains and are planning to setup an onchain binding \u201cembassies+central government\u201d governance system, controlled by ZRX holders. We implemented a community treasury with onchain binding voting on L1, and that might evolve into \u2018local treasuries\u2019 too. The GovernorBranch/ GovernorRoot pattern seems promising at a first glance. Intuitively, I tend to prefer leaving voting strategies and voting power calcs to each protocol/system, and land on standard for cross-chain state updates. We\u2019ll be watching this discussion closely!  ",
                    "links": [
                        "https://www.0x.org/zrx/treasury"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.550000000000001
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rafso",
                    "index": "12",
                    "likes": "2",
                    "time": "31/05/2022-17:59:47",
                    "content": "Hi, Raf from Tally here. I\u2019ve was talking about this spec with Brendan offline a few weeks ago. I\u2019m finally catching up on this thread. I like the idea of splitting the two problems \u2013 cross-chain voting and cross-chain execution \u2013 into separate specs. Seems easier to agree on the path forward and to solve that way. Lots of DAOs are looking at how to solve this problem. I\u2019ve also been following the discussions of how Uniswap DAO plans to solve it.     Brendan:  Proposal data should not be stored on-chain. There could be many state changes in a proposal, which would make storage prohibitively expensive. Instead, we can identify proposals using a content hash: the contents of the proposal is hashed to form a unique and verifiable identifier. Let\u2019s call this identifier the proposal hash.   In our experience at Tally, storing stuff on-chain is expensive, but it\u2019s a huge benefit for interoperability and UX. Maybe a happy medium would be to include optional fields for URI that point to the un-hashed data. The URLs can obviously become unavailable, but that at least makes UX easier when everyone is cooperating. It also makes it more obvious when someone isn\u2019t cooperating by withholding data.     Brendan:  The ProposalCreated event emits the proposal hash as an indexed topic as well.   Naming this event ProposalCreated causes a collision with the  OZ Governor event of the same name. Do we want to reuse the name? That makes it impossible to create a contract that implements both the OZ Governor interface and this cross-chain execution interface. I\u2019d suggest using a different name. Alternatively, we could overload the existing ProposalCreated event by putting the body of cross-chain event in the description. That\u2019s a pretty ugly hack, but it would give us backwards compatibility without needing to upgrade all the existing contracts. I\u2019d also suggest including canonical start and end times for the voting period in this event. Otherwise, how will the off-chain votes know when to start and end the vote?  We should use wall clock times, not block heights, because we can\u2019t assume that other chains know the block heights on the root chain. Even if we do have start and end times, voters can still do timing attacks by moving tokens between chains because the vote won\u2019t start at exactly the same time on all chains. I\u2019m not sure how big of a deal that is. I\u2019m ignoring it for now.     Brendan:  The Executed event must be emitted when the execution occurs. The wasExecuted function allows on-chain contracts to determine if a proposal passed, and behave accordingly.   What\u2019s the correct behavior for a proposal that passed, but whose execution reverts due to an error? We could only allow execution once, but the error may go away in the future. I would suggest letting anyone keep trying to execute the proposal, but only for X amount of time. I don\u2019t think we need to change the interface to support that possible requirement. It\u2019s internal to the execution logic on each chain. Overall, I like the direction that this spec is going. I\u2019ll post more thoughts as I come up with them. ",
                    "links": [
                        "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4942bd19e2da9e416e46da74356506d85950a491/contracts/governance/IGovernor.sol#L28-L38"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.130376344086022
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "13",
                    "likes": "0",
                    "time": "01/06/2022-22:11:03",
                    "content": " Proposal Data URI     rafso:  In our experience at Tally, storing stuff on-chain is expensive, but it\u2019s a huge benefit for interoperability and UX. Maybe a happy medium would be to include optional fields for URI that point to the un-hashed data.   This is interesting to me! My assumption was that including the events would be enough, as the proposal data would be emitted. Do you feel that events are insufficient or impractical? We\u2019ve also found that events aren\u2019t the most convenient, as they require an archive node to access. We\u2019ve been using subgraphs for data, but the Graph network doesn\u2019t support all chains. If we added a proposalDataUri as you suggested, then the proposal data could be sourced from anywhere. For example, the data could be stored on:  IPFS Web 2 host The Governor Branch contract itself (proposal origin) A separate chain used for data availability  To support all of the above, it makes me think:  The spec will need to define a JSON schema (just like ERC721 metadata) We could additionally specify that the uri can be application/octet-stream with the standard ABI encoded data; that way contracts can store the data themselves (if gas is cheap  ) Is it possible to use a separate chain for data availability? Can a URI point to a function on a chain?  I like the proposal data URI idea! Having a JSON schema and abi-encoded application/octet-stream would go a long way in terms of flexibility (and we can always still have the event).  Timestamps     rafso:  I\u2019d also suggest including canonical start and end times for the voting period in this event. Otherwise, how will the off-chain votes know when to start and end the vote?   This is an interesting one\u2026in the voting spec above I outline how \u201cepochs\u201d can prevent double voting (h/t to @frangio for the idea!). The \u201cstart epoch\u201d of the vote would be recorded; not the wall clock start time. It seems to me that start and end times are actually a property of voting, so I hesitate them to include them in the proposal spec. However, perhaps we can broaden the meaning: the \u201cstart time\u201d could instead the more abstract \u201ccreated at\u201d timestamp of the proposal. It would be useful for proposal display, regardless of voting. The \u2018end time\u2019 of a proposal may not be applicable to all implementations. Thoughts?  @auryn I\u2019ve heard that the Gnosis Chain is going to be used as a kind of \u201cgovernance chain\u201d. Is there substance to that? What do you think of the data availability aspect? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.131944444444445
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/anna-carroll",
                    "index": "14",
                    "likes": "3",
                    "time": "01/06/2022-22:55:55",
                    "content": "Hey folks!! I\u2019ve been following this conversation closely and have so much to chime in!! For those who don\u2019t know me, I\u2019m the Protocol Lead at Nomad, and have been working closely with @auryn and Nathan on the aforementioned Zodiac module.     Brendan:   Who else wants multi-chain governance?    Me me me   Execution vs. Voting First things first: I strongly agree with the idea of separating concerns between proposal execution and voting. These are two different design spaces which both need to be solved for. I recommend we start with cross-chain proposal execution.  Reasoning  For a cross-chain protocol, voting doesn\u2019t necessarily need to be cross-chain, whereas proposal execution almost certainly does. A lot of large existing DAOs have well-working solutions for voting on a single chain (e.g. GovernorBravo), which they may not want to migrate from any time soon; many of these same DAOs have very broken experiences for cross-chain proposal execution, which is becoming more pressing to solve. Multichain voting is a much larger design space, whereas cross-chain proposal execution is a tighter design space to start with. I have participated in a lot of discussions with teams about multichain voting already, and the needs can vary widely per-team. Over time I am definitely excited to participate in how this design space evolves!   GovernanceRouter.sol Next things next: I was glad to see some of the design conclusions @Brendan came to in his post about Multi-Chain Proposals, as many of them tightly mirror the Nomad GovernanceRouter.sol contract, a contract for cross-chain proposal execution which I designed nearly over a year ago!!  (Anyone who checks it out, feel free to provide feedback!)  Similarities  (1) A struct of calls to be passed across chains:     struct Call {         bytes32 to;         bytes data;     }  Two questions about the proposed struct:   address caller: why include this field? message passing protocols (that I know of) include the address of the caller on the origin chain so that it can be authenticated. in my mind it would be an attack vector for this to be configurable by end users, unless I misunderstand  chainId: I felt it was best to batch an array of Calls on a per-chain basis. the array of Calls for each destination chain is hashed and sent to the destination chain, to be executed in one atomic batch. in that world, a chainId wouldn\u2019t need to be part of individual Call struct, it\u2019s associated with an array of Calls. I think that atomic execution of all of the Calls on one chain is quite desirable to maintain   (2) An event emitted when a state change is executed, mapping to event Executed above: event BatchExecuted(bytes32 indexed batchHash);   (3) A queryable function inboundCallBatches which tells the caller the status of a batch, similar to the function wasExecuted above.     // call hash -> call status     mapping(bytes32 => BatchStatus) public inboundCallBatches;      // The status of a batch of governance calls    enum BatchStatus {        Unknown,    // 0 - batch not yet delivered. may not exist.        Pending,    // 1 - batch delivered, but not executed        Complete    // 2 - batch executed    }  Note: in my experience executing cross-chain proposals, returning the status enum - not a bool - to tell the status of a Batch has been very helpful in practice, such that off-chain actors know when it is possible to execute a batch. See this script, which checks if a batch has been received, then executes it.  Differences (1) I opted not to emit a similar event to StateChangeCreated, because Nomad emits an event for every message sent, but I would be super open to revisit that decision  (2) Emits this event when the cross-chain containing the state change is delivered:      event BatchReceived(bytes32 indexed batchHash);  Again, it\u2019s helpful to know that additional intermediary step for a Batch, before the Batch is Executed. ",
                    "links": [
                        "https://github.com/nomad-xyz/monorepo/blob/b64a6c5abcc84a93b81d4d68698c3633763a36ed/packages/sdk-govern/scripts/executeRemoteDomains.ts#L37"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.745455865272938
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rafso",
                    "index": "15",
                    "likes": "1",
                    "time": "02/06/2022-09:21:22",
                    "content": "    Brendan:  This is interesting to me! My assumption was that including the events would be enough, as the proposal data would be emitted. Do you feel that events are insufficient or impractical?   Ah good point, thanks for clarifying. I agree that event logs are sufficient. I didn\u2019t realize that your proposed StateChangeCreated and ProposalCreated include plaintext data before hashing. That should be enough for anyone to reconstruct the proposal.     Brendan:  It seems to me that start and end times are actually a property of voting, so I hesitate them to include them in the proposal spec. However, perhaps we can broaden the meaning: the \u201cstart time\u201d could instead the more abstract \u201ccreated at\u201d timestamp of the proposal. It would be useful for proposal display, regardless of voting. The \u2018end time\u2019 of a proposal may not be applicable to all implementations.   Yes, I agree that we want to separate cross-chain execution from cross-chain voting. The cross-chain voting spec should have its own event with whatever metadata the branches need. We can figure out the right fields, such as epoch vs created_at, when we implement or create a spec for voting.     anna-carroll:  Next things next: I was glad to see some of the design conclusions @Brendan came to in his post about Multi-Chain Proposals, as many of them tightly mirror the Nomad GovernanceRouter.sol   Awesome. Thanks for sharing! Seeing your working implementation helps me a lot to understand the details, especially around keeping track of branch execution with BatchStatus and BatchReceived. That bookkeeping state seems super-useful.     anna-carroll:  (1) I opted not to emit a similar event to StateChangeCreated, because Nomad emits an event for every message sent, but I would be super open to revisit that decision   a StateChangeCreated state might be helpful to abstract away the bridge. Indexers might not want to have to keep track of events on bridges, and different bridges might not even emit the same events. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.9730952380952385
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/anna-carroll",
                    "index": "16",
                    "likes": "0",
                    "time": "02/06/2022-11:38:02",
                    "content": "    rafso:  Seeing your working implementation helps me a lot to understand the details   I\u2019m so glad to hear that!! This implementation has been putting in work, as Nomad executes cross-chain proposals with it regularly (most commonly to deploy & enroll a new chain).     rafso:  a StateChangeCreated state might be helpful to abstract away the bridge. Indexers might not want to have to keep track of events on bridges, and different bridges might not even emit the same events.   I totally agree it would be very nice to have an event indexers could pick up that indicates initiating cross-chain call execution  Do you think that event should be emitted once for each destination chain, or once with a bundle of every destination chain? Personally, I\u2019d say once per destination. Perhaps a higher-level Proposal event could include a bundle. As a side note, I\u2019d propose exploring some more general naming:     event CrossChainCall(uint32 destination, bytes32 callHash, Call[] calls);  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.112551652892561
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "17",
                    "likes": "0",
                    "time": "02/06/2022-16:50:01",
                    "content": "Hey Anna! Nice to meet you. I did a deep-dive into Optics before Nomad emerged. I like the tech. You\u2019ve raised a lot of great points, in particular:  Batch semantics. Group calls by caller Batch status: a function on the executor lets us know the status of the batch  Both of these make a ton of sense to me. However, you mention that you don\u2019t see a need for the address caller. After looking at the GovernanceRouter code, I think I see something very interesting!  Imperative vs Declarative Here is what I\u2019m looking at in particular: function executeGovernanceActions(     GovernanceMessage.Call[] calldata _localCalls,     uint32[] calldata _domains,     GovernanceMessage.Call[][] calldata _remoteCalls ) external onlyGovernorOrRecoveryManager;  While you haven\u2019t explicitly declared the caller and the chainId for the array of calls, they are implicitly encoded in the \u2018domains\u2019 array and by who is listening on the other end. IIRC the domain is a xapp connection, so you are defining the receiver of each remote call batch. (afaik there is no multicasting yet?) In a sense, Governance Router proposals are imperative in that the proposal is telling the router how to execute the proposal. A third party looking at the proposal would have to know the Nomad transport semantics to know who is calling who on what chain. By including the caller and chainId, the cross-chain proposal becomes declarative; it doesn\u2019t care how the bridging is accomplished, but it knows what the outcome will be. Contract X on chain Y will call function Z. If there are multiple batch executors on one chain, then each knows what it must do. Is there a way we can marry these two? How can we keep the proposals transport-layer agnostic? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.145833333333332
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/anna-carroll",
                    "index": "18",
                    "likes": "2",
                    "time": "02/06/2022-23:05:06",
                    "content": "    Brendan:  By including the caller and chainId, the cross-chain proposal becomes declarative; it doesn\u2019t care how the bridging is accomplished, but it knows what the outcome will be. Contract X on chain Y will call function Z. If there are multiple batch executors on one chain, then each knows what it must do. Is there a way we can marry these two? How can we keep the proposals transport-layer agnostic?   Ahh I see what you mean now. address caller was meant to indicate the contract on the destination chain that will receive the cross-chain message which contains the calls, and then execute the calls. So, there is value in including the address of the caller on the event emitted, so an indexer can \u201cknow\u201d where to look for these events - however, a couple things to note about the caller role.  Specialized Caller Regardless of the transport layer being used -  the caller must be a special contract, which implements a function to make it capable of receiving cross-chain messages from that transport layer. In Nomad, that function is called handle; in other transport layers, there are other names (there has been no cross-chain message passing standard, yet!) The caller does the following:  handle incoming cross-chain messages from some transport layer perform access validation on the message (e.g. check it\u2019s coming from a permitted source) decode the Calls within the message execute the Calls   To perform this role to the fullest, the caller would be the contract in control of permissioned roles on a protocol. In most cases, those permissions tend to aggregate to a single contract. For example: GovernorBravo usually holds all the permissions for a given protocol, and often custodies treasury funds too.  Multiple Callers? I\u2019d estimate that in the vast majority of cases, that, because  the caller must be a special contract the caller holds privileged permissions on the protocol  This would mean that the vast majority of DAOs would opt for one caller contract per chain. That being said, doesn\u2019t really matter - we can emit the following event once per (destination, caller) tuple:     event CrossChainCall(uint32 destination, address caller, bytes32 callHash, Call[] calls);  Knowing that, usually, there will be just one per chain. (Incidentally - at Nomad, we think of the (chainId, address) tuple as an address\u2019 \u201cidentifier\u201d in the cross-chain world. Just an address is no longer sufficient.)  Naming Personally, to me the name caller is a bit confusing because there are so many potential callers in the process.  the EOA that sends the transaction that initiates the cross-chain call on the sending chain the contract that actually calls the transport layer to initiate the cross-chain call on the sending chain the EOA that sends the transaction that executes the calls on the destination chain the contract that actually executes the calls on the destination chain  All of these could be fairly called a caller. What do y\u2019all think? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.234788359788359
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "19",
                    "likes": "1",
                    "time": "03/06/2022-22:04:12",
                    "content": "I agree that caller is too generic, and that it will need specialized logic in order to receive an authorized batch of calls. Being less abstract will make the spec much clearer. Call it Branch? Remote? Open to ideas. It feels like the conversation is starting to gain focus- so I want to take a step back and reframe what we\u2019re talking about.  Recap The proposal lifecycle can be boiled down into three steps:  Proposal is created Proposal is voted on If passed, proposal is executed  This thread has touched on all three of these steps, but we have the most common ground in the third: proposal execution. Most protocols will need to coordinate and execute state changes across multiple chains. That\u2019s a given. In fact, this is exactly what the Toby has written up in the Uniswap Universal Governance Module. They want to remote control contracts. The Uniswap RFC says that they are evaluating different vendors. In all likelihood these vendors have different interfaces: the resulting module will be proprietary. It seems like we all agree that cross-chain execution is the biggest and most common pain point: so how about we start there? I would love to be able to swap different bridges: for example start with a native bridge then swap out for Nomad or another solution (or straight to Nomad  ) You used a word in the Governance Router that I thought captured it well: remote. We\u2019re talking about \u201cRemote Execution\u201d.  Standard for Remote Execution It seems that we all want a standard for Remote Execution. This is really ground zero for multi-chain system: executing cross-chain calls. The standard should be comprehensive enough to be useful, but small enough to be easy to implement. What should the goals of the standard be? Perhaps:  Make it easy to trace protocol execution across multiple chains, regardless of transport layer. Make it easy to swap out transport layer  Tracing would be easy to do, as we really just need to standardize events, like we\u2019ve been talking about. Being able to swap out the remote execution puts more constraints on the implementation, but would be incredibly useful. Using your language, imagine we had two contracts:   Router: send execution batches to remotes  Remote: receives batches and executes  The spec could define that:  remotes are keyed on (chainid, address) events are emitted to help with tracing a Router function sends batches a Remote function checks batch status  Thoughts? I feel like we\u2019re starting to gain some clarity here! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.501133786848072
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "20",
                    "likes": "0",
                    "time": "04/06/2022-13:37:06",
                    "content": "Hey, not sure if this has come up yet, but have you considered using ChainAgnostic\u2019s standards track? GitHub - ChainAgnostic/CAIPs: Chain Agnostic Improvement Proposals ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 3.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "21",
                    "likes": "1",
                    "time": "05/06/2022-22:09:32",
                    "content": "I didn\u2019t know about CAIPs! But what we\u2019re talking about it pretty EVM-specific; I think it fits well here. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/mintcloud",
                    "index": "22",
                    "likes": "1",
                    "time": "07/06/2022-09:18:10",
                    "content": "Thanks everyone for narrowing the scope. Focusing on a standard for remote execution makes a lot of sense. The risk now seems to be the fact that such standard could apply to \u2018arbitrary\u2019 remote execution, while we all started with the governance use case in mind. Unless you guys think it won\u2019t affect the design space that much, it might be useful to restrain this standard to governance applications to start. That can help address questions like:  multiple callers/remote/branch? Frankly, I think we don\u2019t need that in the case of governance, as only one designated \u2018branch\u2019 contract should be able to receive, validate and execute proposals. Agree with @anna-carroll here      anna-carroll:   the caller must be a special contract the caller holds privileged permissions on the protocol  This would mean that the vast majority of DAOs would opt for one caller contract per chain.    naming being the most difficult in programming (esp. protocol programming), I actually quite liked the GovernonRoot/GovernorBranch proposal at the beginning of the EIP - however I understand it could be messing out with proposal creation and voting, something we\u2019re not interested in. Not really fond of caller       Brendan:  I agree that caller is too generic, and that it will need specialized logic in order to receive an authorized batch of calls. Being less abstract will make the spec much clearer. Call it Branch? Remote? Open to ideas.   My suggestion might be completely off. If it\u2019s easy enough to abstract that to arbitrary remote execution, then let\u2019s go for it! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.267953149001537
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "23",
                    "likes": "0",
                    "time": "07/06/2022-17:47:57",
                    "content": "I think we can have our cake and eat it too! That being said, I agree @mintcloud. Let\u2019s analyze it with our governance hats on so that we can nail that use case. Once we\u2019re happy with it we can put our protocol hats on and see how well it works for other use cases. Something I realized over the weekend was that the sender of the message can\u2019t necessarily guarantee who the recipient is. The Router could include the Remote\u2019s chainId and address in the message, but anyone can decide to execute that message. It\u2019s not up to the Router. And, for a bridge implementations like Nomad, the recipient is implicit in the domain code. Instead, it\u2019s the Remote that must be aware of the Router. The remote must validate the message sender. This is evidenced by both the Nomad Governance Router and the OpenZeppelin Cross-Chain Aware contract implementation. The Nomad GovernanceRouter has a handle function that receives remote calls. Note the onlyGovernorRouter modifier:     function handle(         uint32 _origin,         uint32, // _nonce (unused)         bytes32 _sender,         bytes memory _message     ) external override onlyReplica onlyGovernorRouter(_origin, _sender);  The new OpenZeppelin cross chain contracts are implemented as being \u201ccross chain aware\u201d, in the sense that they are aware of a cross chain sender, and can authorize accordingly:     function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {         return _sender;     }      function processMessageFromRoot(         uint256,         address rootMessageSender,         bytes calldata data     ) external override nonReentrant {         _sender = rootMessageSender;         Address.functionDelegateCall(address(this), data, \"cross-chain execution failed\");         _sender = DEFAULT_SENDER;     }  The OZ cross-chain plumbing is a little more low-level, but it illustrates how they are providing easy access to the cross-chain origin so that the receiver can authorize the call. Finally, I do want to mention the Curve Gauges. While we\u2019re thinking about this in terms of governance, it\u2019s very clear that protocols will need this for their interactions as well. The Curve sidechain Gauges are a great example of this. They\u2019ve cut and paste gauge code for each of Arbitrum, Polygon, xDai, and others, then replaced a small piece of the internals to send a message across the relevant bridge. If they had had a remote execution abstraction they could have re-used so much more code. So with that being said, I would tweak the Remote Exec outline above to instead say that the Remote should be aware of the router, and have accessors for the router / chainid. ",
                    "links": [
                        "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/crosschain",
                        "https://github.com/curvefi/curve-dao-contracts/tree/aedbb55f3492bc3b28829264960662a8bc662187/contracts/gauges/sidechain"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.506199494949495
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/anna-carroll",
                    "index": "24",
                    "likes": "1",
                    "time": "09/06/2022-01:50:22",
                    "content": " Recipient Validates Sender     Brendan:  So with that being said, I would tweak the Remote Exec outline above to instead say that the Remote should be aware of the router, and have accessors for the router / chainid.   Yes, the message receiving contract should be \u201caware\u201d of the address of the message sending contract. Note the same functionality in Zodiac Nomad module - it calls the authorized sender the \u201cController\u201d:   /// Address of the remote controller which is authorized   /// to initiate execTransactions on the module from a remote domain.   address public controller;   /// Domain of the controller which is authorized to send messages to the module.   /// Domains are unique identifiers within Nomad for a domain (chain, L1, L2, sidechain, rollup, etc).   uint32 public controllerDomain;  when the Zodiac module receives messages from Nomad, it validates that the message comes from the Controller: function handle(     uint32 _origin,     uint32, // _nonce (unused)     bytes32 _sender,     bytes memory _message   ) external onlyValid(msg.sender, _origin, _sender) {  where onlyValid in turn calls require(isController(_senderAddr, _origin), \"Unauthorized controller\");   Cross-Chain Owner You can think of the Controller like the cross-chain version of an Owner. Instead of using onlyOwner which checks that msg.sender == owner  we instead have to check that origin == controllerDomain &&  sender == controllerAddress  Again, with the (domain, address) tuple being the unique identifier in the cross-chain world - address is no longer sufficient.  Naming, Again I want to note that Router is a naming convention that @prestwich and I started using for cross-chain application contracts which are isomorphic in nature. That is, these cross-chain applications (xApps) have the same code on every chain; they must contain the logic for both sending and receiving messages. Nomad\u2019s Bridge and core Governance xApps use the Router pattern. They contain both message sending & message receiving logic, and the code is deployed the same everywhere. The Zodiac Nomad module does not follow this pattern. It only implements receiving logic. The contract you\u2019ve described as the \u201cRouter\u201d only implements sending logic - as such, I\u2019d gently discourage using the term Router for that. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.222222222222222
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "25",
                    "likes": "0",
                    "time": "10/06/2022-12:38:52",
                    "content": "Hello, I\u2019m just joining in, and I have difficulties following your language. In particular, I don\u2019t understand which contracts are on which chains. I\u2019m also not sure I undersand the:     Brendan:    Router: send execution batches to remotes  Remote: receives batches and executes    My understand is, that when doing a cross-chain operation, such as executing a governance call, there is:  A caller (C), on chain #1  A receiver (R), on chain #2.  Am I correct in understanding that  the router is on chain #1, its being called bu the caller (C), and it triggers \u201csomething\u201d the remote is on chain #2, it receives cross chain messages, calls the receiver (R) and includes mechanisms so that R can figure out who C is?  In that sense, Router-Remote would form a bridge. Or maybe I got it wrong, and Router and Remote are both on chain #1, with remote being the bridge entry-point and router being a discovery mechanism. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.508333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "26",
                    "likes": "1",
                    "time": "10/06/2022-12:48:30",
                    "content": "For the record, I believe that the main issue in that space comes from the different bridges having such different interfaces. IMO, the \u201clow level\u201d bridges should be very simple, with very few feature (they should not care about replay tickets for example), and all the features should be built in the userspace. Here is an example of such a bridge, that can be be specialized for full duplex communication between polygon root chain mainnet and child chain If such bridges were standard and widely available, we could build routers allow chainId lookup, and remote execution on any chain (for which a bridge is known) ",
                    "links": [
                        "https://github.com/Amxx/openzeppelin-labs/blob/devel/crosschain-contracts/contracts/global/polygon-callbridge/BrigdePolygonRoot.sol",
                        "https://github.com/Amxx/openzeppelin-labs/blob/devel/crosschain-contracts/contracts/global/polygon-callbridge/BrigdePolygonChild.sol"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.231944444444444
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "27",
                    "likes": "1",
                    "time": "14/06/2022-20:49:35",
                    "content": "    Amxx:  Am I correct in understanding that  the router is on chain #1, its being called bu the caller (C), and it triggers \u201csomething\u201d the remote is on chain #2, it receives cross chain messages, calls the receiver (R) and includes mechanisms so that R can figure out who C is?    Yes, exactly! You nailed it. Looking at your code, the IBridge contract would be roughly analogous to the \u201cRouter\u201d: interface IBridge {     function sendMessage(address target, bytes memory data) external; }  It\u2019s just a matter of defining additional responsibilities for the receiver. By defining the receiver behaviour we can unify an interface across Nomad, the Polygon Bridge, and others. I\u2019m going to whip up a new EIP draft that captures what we\u2019ve discussed so far, then create a new topic so that we can start a fresh conversation. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.436237373737374
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Brendan",
                    "index": "28",
                    "likes": "2",
                    "time": "15/06/2022-17:45:33",
                    "content": "The draft of the EIP for Cross-Chain Execution has now been opened as a PR. Once an EIP number is assigned I\u2019ll create a fresh discussion thread for us to continue fine-tuning the spec. I\u2019ve added everyone in this thread as a contributor; but if you don\u2019t wish to be included please dm me. New Thread: EIP-5164: Cross-Chain Execution ",
                    "links": [
                        "https://ethereum-magicians.org/t/eip-5164-cross-chain-execution/9658"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "3rd party or author wants to collaborate on proposal"
                    ],
                    "Sentiment": 6.090909090909092
                }
            ]
        }
    ],
    "group_index": "1746"
}