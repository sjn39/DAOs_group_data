{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/immutables-invariants-and-upgradability/2440",
            "title": "Immutables, invariants, and upgradability ",
            "index": 2440,
            "category": [
                "EIPs"
            ],
            "tags": [
                "NONE"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "1",
                    "likes": "11",
                    "time": "16/01/2019-12:55:49",
                    "content": "One of the critical meta-questions raised by Remediations for EIP-1283 reentrancy bug and the delay of the Constantinople upgrade is: Precisely what on Ethereum is immutable and what behavior should be considered invariant? Since irregular state transitions are outside the scope of this conversation, for sake of argument let\u2019s all agree that code and data (storage) are immutable. However, we\u2019re left with the challenge that EVM semantics can and do change during a hard fork, the most germane example here being a change in gas cost. In other words, as a smart contract developer, even though I know my code will not change, I do not have a guarantee that its behavior will not change. As @AlexeyAkhunov points out:  In all other hard forks, the gas cost of operations were only increased  and it appears that many developers may have been relying on this to be invariant, as well as on the fact that send and transfer couldn\u2019t result in reentrancy, which as @MicahZoltu points out here, was only \u201cimplied\u201d and never explicit:  Not only was the invariant only implied, not explicitly stated, but if no one is depending on it what do we gain by maintaining it?  I assert that:  in general (with the possible exception of an emergency fix to EVM behavior where the risk of not fixing it is greater than the risk of changing the behavior of deployed code) there is a tacit social contract with developers whereby not only code but behavior should be immutable. This has not always been true historically, but many people nevertheless believe it to be true, hence the tacit social contract and the problem of \u201cimplied\u201d invariants.  intended behavior of deployed code is extraordinarily hard to establish \u2013 e.g., did a developer write something a certain way intentionally, or did they make a mistake? Therefore, we should not be in the business of trying to figure out or maintain intended behavior of deployed code. For this reason I disagree with use of the word \u201cbreak\u201d as in \u201cbreaking changes\u201d or \u201cbreaking someone\u2019s code\u201d since, without establishing intent, we cannot know whether behavior has been \u201cbroken\u201d or not.  If you agree with both of these points, then I think it follows that:  all upgrades should be backwards-compatible, which is to say, they should not change the behavior of on-chain code.  I see two potential ways of achieving this:   Introducing an \u201cEVM version\u201d flag to deployed code (like a solidity pragma) so that a developer knows that their code will always target a particular version of EVM. This adds the requirement that all clients implement all historical EVM semantics and can fire up a VM for any EVM version. In practice all major clients today do implement all historical EVM semantics, but future clients may not. Another challenge with this approach is that contracts can call other contracts, which may in turn call contracts that target a newer EVM, so it does not solve the underlying problem. This could be addressed using a form of snapshotting or \u201cstatic linking\u201d of contracts, but that introduces complexity and problems with upgradability. A final challenge here is that it makes analysis and auditing much harder.   Another, simpler approach is to never change the behavior of an existing opcode (again, except in case of emergency). All changes to existing opcodes are introduced as new opcodes\u2013in the case of EIP-1283, instead of changing SSTORE, a new SSTORE2 (or SSTORE_CHEAPER) could be introduced. This has the upside of simplicity and the downside of making the EVM more complicated.   There are two big, outstanding questions, however:  If we move forward with state rent or a similar solution, can it be done without changing the behavior of deployed code? Should Ethereum 1.x be in \u201cmaintenance mode\u201d with no further EVM changes, and should all such changes instead target Eth 2 and perhaps be done in Ewasm?  Thanks. [Thanks to Liam Horne, Dan Robinson, Joshua Goldbard, and James Prestwich for sharing thoughts and discussing this issue. This was inspired by the conversation we had on this topic.] ",
                    "links": [
                        "https://ethereum-magicians.org/t/core-devs-discussion-about-a-vulnerability-in-constantinople-delay-of-the-upgrade/2427",
                        "https://ethereum-magicians.org/t/remediations-for-eip-1283-reentrancy-bug/2434/16",
                        "https://ethereum-magicians.org/t/remediations-for-eip-1283-reentrancy-bug/2434/18",
                        "https://eips.ethereum.org/EIPS/eip-1283",
                        "https://ethereum-magicians.org/t/ethereum-state-rent-for-eth-1-x-pre-eip-document/2018",
                        "https://ethereum-magicians.org/t/council-of-paris-2019-call-for-agenda-topics/2442/3",
                        "https://ethereum-magicians.org/t/remediations-for-eip-1283-reentrancy-bug/2434/46",
                        "https://ethereum-magicians.org/t/remediations-for-eip-1283-reentrancy-bug/2434/93",
                        "https://ethereum-magicians.org/t/council-of-paris-2019-call-for-rings/2726",
                        "https://ethereum-magicians.org/t/remediations-for-eip-1283-reentrancy-bug/2434/91",
                        "https://ethereum-magicians.org/t/jello-paper-as-canonical-evm-spec/2389/22"
                    ],
                    "GPT-summary": "The author discusses the challenge of maintaining the intended behavior of deployed code on Ethereum, especially in the context of hard forks and changes in gas cost. The author proposes two potential solutions to ensure backwards-compatibility of upgrades, including introducing an \"EVM version\" flag or never changing the behavior of an existing opcode. The post also raises questions about the feasibility of state rent without changing the behavior of deployed code and whether Ethereum 1.x should be in \"maintenance mode.\"",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Interoperability and Scalability",
                        "Privacy, Security and risk management",
                        "Token economics",
                        "Law and regulations"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None"
                    ],
                    "Sentiment": 5.387462452513473
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "2",
                    "likes": "3",
                    "time": "16/01/2019-13:42:53",
                    "content": "would merge here from other topic\u2026    ERC-1283 reentrancy bug and long term gas cost stability assumption   The root cause of the ERC-1283 re-entrancy bug is an assumption about stability of gas costs and in particular that the gas cost of any storage change is more than a transfer call offers to the target contract. Gas costs of OPCODE come from sampling on \u201cusual\u201d hardware. Whatever \u201cusual\u201d hardware can be, it changes in years. Correspondent gas costs should be tuned time to time to prevent DDOS attacks or too low block limits. For example, if Non-Volatile Memory becomes significantly faster, the gas cost ratio SSTORE/MSTORE may change accordingly (lowing the SSTORE costs). Simply rising limits for gas per block will not work because it will create a DDOS attack vector by excessive usage of still-slow OPCODEs. I thing we should make it clear, that OPCODE gas costs are NOT constant in long term. Avoidable assumptions about gas costs in the future is a bad practice and should be discouraged.   ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.023809523809524
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "3",
                    "likes": "0",
                    "time": "16/01/2019-13:49:38",
                    "content": "    lrettig:  Another, simpler approach is to never change the behavior of an existing opcode (again, except in case of emergency).   Do you mean gas cost of an opcode is its behavior?  As I mentioned above, gas cost tuning may be necessary in the future because of hardware evolution. It is just not constant in long term. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.697916666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "4",
                    "likes": "0",
                    "time": "16/01/2019-15:29:19",
                    "content": " gas cost tuning may be necessary in the future because of hardware evolution. It is just not constant in long term  This is a good point. Yes, I am considering gas cost tuning to be a behavior change as well\u2013again, ample evidence in this present SSTORE issue. We always have the option of increasing the block gas limit rather than lowering the gas cost, of course, although that\u2019s much less surgical. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.345238095238095
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jpitts",
                    "index": "5",
                    "likes": "3",
                    "time": "16/01/2019-16:15:25",
                    "content": "Definitely appreciate the first principles approach here! A lot can be learned from recent computing history. The evolution of the x86 architecture sheds a lot of light, particularly as it fit into the IBM PC platform (allegorical to all of the other factors of the Ethereum protocol which affect how smart contracts run in the EVM). Serious resources were put into backwards compatibility, and this is because Intel, MS, developers, and other stakeholders wanted to maintain stability of applications for its current user base. I recall that @gcolvin mentioned this at the Council of Prague. There have been generations of new features added to x86, as well as advances made to the PC platform at which it was the center. How did the designers ensure that backwards compatibility given all of those evolving parts? As an example of the dedication to backwards compatibility as so much has moved forward in the PC platform, only now is the PC BIOS being removed!    Ars Technica    The PC BIOS will be killed off by 2020 as Intel plans move to pure UEFI The ability to boot DOS and other legacy relics is going to disappear.      ",
                    "links": [
                        "https://arstechnica.com/gadgets/2017/11/intel-to-kill-off-the-last-vestiges-of-the-ancient-pc-bios-by-2020/"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.019194925444925
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "6",
                    "likes": "0",
                    "time": "16/01/2019-17:50:52",
                    "content": "    lrettig:  We always have the option of increasing the block gas limit rather than lowering the gas cost,   Do you think there will be no need to tune single opcode\u2019s cost in the future even if the hardware will change significant? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.505952380952381
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "7",
                    "likes": "5",
                    "time": "16/01/2019-18:51:09",
                    "content": "In general I\u2019m strongly in agreement. A large part of the point of using a blockchain like Ethereum is certainty about your code\u2019s execution, and it\u2019s crucial we retain that if we want Ethereum to be useful. I think that we\u2019re benefiting from a lot of hindsight bias here, though. Before this behaviour was discovered, nobody considered reducing the gas cost of SSTORE a potentially breaking change; reducing a cost is less likely to cause problems with contract execution than increasing it. I don\u2019t think it\u2019s reasonable to require a new opcode for every change, when the only difference between the two is that the new one is that it\u2019s more gas-efficient. I also don\u2019t  think it\u2019s practical - if we do this we will run out of opcodes very quickly. Versioning seems like a more practical approach, but will likely require consensus-level changes in order to function. On the other hand, it will also open the door to EWASM, which would require some kind of versioning anyway. ",
                    "links": [
                        "https://ethereum-magicians.org/t/evm-instruction-set-versioning/2286/3"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.845266575529733
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "8",
                    "likes": "2",
                    "time": "16/01/2019-22:38:20",
                    "content": "    Arachnid:  Versioning seems like a more practical approach, but will likely require consensus-level changes in order to function.       lrettig:  Introducing an \u201cEVM version\u201d flag to deployed code (like a solidity pragma ) so that a developer knows that their code will always target a particular version of EVM   I think the \u201cEVM version\u201d should not be embedded into deployed code, but be a function of block number of the particular chain. Nevertheless I can\u2019t understand how it could help in the ERC-1283 case. Consider an a victim contract (V) was deployed at the age of EVM_v1 with the assumption about re-entrance safety of the transfermethod. Then we deploy an EVM_v2 and the attacker deploys his contract (A), sticking to  EVM_v2. The victim code get executed in EVM_v1, the attacker code - EVM_v2 (with cheap SSTORE). I see no change to current buggy behavior. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.677083333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "9",
                    "likes": "0",
                    "time": "17/01/2019-01:39:48",
                    "content": "    Ethernian:  I think the \u201cEVM version\u201d should not be embedded into deployed code, but be a function of block number of the particular chain.   Why?     Ethernian:  Nevertheless I can\u2019t understand how it could help in the ERC-1283 case. Consider an a victim contract (V) was deployed at the age of EVM_v1 with the assumption about re-entrance safety of the transfer method. Then we deploy an EVM_v2 and the attacker deploys his contract (A), sticking to EVM_v2. The victim code get executed in EVM_v1, the attacker code - EVM_v2 (with cheap SSTORE). I see no change to current buggy behavior.   That\u2019s a good point. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.930555555555555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "10",
                    "likes": "1",
                    "time": "17/01/2019-01:47:09",
                    "content": "    Arachnid:   I think the \u201cEVM version\u201d should not be embedded into deployed code, but be a function of block number of the particular chain.  Why?   because it does not belongs to  I can deploy the same code to different chains with different EVM versions inside. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.208333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "11",
                    "likes": "0",
                    "time": "17/01/2019-01:54:04",
                    "content": "    Arachnid:   The victim code get executed in EVM_v1, the attacker code - EVM_v2 (with cheap SSTORE). I see no change to current buggy behavior.  That\u2019s a good point.   hmm\u2026 may be I am wrong\u2026 It is too late\u2026 May be the applicable rule set (EVM_v1 or EVM_2) should depends on which storage is accessed (which exactly means \u201cthe code gets executed\u201d). hmm\u2026 If we assume that the (V) Victim should store anything in own storage, then it is ok: he has EVM_v1 and \u201cexpensive\u201d SSTORE. The reentrance attack using transfer call will fail. But what if it depends on some critical state stored in some EVM_v2 contract, that an attacker could manipulate cheep? Then the attack will succeed. Then we need indeed a possibility to define a target EVM for a contract we deploying. Oh\u2026 it gets complicated  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.590909090909091
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "12",
                    "likes": "4",
                    "time": "17/01/2019-05:21:59",
                    "content": "Two really random thoughts:  The gas limit on transfer was a poor precedent to set as it created a bad development practice that can be easily violated in an otherwise innocent change like this. We should avoid doing subtle little hacks like this in future because they are hard to reason about. It would instead be more beneficial if transfer literally would not allow a call back directly, by somehow shutting down execution or at least disallowing a re-entrancy more directly. That\u2019s how most developers think of it in practice IMO.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.930964052287582
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rajeevgopalakrishna",
                    "index": "13",
                    "likes": "2",
                    "time": "17/01/2019-05:39:18",
                    "content": "    jpitts:  There have been generations of new features added to x86, as well as advances made to the PC platform at which it was the center. How did the designers ensure that backwards compatibility given all of those evolving parts?   Having worked at Intel for a few years, I observed that backward-compatibility was always a top-priority, very challenging and time-consuming to get right. As @lrettig points out, it is an explicit/implicit social contract with your developers/users, and in this case, fundamental to the immutability (of behaviour) guarantee. This aspect may have been critical to the wide-spread adoption of x86 architecture because one can always buy the next generation processor with full confidence that the software they use/wrote (from n years ago) will continue to function as before. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.641895141895141
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rajeevgopalakrishna",
                    "index": "14",
                    "likes": "0",
                    "time": "17/01/2019-06:55:15",
                    "content": "    fubuloubu:  It would instead be more beneficial if transfer literally would not allow a call back directly, by somehow shutting down execution or at least disallowing a re-entrancy more directly. That\u2019s how most developers think of it in practice IMO.   This is similar to what was suggested in EIP-1283 Incident Report that we should consider introducing a contract-level reentrancy-/recursion-free CALL opcode. This could allow value transfers and state modifications (unlike STATICCALL) but prevent a contract-level indirect recursion. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.6913580246913575
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "15",
                    "likes": "0",
                    "time": "17/01/2019-08:10:46",
                    "content": "    rajeevgopalakrishna:  This is similar to what was suggested in EIP-1283 Incident Report that we should consider introducing a contract-level reentrancy-/recursion-free CALL opcode. This could allow value transfers and state modifications (unlike STATICCALL ) but prevent a contract-level indirect recursion.   I still think this is a bad idea. Preventing function-level recursion could be a useful thing to do, but preventing contract level recursion is far too blunt a tool. There are lots of cases where calling one\u2019s caller is a useful thing to do, and next to no workaround for those cases if it\u2019s prohibited. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rajeevgopalakrishna",
                    "index": "16",
                    "likes": "0",
                    "time": "17/01/2019-08:27:54",
                    "content": "    Arachnid:  There are lots of cases where calling one\u2019s caller is a useful thing to do, and next to no workaround for those cases if it\u2019s prohibited.   I see. Given that STATICCALL should already reduce the reentrancy attack surface, introducing a variant of it that allows value transfers (for transfer/send) and only LOG opcodes in fallback functions seems too specific, wouldn\u2019t it? This is essentially the second proposal listed here I suppose. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rajeevgopalakrishna",
                    "index": "17",
                    "likes": "1",
                    "time": "17/01/2019-09:11:33",
                    "content": "    Ethernian:  The victim code get executed in EVM_v1, the attacker code - EVM_v2 (with cheap SSTORE). I see no change to current buggy behavior.   In the example contract illustrated by ChainSecurity, the dirty/cheaper SSTORE is executed by the victim\u2019s contract (in updateSplit) when called by the attacker contract\u2019s fallback function. So, even though the attacker contract is in EVM_v2 context, when it makes a call to the victim contract, the context should change to EVM_v1 (assuming victim contract was deployed with EVM_v1 i.e. without EIP-1283) and the legacy SSTORE will fail with OOG. The attacker shouldn\u2019t be able to force the victim contract to execute in the newer post-EIP-1283 EVM_v2 context. What am I missing?     Arachnid:  Versioning seems like a more practical approach, but will likely require consensus-level changes in order to function. On the other hand, it will also open the door to EWASM, which would require some kind of versioning anyway.   What do we mean by \u201cconsensus-level changes in order to function\u201d? If anyone is planning to work on this EVM versioning proposal, I will be interested in contributing.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.25390625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "18",
                    "likes": "0",
                    "time": "17/01/2019-10:18:33",
                    "content": "    rajeevgopalakrishna:  So, even though the attacker contract is in EVM_v2 context, when it makes a call to the victim contract, the context should change to EVM_v1 //\u2026// and the legacy SSTORE will fail with OOG. //\u2026// What am I missing?   Yes, you are right. Although for pure re-entrance only. In general the Victim can depend on other contract\u2019s storage and if it is in EVM_v2 scope, we have a problem. We will need a possibility to enforce the target EVM version on deployment. But if there many Victims in different EVMs depending on shared storage, accessible by Attacker, it will be a version conflict\u2026 ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.1875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rajeevgopalakrishna",
                    "index": "19",
                    "likes": "3",
                    "time": "17/01/2019-10:42:32",
                    "content": "Versioning, in general, will be tricky to design and enforce I suspect. But if we would like to update existing developer-exposed interfaces/semantics without sacrificing backwards-compatibility, then the options are to (1) offer new interfaces for updated semantics (i.e. via new opcodes) or (2) update semantics of existing interfaces (i.e. new opcode behaviour) but provide a versioning system to allow developers to bind their code to specific semantics. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.459090909090909
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "20",
                    "likes": "0",
                    "time": "17/01/2019-11:33:56",
                    "content": "    rajeevgopalakrishna:  This is similar to what was suggested in EIP-1283 Incident Report that we should consider introducing a contract-level reentrancy-/recursion-free CALL opcode.   disagree. Devs should create an re-entrance lock at the particular \u201centrance\u201d, not at particular \u201cexit\u201d (call). At the \u201centrance\u201d we know the function we would like to guard. Behind the \u201cexit\u201d it depends on callee and unknown to deployment time of caller\u2019s contract. We should publicly promote an explicit re-entrance lock usage. Assumption about reentrant behavior of other constructs, that were not developed as a re-entrancy lock, should be strongly discouraged. Devs must use a lock on a function if there is something to guard and there is a call to other contract inside. @fubuloubu, would you agree on the statement above? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.984848484848484
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "21",
                    "likes": "1",
                    "time": "17/01/2019-14:41:06",
                    "content": "For Vyper, we\u2019ve discussed adding function-level recursion locks that would attempt and prevent mutal recursion between a set of contracts, but it would involve a lot of overhead and be too complex as to open a lot of attack surface in practice I think. I really like the proposal of adding a callback-safe transfer opcode because it allows the developer an additional option to explicitly reduce their attack surface so they can protect themselves if a particular protocol would have safety issues that need to be protected. Re-entrancy is probably one of the most complex bugs possible with smart contracts, and I think giving protocol-level tools to protect against unintended behaviors is important to provide as it will actually mitigate the problem instead of band-aiding it as the 2300 gas stipend does. This \u201ccallback-safe\u201d version of transfer could allow STATICCALLs back but no mutating function calls. This might also be more broadly useful as an a method of calling, something like FINALCALL that does not allow mutating calls to itself after the call is forwarded e.g. \u201cI don\u2019t care what you do with this, but don\u2019t come crawling back to me with it because I won\u2019t be listening\u201d. I do agree with @Arachnid that this starts to break the \u201ccomposable\u201d behavior that developers tend to tout of Ethereum smart contracts, but it\u2019s a trade of interoperability for safety that I think would be very helpful to developers. I\u2019ll caveat all of the above with \u201cI am not a VM expert, and this all could be very difficult to design\u201d. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.401455026455027
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "22",
                    "likes": "2",
                    "time": "17/01/2019-17:43:31",
                    "content": "    rajeevgopalakrishna:  it is an explicit/implicit social contract with your developers/users, and in this case, fundamental to the immutability (of behaviour) guarantee   The backwards compatibility of x86 is a helpful example, and I\u2019m thankful that @jpitts brought it up. I\u2019ve heard @gcolvin speak about this before as well. But lest we compare ourselves too closely to Intel, I just want to point out a glaring difference: ours is an adversarial environment where the attacker can see, and execute, code on our \u201cmachine\u201d at will. For this reason I think we should adopt a different set of principles and priorities in our design, and safety should be an even higher priority for us. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.472222222222223
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "23",
                    "likes": "1",
                    "time": "17/01/2019-17:46:38",
                    "content": "The honest answer to your question is that IMHO we should not have just one kind of \u201cgas.\u201d It should be multi-dimensional, and we should try to more accurately reflect the orthogonal costs of bandwidth, storage, compute, etc. I fear that monolithic gas is too great an abstraction for a functional, safe, efficient machine. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "None",
                        "None",
                        "None"
                    ],
                    "Sentiment": 7.833333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "24",
                    "likes": "0",
                    "time": "17/01/2019-17:55:37",
                    "content": " Before this behaviour was discovered, nobody considered reducing the gas cost of SSTORE a potentially breaking change; reducing a cost is less likely to cause problems with contract execution than increasing it  What this issue taught us (yes, with the benefit of hindsight) is that even something as seemingly benign as reducing the gas cost of an opcode can have unintended knock-on effects that violate perceived \u201cinvariants.\u201d Unless someone can generate some sort of formal proof that reducing gas costs in the future cannot have this effect, then I\u2019m afraid we are stuck. We had months to evaluate this EIP and prepare for this hard fork and many intelligent people missed this potential issue, and the same could happen with any future change of this sort. And that\u2019s just for reductions in gas cost - what about for other types of changes? It seems to me that, fundamentally, we are faced with a stark choice between the following:  Violate this \u201ctacit social contract\u201d (as I am referring to it) and accept whatever may come of that, including hacks and breakage, or Do not make changes to existing opcodes, no matter how benign   Versioning seems like a more practical approach, but will likely require consensus-level changes in order to function. On the other hand, it will also open the door to EWASM, which would require some kind of versioning anyway  Yes, this is promising and we need to give this more thought, but you\u2019re right that it\u2019s necessary for Ewasm anyway and it\u2019s something we\u2019ve begun to explore. We can continue that conversation here. In general I think we should not attempt to reinvent the wheel and should take as much as we can from existing package management systems such as npm, yarn, cargo, etc. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.367984693877551
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "25",
                    "likes": "0",
                    "time": "17/01/2019-18:26:03",
                    "content": "    lrettig:  It should be multi-dimensional, and we should try to more accurately reflect the orthogonal costs of bandwidth, storage, compute, etc.   I can understand your point about multi-dimensional gas if you are talking about opcodes sampling. Yes, the sampled gas cost for some opcode is a \u201csum\u201d of  \u201corthogonal costs of bandwidth, storage, compute, etc\u201d. But once the \u201ccombined\u201d gas cost is sampled into single number, I don\u2019t see any reason for user to split it back into dimensions. Multi-dimensional gas should imply multidimensional gas price, but I don\u2019t see who will need it.  What should a user express by setting a network gas price higher than computational gas price? Unclear to me. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.078571428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "26",
                    "likes": "1",
                    "time": "17/01/2019-18:39:32",
                    "content": "@lrettig, shouldn\u2019t we better extend the topic to \u201cImmutables, invariants and upgradability\u201d? Objects are: smart contracts, EVM and social contract around it. currently we have it fragmented:  there are works on contract upgradability, there are discussions on EVM upgradability, social contract upgrades (like gas cost changes) are even not in discussion yet  I think all this stuff is in the same domain and tightly coupled. It is really worth of thoughtful research and specification. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.723544973544974
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "27",
                    "likes": "0",
                    "time": "17/01/2019-18:44:10",
                    "content": "Back to your original question:  Do you think there will be no need to tune single opcode\u2019s cost in the future even if the hardware will change significant?  You\u2019re right that multidimensional gas cost does not really help address this question. I think, yes, we probably do want to/need to be able to tune an opcode\u2019s gas cost in the future. There are two ways we could tune:  Up, in case it\u2019s too low, which would probably only happen to mitigate a DoS attack, which I would consider an emergency, and which in any case would definitely not increase the risk of re-entrancy Down, in which case we might introduce a new, cheaper version of the opcode, or alternatively a new EVM version with a cheaper opcode  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.493819143819144
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "28",
                    "likes": "0",
                    "time": "17/01/2019-18:44:56",
                    "content": "Agree, good point, will update the subject ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "29",
                    "likes": "0",
                    "time": "17/01/2019-18:47:24",
                    "content": "    fubuloubu:  For Vyper, we\u2019ve discussed adding function-level recursion locks that would attempt and prevent mutal recursion between a set of contracts, but it would involve a lot of overhead and be too complex as to open a lot   I meant re-entrance locks. Unsure whether you mean the same with recursion locks. Re-entrance locks are simple and intuitive in solidity, although quite expensive (exact this issue was targeted by EIP-1283). I am wondering what do you mean by \u201ctoo complex / a lot of overhead\u201d in Viper exactly? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 4.387499999999999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "30",
                    "likes": "1",
                    "time": "17/01/2019-18:57:36",
                    "content": "Copying over some relevant posts on this topic from the other thread:    Remediations for EIP-1283 reentrancy bug   One more (much technically challenging) solution would be to assign EVM version and gas prices to contracts at deployment. That means, that smart contract that is deployed before the hard fork is always executed with old gas prices (and old features of EVM). So, we will have EVM0 (pre Constantinople) and EVM1 (Constantinople). When a new contract (running EVM1) calls anything that is deployed before that, EVM1 communicates to EVM0, and the old contract will use old gas prices and old assumptions will stay the same. This communication isn\u2019t trivial, but since contracts have very specific interfaces it is not impossible. Cons:  more complicated codebase and testing; more complicated contract interaction; bloating codebase with any hardforks;  Pros:  contracts that are already deployed aways will stay the same and behave the same; incentive for those who can to upgrade their contracts to the new version because cheaper gas, etc.  I still think that this might solve the whole class of problems like that and might be worth it in the long run because the contracts behaviour would be truly immutable.      Remediations for EIP-1283 reentrancy bug    So, we will have EVM0 (pre Constantinople) and EVM1 (Constantinople). When a new contract (running EVM1) calls anything that is deployed before that, EVM1 communicates to EVM0, and the old contract will use old gas prices and old assumptions will stay the same. This communication isn\u2019t trivial, but since contracts have very specific interfaces it is not impossible.  This is a reasonable idea - I\u2019ll add it to the list. The main barrier is that it will require either a new consensus field for accounts, or some other means of communicating EVM versioning. It\u2019s worth noting that this doesn\u2019t require two entirely separate EVMs, just some context that gets passed around for the current execution environment. Nodes already need most of this functionality to handle previous hard forks that have changed execution rules. One way to handle this would be to introduce a new opcode, along these lines:  VERSION : Pops one element from the stack and changes the execution environment to the specified version. Clears stack and local memory before handing control to the new version, which begins executing at the next PC value.  Each new contract would then start with a prologue along the lines of PUSH 1 VERSION to enable the new EVM. This avoids the need to introduce new consensus data structures. This can even be used for a transition to Web Assembly; contracts would just start with a prologue that switches the execution environment to EWASM. Alternately, this could be a pseudo-opcode that\u2019s only valid at the start of a contract, for simplicity reasons.      Remediations for EIP-1283 reentrancy bug   Very well articulated. IMO, this is very similar to challenges faced by microprocessor companies when introducing or modifying architectural features. The underlying micro-architecture can/will change to improve performance/power but existing architectural interfaces/semantics will remain the same or are enhanced with new features via new opcodes. Backward-compatibility and Interoperability are social contracts with developers/users. This may be viewed as legacy baggage but guarantees that code running on one processor will have the same behaviour on any future processor.      Remediations for EIP-1283 reentrancy bug   Versioning might get complicated but don\u2019t see how we can avoid it. Either we version the opcodes i.e. SSTORE, SSTORE2 (similar to CREATE, CREATE2) and run the risk of exhausting one-byte opcodes forcing us to go multi-byte and variable-length opcodes, or we version the EVM semantics. EVM versioning gives the most flexibility IMO.   CC @mandrigin, @Arachnid, @rajeevgopalakrishna ",
                    "links": [
                        "https://ethereum-magicians.org/t/remediations-for-eip-1283-reentrancy-bug/2434/55",
                        "https://ethereum-magicians.org/t/remediations-for-eip-1283-reentrancy-bug/2434/57",
                        "https://ethereum-magicians.org/t/remediations-for-eip-1283-reentrancy-bug/2434/58",
                        "https://ethereum-magicians.org/t/remediations-for-eip-1283-reentrancy-bug/2434/60"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.399281934996221
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/veox",
                    "index": "31",
                    "likes": "2",
                    "time": "17/01/2019-19:20:31",
                    "content": "    lrettig:  If we move forward with state rent or a similar solution, can it be done without changing the behavior of deployed code?   No. It introduces a condition without considering which nearly all currently-deployed contracts were written. This is exactly against opposite the rest of your post. Operation of all contracts will have to be re-considered, and many (most?) will need to be rewritten, to answer a new question: \u201cWho pays the rent?\u201d Either this, or some form of special-casing is introduced for \u201cpre-rent\u201d contracts; this increases system complexity a little, and incentivises \u201cstate hoarding\u201d up until the feature is enabled (like described in this post). The latter can (probably) be worked around, but then it increases complexity greatly.  The problem is, we can\u2019t reasonably expect both decentralisation and pay-once general storage. Sharding (at best) delays this, and (at worst) allows a much more rapid growth. Personally, I would much rather see exodus from the (future) Ethereum 1.x shard into rent-enabled shards, rather than the same free-for-all. At least if we\u2019re to expect people to run PoS-enabled clients on their laptops. (Replace \u201cshard\u201d with \u201cside-chain\u201d if needed.) Whether rent should be enabled on 1.x is (still) an open question, IMO. But it should be, eventually, somewhere. [All] costs should be internalised, otherwise the protocol will suffer a \u201ctragedy of the commons\u201d. ",
                    "links": [
                        "https://ethereum-magicians.org/t/state-rent-proposal-update-and-dark-rent-markets/2202",
                        "https://ethresear.ch/t/internalise-costs-storage-and-bandwidth/1431"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party or author wants to collaborate on proposal"
                    ],
                    "Sentiment": 5.654491341991342
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "32",
                    "likes": "1",
                    "time": "17/01/2019-19:22:14",
                    "content": "Same thing. I call it a \u201cmutal recursion\u201d issue since we protect against recursion internally (a Vyper contract cannot recursively call itself) We were brainstorming a way to do it behind the scenes, basically some sort of bloom filter mechanism that would be efficient enough in practice (1 word per contract). Decided against it. The alternative is to track the call addresses explicitly per call, which would be very expensive. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 3.95
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "33",
                    "likes": "0",
                    "time": "17/01/2019-19:24:02",
                    "content": "Technical note: Could they be EVM0.1, EVM1.0, EVM1.1, etc? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "34",
                    "likes": "1",
                    "time": "17/01/2019-19:48:25",
                    "content": "Those already exist: https://github.com/ethereum/py-evm/tree/master/eth/vm/forks ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jpitts",
                    "index": "35",
                    "likes": "2",
                    "time": "17/01/2019-20:04:55",
                    "content": "It is true that a key idea of first principles thinking is to not reason based on analogy. Different principles and priorities must be applied given that this is on a live network and all operations are costed out. Still, it is important to learn from how the PC and other platforms evolved, what principles they adopted for upgradability, and how they survived against competing ecosystems. Every platform I have developed for or deployed, and every device we use, has defined certain known points of stability over time, but eventually most apps will break\u2026 because the platform must move forward or die. The saving grace is being able to quickly understand the context in which an app is running, breaking, potentially becoming insecure if deployed on a newer version of the platform. In \u201ctech talks\u201d, conferences, network upgrades, and in this upgradability discussion, I sense that we are getting beyond copying industry and into understanding why they do what they do. What industry players to do maintain stability for their developers:  Maintain an up-to-date specification that captures the current, full system. Clearly number & describe the milestone releases and the updates within those releases. Delineate the key parts of the system, their versions, and how they fit together into a milestone release of the platform. Use concise language for the categories of expected behavior for developers deploying apps targeting a certain milestone release (microprocessors and other hardware developers call them \u201cseries\u201d). A release isn\u2019t just a set of new features described in specs.  Point to implications, areas of risk due to other parts of the platform changing for developers in a given milestone release Clearly describe policies around \u201cwhat is supported\u201d e.g. TLS, STS. We must find a way to position this social contract in our decentralized situation, and establish what should and can feasibly be guaranteed.   Are there other ways of \u201cplatforms communicating with their devs\u201d that I am missing? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.540494227994229
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "36",
                    "likes": "0",
                    "time": "17/01/2019-20:48:38",
                    "content": "    fubuloubu:  basically some sort of bloom filter \u2026 The alternative is to track the call addresses explicitly per call,   Why you haven\u2019t used locks in storage like in solidity? Are we talking about locks programmable by devs or built-in locks provided by language to any function? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "37",
                    "likes": "0",
                    "time": "17/01/2019-21:28:09",
                    "content": "Built-in. I wasn\u2019t aware they existed in Solidity, but I would hesitate to add the complexity. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "38",
                    "likes": "1",
                    "time": "17/01/2019-23:07:17",
                    "content": "    fubuloubu:  I wasn\u2019t aware they existed in Solidity   Re-entrance locks exist in Solidity as a pattern (modifier), not as a built-in feature. Nevertheless quite simple and easy to use. For example, this one. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "None of the topics listed match."
                    ],
                    "Sentiment": 6.138888888888889
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "39",
                    "likes": "0",
                    "time": "17/01/2019-23:25:22",
                    "content": "Ah, that\u2019s what I thought. We were proposing it as a feature. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "40",
                    "likes": "2",
                    "time": "18/01/2019-02:25:37",
                    "content": "    rajeevgopalakrishna:  What do we mean by \u201cconsensus-level changes in order to function\u201d?   Sorry, this wasn\u2019t really a very clear description from me. What I meant to say is that it would likely require a change to consensus data structures (specifically, the accounts struct) to record the version. The version opcode I was referring to would avoid the need for that, though.     Ethernian:  In general the Victim can depend on other contract\u2019s storage and if it is in EVM_v2 scope, we have a problem.   Can you give an example? RE locks, personally I believe these are a code smell; I\u2019ve yet to see a contract designed with locks that couldn\u2019t be rewritten to be safe without them. I really think they\u2019re a bandaid developers will use to avoid having to reason about how their code works properly, and will encourage bad development practice. That said, 1283 would have made them more affordable to use. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 4.872115384615385
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jochem-brouwer",
                    "index": "41",
                    "likes": "0",
                    "time": "18/01/2019-17:29:40",
                    "content": "    Remediations for EIP-1283 reentrancy bug EIPs       I find this a really interesting point to discuss on the \u201cethical\u201d side of forks.  The fork is now delayed because this introduces reentrancies into contracts and some of them have been found. The main reason I think for the delay is because most smart contract writers have assumed that send/transfer guards against reentrancies while actually this is not a feature of them: it is just that on the current network it is indeed not possible. Because most developers were \u201ceducated\u201d this way we can a\u2026     This might have belonged here better. My main point of this post is discussing what we find OK and what not. I can create a contract which changes behavior if an unoccupied opcode in the past is occupied at a fork. Do we now assign all these opcodes as INVALID because a single contract suddenly changes behavior? Probably not. But what if there is 10% of all Ether in it? Can I hold the network hostage against forks via this? Constantinople is delayed because possibly many contracts are affected. But what is the minimum amount of affection a fork may have to delay the fork? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.075396825396825
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "42",
                    "likes": "0",
                    "time": "19/01/2019-02:45:41",
                    "content": "    Arachnid:      ethernian:  In general the Victim can depend on other contract\u2019s storage and if it is in EVM_v2 scope, we have a problem.   Can you give an example?   @Arachnid, let me provide just a quick idea. Consider PaymentSharer example provided by ChainSecurity. But instead of using it directly, lets create a new GeneralProxy to the initially deployed PaymentSharer instead of redeploying it. Proxy will reuse its logic (EVM_v1), but with own storage (EVM_v2) with cheap SSTORE. Moreover, a more complex dispatching Proxy can redirect to different contracts deployed to different EVM versions. In which EVM version should Proxy operate? May be we will have similar challenges using libraries. I like the idea of EVM versioning, but it requires caution design through all the edge cases. ",
                    "links": [
                        "https://github.com/ethereum/remix-workshops/blob/master/proxyContractAwardToken/GenericProxy.sol"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.578463203463203
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/esaulpaugh",
                    "index": "43",
                    "likes": "0",
                    "time": "19/01/2019-04:50:20",
                    "content": "It\u2019s hard to talk about immutability in a vacuum. While I look forward to Eth 2.0 being a fresh start, eventually that too will become bogged down with technical debt. There was some talk maybe a year ago about a multi-tiered system to satisfy both the risk-tolerant and the risk-averse (whether it\u2019s different rules for different shards or something else). Of course this brings additional complexity, of which there\u2019s already no shortage. I still find it profoundly stupid to consider gas cost invariant (and judging by how little code this pricing change broke, maybe most developers agree?). Hardware and expenses associated with hardware change every year and as a result so do the relative costs of memory vs CPU vs storage usage. Maybe language tools can do more to prevent us from relying on gas cost for program behavior. I wish information about gas was completely inaccessible to contracts so that they would be unable to branch on it. I don\u2019t want my program doing different things based on how much power it\u2019s getting from the wall. It should either have enough gas to complete or not. Ideally gas costs should be market-driven in real time and I hope there\u2019s a way to get there eventually. I was hoping that this year Ethereum would scale 10x in terms of ops/s. It seems increasingly unlikely given how seriously we treat de facto invariants such as gas cost and how every time we fork/upgrade it\u2019s like we\u2019re defusing a nuclear weapon. Like everyone else, I want to have my cake and eat it too. Maybe this means focusing on Layer 2. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.682002314814815
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "44",
                    "likes": "2",
                    "time": "19/01/2019-14:47:58",
                    "content": "    lrettig:  The backwards compatibility of x86 is a helpful example, and I\u2019m thankful that @jpitts brought it up. I\u2019ve heard @gcolvin speak about this before as well. But lest we compare ourselves too closely to Intel, I just want to point out a glaring difference: ours is an adversarial environment where the attacker can see, and execute, code on our \u201cmachine\u201d at will. For this reason I think we should adopt a different set of principles and priorities in our design, and safety should be an even higher priority for us.   CPUs live in an adversarial environment as well.  Bugs in their chips can break an unknowable number of programs and open an unknowable number of security holes.  So adversaries are always looking for bugs.  And as @jpitts @rajeevgopalakrishna point out, Intel takes backwards compatibility seriously.  \u201cWe put the backwards in backwards-compatible.\u201d  The architecture of the original Intel hand calculator is still visible in their current chips, and the code for it still runs. Whether gas should be immutable shouldn\u2019t be a difficult question.  That hand calculator had performance limits that are far below current chips.  Should current chips be purposely hobbled to match it? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.012741046831955
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "45",
                    "likes": "0",
                    "time": "19/01/2019-15:41:21",
                    "content": "    esaulpaugh:  I still find it profoundly stupid to consider gas cost invariant   Just to be clear, I\u2019m not suggesting it be invariant, just that, if we lower the gas cost of an opcode, we do it by introducing a new, cheaper version of the opcode. Or we use engine versioning, as discussed here (I like @arachnid\u2019s proposal)\u2013they achieve the same thing wrt gas pricing. Or maybe we need to think outside the box more and introduce multiple tiers, as you suggest\u2013these could be shards, or they could even be at layer two. There\u2019s something elegant about the idea of shards running different engine versions, since it could provide an economic incentive (cheaper gas) for developers to migrate contracts from older shards to newer ones. This is a step towards gas costs being market-driven as you suggest. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.365013774104684
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "46",
                    "likes": "0",
                    "time": "22/01/2019-13:31:07",
                    "content": "Guys, I think it is quite important topic worth of discussion at Magicians Council in Paris. Who is interested to join the conversation there? Please raise your hand. In order to get a time slot, we need to present enough people interested in the discussion. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party or author wants to collaborate on proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "47",
                    "likes": "0",
                    "time": "22/01/2019-17:23:23",
                    "content": "    Ethernian:  Who is interested to join the conversation there?   Me, obviously haha!  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "48",
                    "likes": "0",
                    "time": "22/01/2019-23:38:45",
                    "content": "    Arachnid:  RE locks, personally I believe these are a code smell; I\u2019ve yet to see a contract designed with locks that couldn\u2019t be rewritten to be safe without them.   really? Wow! I have heavily used re-entrance locks protecting functions in case of even smallest possibility for re-entrance. Tried to avoid any assumptions about external code execution. What is your suggestion or pattern? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.425
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "49",
                    "likes": "4",
                    "time": "22/01/2019-23:43:20",
                    "content": "    Ethernian:  What is your suggestion or pattern?   Call external code after making all state changes when practical. When not, determine what your invariants are, and ensure they always hold any time you call out to external code. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "50",
                    "likes": "1",
                    "time": "23/01/2019-09:07:51",
                    "content": "    lrettig:  I\u2019m not suggesting it be invariant, just that, if we lower the gas cost of an opcode, we do it by introducing a new, cheaper version of the opcode.   I don\u2019t think the problem is that lowering (or changing) costs is dangerous per se. The EIP-1283 bug involved subtle assumptions about specific gas costs that were commonly used for a particular purpose.  I actually don\u2019t expect there are very many of those, and  lots of other programs could be written whose behavior would change if certain gas costs got lower with no complaints at all\u2013they would just be able to do more of what they do before running out of gas.  Which is the whole idea of gas. So, adding the complexity and working out out all the edge cases of a new versioning, tiering system or context passing system, or of offering up whole new sets of replacement opcodes, (e.g. all of the arithmetic opcodes) before we can change the gas cost of opcodes that are overpriced?  That all sounds like jumping out of the frying pan and into the fire. We need to do some sort of versioning at some point, but not so that programs can learn which gas price regime they are running under.  I think it just needs to be made clear that gas prices are subject to change without notice. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.393067580567581
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "51",
                    "likes": "1",
                    "time": "23/01/2019-09:12:28",
                    "content": "    gcolvin:  I think it just needs to be made clear that gas prices are subject to change without notice.   I totally agree. Also, there\u2019s a historic precedent to this, so people/code should not make assumptions about particular gas costs. Doing so means that the dev has gone off the trail, like doing some evm experimentation with assembly. If, OTOH, we find that solidity has some implicit assumptions about gascost, then we should try to respect that (IIRC, there were some early assumptions about the gascosts when using the IDENTITY precompile, which we had to very carefully tread around when we changed how the 63/64ths rule worked) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.05
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "52",
                    "likes": "1",
                    "time": "23/01/2019-19:47:18",
                    "content": "    gcolvin:  The EIP-1283 bug involved subtle assumptions about specific gas costs that were commonly used for a particular purpose. I actually don\u2019t expect there are very many of those   This is probably the best take. The problem wasn\u2019t that lowering the gas cost broke a user assumption. The problem is that assumption was there in the first place. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.895833333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lrettig",
                    "index": "53",
                    "likes": "1",
                    "time": "23/01/2019-23:05:30",
                    "content": "Right, but where do we draw the line going forward? Are we comfortable changing gas costs? Then why weren\u2019t we comfortable doing it in this case and how will it be different next time? How do we communicate this to developers and make sure they factor this in so that future changes don\u2019t break \u201cinvariants\u201d that they should not be relying on? ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 6.13265306122449
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "54",
                    "likes": "1",
                    "time": "23/01/2019-23:24:27",
                    "content": "A few things, I guess:  No more gas-dependant contextual changes, especially as mitigations for security issues Factor in developers and compiler peeps as a signal into EIPs that affect the development/user experience I think we\u2019re more aware now that there can be negative consequences for changing gas costs of an opcode, so\u2026 learning experience?  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "55",
                    "likes": "3",
                    "time": "23/01/2019-23:24:55",
                    "content": " Write down invariants\u2026 Somewhere  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.222222222222222
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rajeevgopalakrishna",
                    "index": "56",
                    "likes": "1",
                    "time": "24/01/2019-01:58:45",
                    "content": "Agree with the rationale expressed by @gcolvin & @holiman and the questions/suggestions from @lrettig & @fubuloubu. We cannot prevent the creativity of developers (if inline-assembly is supported by a language, it is fair game) but only anticipate them, and hence establish well documented guard-rails on invariants/assumptions and any guarantees on backward-compatibility/interoperability going forward. This is going to be even more critical with all the upcoming changes, such as ewasm. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.666666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "57",
                    "likes": "4",
                    "time": "24/01/2019-09:31:20",
                    "content": "Regarding breaking invariants, here\u2019s another example. Even since the Devcon in Mexico, I\u2019ve been trying to raise awareness of the fact that CREATE2 will break an invariant: a contract A which has code C at one point in time might have code D at another point in time. (Back then, it was another EIP but same effect). This is something that @AlexeyAkhunov also found out indedependently, despite the discussion having taken place in various places. Do contract developers know about this? It\u2019s really hard to say. Despite all the discussions, I still believe that a lot of devs aren\u2019t aware of this. It might not make any difference in 99.9% of all cases, but OTOH might make all the difference in 0.1% of the cases. My take is that we need to produce an \u2018Audit\u2019, which should be based on a common template, which focuses on things like this. That audit should be performed by people who are both evm-nerds (and I don\u2019t mean that derogatory, I count myself as one) and also know contract-development. The audit should be commissioned as soon as an EIP is accepted, and when done, it should be stored in the EIP repository and published far and wide. Things that I would like to see in focus for such an audit would be  Invariants broken / changed, Potential edgecases that need to be handled Important testcases for edgecases Consequences for existing contracts Consequences for future contracts Potential for DoS-attacks due to this change  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.756510416666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rajeevgopalakrishna",
                    "index": "58",
                    "likes": "0",
                    "time": "24/01/2019-09:48:50",
                    "content": "    holiman:  the fact that CREATE2 will break an invariant: a contract A which has code C at one point in time might have code D at another point in time   Is this described somewhere? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "59",
                    "likes": "3",
                    "time": "24/01/2019-10:20:49",
                    "content": "    lrettig:  Are we comfortable changing gas costs? Then why weren\u2019t we comfortable doing it in this case and how will it be different next time?   We have to be comfortable changing gas costs\u2013they are parameters meant to be adjusted to match the cost of operations on current hardware. We were uncomfortable  because we had not anticipated that the precise gas stipend of 2300 would combine with assumptions about permanent gas costs to create reentrancy. locks.  And yes, I suppose we should worry about every other useful trick could one pull off that way.  A precise \u201cgas fees are subject to change\u201d in the Yellow Paper would help.  And close scrutiny of any other bare numbers in the protocol that might be relied on. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.477777777777778
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "60",
                    "likes": "2",
                    "time": "10/02/2019-23:09:32",
                    "content": "    Ethernian:  Guys, I think it is quite important topic worth of discussion at Magicians Council in Paris.   Oh, looks like I have forgot to propose the topic to Council. Sorry for that  I would submit it as: \"Immutables, invariants, and upgradability: What kind of social contract do we have to follow?\" Please  this post to signal your support. It is really important to make the discussion happen, so please do! P.S. @lrettig, I have already counted your vote. Thanks  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal"
                    ],
                    "Sentiment": 6.095238095238095
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jpitts",
                    "index": "62",
                    "likes": "4",
                    "time": "12/02/2019-02:26:13",
                    "content": "Here are the FEM and Twitter discussion about CREATE2 that is relevant to this sub-subject brought up by @rajeevgopalakrishna:     Potential security implications of CREATE2? (EIP-1014) EIPs       Not sure if this has been discussed elsewhere/before but I came across this topic today on AllCoreDevs gitter and thought it may be useful to start a thread here. Thanks to @carver and @holiman for initiating this discussion.  Summary (per my understanding so far): CREATE2 allows contracts to change in-place after being deployed. This is because, although CREATE2 includes the hash of init_code in address generation, the same init_code could intentionally generate arbitrary contract code. There a\u2026       twitter.com          M H (((Swende))) (mhswende)     Fact: after Constantinople, a contract can selfdestruct and potentially be restored with different code. (rules and conditions apply)  So YES, it can change code in-place (but no if you don't consider 2 txs timespan suddenly) https://t.co/NWAXOl0vbT  2:11 PM - 8 Feb 2019     43          13            ",
                    "links": [
                        "https://twitter.com/mhswende/status/1093995835518537728",
                        "https://twitter.com/mhswende/status/1093995835518537728",
                        "https://twitter.com/mhswende/status/1093995835518537728"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving additional information on proposal"
                    ],
                    "Sentiment": 5.295454545454545
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "63",
                    "likes": "2",
                    "time": "12/02/2019-15:55:58",
                    "content": "I have proposed the topic for Ethereum Magicians Council:  Immutables, invariants, and upgradability. What kind of social contract do we have to follow? please add yourself as participant/supporter list. It is important to get a timeslot for discussion. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal"
                    ],
                    "Sentiment": 6.722222222222221
                }
            ]
        }
    ],
    "group_index": "650"
}