{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-4804-web3-url-to-evm-call-message-translation/8300",
            "title": "EIP-4804: Web3 URL to EVM Call Message Translation ",
            "index": 8300,
            "category": [
                "EIPs"
            ],
            "tags": [
                "evm"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "1",
                    "likes": "7",
                    "time": "14/02/2022-22:11:31",
                    "content": "A translation of an HTTP-style Web3 URL to an EVM call message  Motivation Currently, reading data from Web3 generally relies on a translation done by a Web2 proxy to Web3 blockchain. The translation is mostly done by the proxies such as dApp websites/node service provider/etherscan, which are out of the control of users. The standard here aims to provide a simple way for Web2 users to directly access the content of Web3.  Moreover, this standard enables interoperability with other standards already compatible with URIs, like SVG.   github.com/ethereum/EIPs         Create EIP-4804   ethereum:master \u2190 qizhou:qizhou-4804            opened 09:18PM - 13 Apr 22 UTC               qizhou             +161 -0       When opening a pull request to submit a new EIP, please use the suggested templa\u2026te: https://github.com/ethereum/EIPs/blob/master/eip-template.md  We have a GitHub bot that automatically merges some PRs. It will merge yours immediately if certain criteria are met:   - The PR edits only existing draft PRs.  - The build passes.  - Your GitHub username or email address is listed in the 'author' header of all affected PRs, inside <triangular brackets>.  - If matching on email address, the email address is the one publicly listed on your GitHub profile.       ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/4995",
                        "https://github.com/qizhou",
                        "https://github.com/ethereum/EIPs/pull/4995/files",
                        "https://github.com/ethereum/EIPs/pull/4995"
                    ],
                    "GPT-summary": "The post introduces EIP-4804, which proposes a standard for translating Web3 URLs to EVM call messages. The proposal aims to provide a simple way for Web2 users to directly access the content of Web3 and enable interoperability with other standards compatible with URIs. The post also includes instructions for submitting a new EIP and criteria for automatic merging of pull requests. Some third-party feedback is present in the form of questions and constructive criticism.",
                    "GPT-proposal-categories": [
                        "Interoperability and Scalability",
                        "Smart contract updates",
                        "Privacy, Security and risk management",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None"
                    ],
                    "Sentiment": 5.336788211788211
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wart",
                    "index": "2",
                    "likes": "3",
                    "time": "15/02/2022-02:24:50",
                    "content": "nice proposal. and it would be greatly beneficial when eth tps improves a lot ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 8.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/liushooter",
                    "index": "3",
                    "likes": "2",
                    "time": "18/02/2022-05:04:20",
                    "content": "awsl   974\u00d7180 5.92 KB  https://web3q.io/quickcreation.w3q/LogWeb3  ",
                    "links": [
                        "https://web3q.io/quickcreation.w3q/LogWeb3"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "4",
                    "likes": "0",
                    "time": "14/04/2022-21:53:08",
                    "content": "Hey! I\u2019m pretty interested in this, would you be interested in a co-author? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "5",
                    "likes": "0",
                    "time": "14/04/2022-22:14:07",
                    "content": "Of course!  The standard is at an early stage and we welcome any contribution from the community. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "6",
                    "likes": "1",
                    "time": "14/04/2022-22:29:30",
                    "content": "BTW: Nice article about on-chain PNG rendering Rendering a PNG on Ethereum: face.png - this something we are looking for and optimize for  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 8.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "7",
                    "likes": "0",
                    "time": "14/04/2022-23:51:11",
                    "content": "So a couple of non-formatting related comments:  In the motivation section, it might be nice to add something like this comment. Perhaps: interoperability with other standards already compatible with URIs, like SVG. Personally, I think the web3 term is a bit too vague/broad for us to co-opt. Maybe evm://, since we use Solidity\u2019s ABI, or just maybe just eth? The return types are strictly client-side, so perhaps using the anchor notation for that ...#uint256,(string,bytes32)? In the example web3://wusdt.eth:4->(uint256)/balanceOf/charles.eth, balanceOf doesn\u2019t match the given grammar earlier in the proposal (as far as I could tell.) How would you feel if the types were mandatory? Asking implementers to figure out how to retrieve ABI definitions might be a bit heavy.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.267857142857143
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "8",
                    "likes": "0",
                    "time": "15/04/2022-01:15:02",
                    "content": "Many thanks for your comments.  A couple of my responses:     SamWilsn:  In the motivation section, it might be nice to add something like this comment. Perhaps: interoperability with other standards already compatible with URIs, like SVG.   Nice!  I have added the sentence Moreover, this standard enables interoperability with other standards already compatible with URIs, like SVG. in the motivation part.     SamWilsn:  Personally, I think the web3 term is a bit too vague/broad for us to co-opt. Maybe evm://, since we use Solidity\u2019s ABI, or just maybe just eth?   Thanks for the comment.  I feel that eth:// may be a bit narrow because the protocol itself can support any EVM blockchains such as Polygon/BSC or even testnets.  For evm://, I feel it is a bit technical because a lot of Web2 people may not have an idea what EVM is. I have been struggling to choose the best scheme name.  I finally choose web3:// because the major goal of the protocol is to be the counterpart of http:// in Web2.  Further, given the fact that Ethereum/EVM has been the de-facto Web3 technical stack, using web3:// could strengthen the position of Ethereum/EVM in Web3 without creating confusion.  Feel free to let me know if you have other thoughts.     SamWilsn:  The return types are strictly client-side, so perhaps using the anchor notation for that ...#uint256,(string,bytes32)?   Thanks for the comment.  The hashtag will be pre-processed by the browser so that the type info may not be passed to the gateway or web extension.   If we want to process them on the client side, we need to return an HTML that processes the type info, which may be complicated.  Instead, if we could process them on server side, then the user can browse the formatted result either in browser or curl/wget or programs easily.     SamWilsn:  In the example web3://wusdt.eth:4->(uint256)/balanceOf/charles.eth, balanceOf doesn\u2019t match the given grammar earlier in the proposal (as far as I could tell.)   Thanks for the comment.  balanceOf should match method in the grammar: Web3URL = \"web3://\" [userinfo \"@\"] contractName [\":\" chainid] [\"->(\" returnTypes \")\"] path [? query] contractName = address | name \".\" nsProvider path = [\"/\" method [\"/\" argument_0 [\"/\" argument_1 ... ]]] argument = [type \"!\"] value  As the result, the protocol will call \u201cbalanceOf(address)\u201d with charles.eth's address from NS.   Please let me know if I miss anything.     SamWilsn:  How would you feel if the types were mandatory? Asking implementers to figure out how to retrieve ABI definitions might be a bit heavy.   I agree that retrieving ABI definition is not easy in this case.  Actually, mandating the types in the link still needs ABI definitions for implementers.  So the cost should be the same no matter whether the types are mandatory or not. The reason for providing auto-type detection is to make the URL as simple and natural as possible.  Further, in our current gateway implementation, we will return web3-calldata, web3-method-siganture, and web3-return-type in HTTP response headers for better debuggability.  The following is an example of https://web3q.io/wusdt.eth:4->(uint256)/balanceOf/charles.eth  ",
                    "links": [
                        "https://web3q.io/wusdt.eth:4-%3E(uint256)/balanceOf/charles.eth"
                    ],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.528356481481481
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "9",
                    "likes": "0",
                    "time": "15/04/2022-02:32:45",
                    "content": "    qizhou:  For evm://, I feel it is a bit technical because a lot of Web2 people may not have an idea what EVM is.   I would argue that http is pretty technical  I don\u2019t feel too strongly about the actual prefix though.     qizhou:  The hashtag will be pre-processed by the browser so that the type info may not be passed to the gateway or web extension. If we want to process them on the client side, we need to return an HTML that processes the type info, which may be complicated. Instead, if we could process them on server side, then the user can browse the formatted result either in browser or curl/wget or programs easily.   Is the intent to resolve the URIs through a browser? Although it\u2019s possible to return HTML directly from a contract, I don\u2019t expect that to be too normal (or gas efficient.) If the anchor is stripped before passing to a web extension, then yeah, it wouldn\u2019t make sense to put it there. The only non-binary data I\u2019m familiar with on-chain today would be NFT metadata/image data.     qizhou:  Thanks for the comment. balanceOf should match method in the grammar   Ha, can\u2019t believe I missed that\u2026 Obviously that makes sense.     qizhou:  Actually, mandating the types in the link still needs ABI definitions for implementers.   I think if you had a URI like web3://foo.eth/balanceOf/address!bar.eth that would be sufficient to call the function. Actually, you could even do web3://foo.eth/balanceOf(address):uint256/bar.eth. What am I missing? Are the types in the current EIP are there to disambiguate between overrides?  On an unrelated note:  In the second case, nsProvider will be the short name of name service providers such as \u201cens\u201d, \u201cw3q\u201d, etc.  This seems to imply that an ENS lookup would have to be web3://foo.eth.ens/... or web3://example.com.ens/...? The examples later in the EIP don\u2019t match that pattern. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.28219696969697
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "10",
                    "likes": "0",
                    "time": "15/04/2022-06:05:31",
                    "content": "    SamWilsn:  Is the intent to resolve the URIs through a browser? Although it\u2019s possible to return HTML directly from a contract, I don\u2019t expect that to be too normal (or gas efficient.) If the anchor is stripped before passing to a web extension, then yeah, it wouldn\u2019t make sense to put it there.   Thanks for the comment.  The intention is to resolve the URIs via a gateway (like ipfs.io) or a web browser extension.  The browser just passes the full Web3 URI to the gateway/extension, and the gateway/extension would have full knowledge to parse the URIs to EVM call message and format the returned data back to the browser via HTTP protocol.  This requires minimal changes on browsers so that we can use any browser (Chrome/Firefox/IE/etc) to browse Web3 URIs easily. The standard would perfectly fit into NFT metadata/image data like SVG (I am also a big fan of it  ).  Meanwhile, we are exploring other non-binary data such as dWeb or even dynamic Web page generation (decentralized social network?).  There are a lot of possibilities here enabled by Ethereum and ERC-4804!     SamWilsn:  I think if you had a URI like web3://foo.eth/balanceOf/address!bar.eth that would be sufficient to call the function. Actually, you could even do web3://foo.eth/balanceOf(address):uint256/bar.eth. What am I missing? Are the types in the current EIP are there to disambiguate between overrides?   Many thanks for the comment.  A couple of great design questions for the standard.  Let me list them one-by-one: Q1: For address from name service, should we use name type or address type? E.g.,   web3://foo.eth/balanceOf/address!bar.eth ; or  web3://foo.eth/balanceOf/name!bar.eth?  Using address type for both conventional 0x-20-bytes-hex ETH address space and name from NS should work as ETH address will never have \u201c.\u201d, but should we separate these types for better clarification? Q2: Do we need type auto-detection, i.e., do we need the simpler URI at the price of potential ambiguity?  E.g.,  web3://foo.eth/balanceOf/address!bar.eth  web3://foo.eth/balanceOf/bar.eth where the first is with mandatory type and the second\u2019s type is auto-detected.  Actually, auto-detection may coexist with manual resolve mode better.  Taking a dWeb as an example, the user may type (myhome.eth is in manual resolve mode)   web3://myhome.eth/aaa.svg,  which will pass /aaa.svg as the calldata so that the contract can display the file directly.  As a comparison, using the mandatory typed link in auto resolve mode will look like   web3://myhome.eth/showFile/string!aaa.svg which is more verbose.  Q3: If types are supplied, where to put the input argument types and return types (which can be a tuple)? E.g.,  web3://foo.eth/balanceOf(address):(uint256)/bar.eth web3://foo.eth/balanceOf(address)->(uint256)/bar.eth web3://foo.eth/balanceOf->(uint256)/address!bar.eth web3://foo.eth->(uint256)/balanceOf/address!bar.eth  I personally prefer \u201c->\u201d to prepend return types as it is clear to understand.  In addition, current standard puts \u201c->(outputTypes)\u201d after the contract name (Option 4) so that the path part of the link looks almost the same as that of the Web2 HTTP link.  Admittedly, Option 1 or 2 is closer to what current Solidity has, but seems to be incompatible with auto-detection for types.     SamWilsn:  This seems to imply that an ENS lookup would have to be web3://foo.eth.ens/... or web3://example.com.ens/...? The examples later in the EIP don\u2019t match that pattern.   Nice find!  I have changed the sentence to  In the second case, nsProviderSuffix will be the suffix from name service providers such as \u201ceth\u201d, \u201cw3q\u201d, etc.  ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.689895470383275
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "11",
                    "likes": "0",
                    "time": "15/04/2022-07:10:17",
                    "content": "    qizhou:  resolve the URIs via a gateway (like ipfs.io)   If you\u2019re using a gateway (like foo.test), I\u2019m guessing the full URL would look something like https://example.eth.foo.test/balanceOf/bar.eth#uint256? If the gateway is returning the raw data, it wouldn\u2019t be able to access the anchor\u2026 So it makes sense to put it in the path component. If we want everything to be symmetric, then it makes sense to put it in the path for extensions and direct requests too. You\u2019ve convinced me      qizhou:  Using address type for both conventional 0x-20-bytes-hex ETH address space and name from NS should work as ETH address will never have \u201c.\u201d, but should we separate these types for better clarification?   I guess the reverse question is also important: will there ever be a NS provider without a .? I have a slight preference for just using address, but that mandates a dot in the name. Small trade-off, in my opinion.     qizhou:  Q2: Do we need type auto-detection, i.e., do we need the simpler URI at the price of potential ambiguity?   I totally overlooked the section on auto-detection. I don\u2019t think the contract being queried should be able to affect the interpretation of the URI. That would mean I\u2019d need to know what mode the contract is in to correctly construct a URI, which would make autogeneration of URIs (say in on-chain SVGs) difficult. I\u2019d most prefer an explicitly typed URI, but it might be possible to make some unambiguous rules to infer types.     qizhou:  Q3: If types are supplied, where to put the input argument types and return types (which can be a tuple)?   Yeah, looking at your examples, I like -> more too. Doing name(type arg0)->(type,type) will be pretty familiar to Rust devs  I definitely don\u2019t think it should come before the first /. If it does, it looks like part of the \u201chost\u201d.     qizhou:  Admittedly, Option 1 or 2 is closer to what current Solidity has, but seems to be incompatible with auto-detection for types.   Just kinda throwing the idea out, but what if there were some implied defaults, if not specified? For example web3://foo.eth/->/aaa.svg could mean \"call a function with the signature index(string) -> (string)\".  How would you handle resolving ENS names that use DNSSEC? For example supersaiyan.xyz is a valid ENS name. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.502110208631947
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "12",
                    "likes": "0",
                    "time": "15/04/2022-09:09:28",
                    "content": "    SamWilsn:  I guess the reverse question is also important: will there ever be a NS provider without a .? I have a slight preference for just using address, but that mandates a dot in the name. Small trade-off, in my opinion.   We also had an internal discussion on which one is better, but no strong preference.  I think we could choose address now by assuming that all NS providers must have \u201c.\u201d.     SamWilsn:  I don\u2019t think the contract being queried should be able to affect the interpretation of the URI. That would mean I\u2019d need to know what mode the contract is in to correctly construct a URI, which would make autogeneration of URIs (say in on-chain SVGs) difficult.   Thanks for the comment.  I would argue a potential huge application with \u201cmanual\u201d mode for on-chain Web content generation.  To be more specific, the current standard serves two major purposes:  Purpose 1: Call a contract for JSON-formated result If the returned types are specified, the protocol will 1. call the contract; 2. get the call result in raw bytes; 3. parse the raw bytes into ABI-encoded types as specified by returned types; 4. format the ABI-encoded types to JSON and return the JSON response to the client. This can be viewed as a complement to the existing JSON-RPC protocol.  Purpose 2: Call a contract for on-chain Web content If the returned types are not specified, the protocol will assume that an on-chain web content (e.g., HTML/SVG/CSS/etc) will be returned to the client.  This is perhaps the most attractive application of the standard. My original design for this purpose comes from common gateway interface (CGI) - the famous interface for Web servers.  In CGI,  the web server allows its owner to configure which URLs should be handled by which CGI scripts.  For example, http://example.com/cgi-bin/printenv.pl/with/additional/path?and=a&query=string this will ask web server to call printenv.pl script with /with/additional/path?and=a&query=string as argument. With manual resolve mode, the smart contract can work as CGI script similar to Web2.  This brings the following unique benefits:  Support Web3 URI with HTTP-URL-style path and query, which existing Web2 users are most familiar with; Be compatible with existing HTTP-URL pathing, such as relative path.  This means a HTML/XML can reference their relative resources easily (e.g., web3://aaa.eth/a.svg referencing ./layers/0.svg will be translated to web3://aaa.eth/layers/0.svg by browser); Default web index (e.g., web3://aaa.eth/ could reference to web3://aaa.eth/index.html as configured by the contract).  I think that these features should greatly bridge the gap between Web2 users to Web3 dApps. Admittedly that the users need to know what mode the contract is in to correctly construct a URI.  However, the manual mode only works to CGI contracts that serve special web content needs, while 99+% of existing contracts are not affected.  As a result, we could safely assume that the implementers (most likely the CGI contract developers) have the full knowledge of how to interact with CGI contracts in manual model. What do you think?     SamWilsn:  Just kinda throwing the idea out, but what if there were some implied defaults, if not specified? For example web3://foo.eth/->/aaa.svg could mean \"call a function with the signature index(string) -> (string)\"   I think if we enable manual mode, the implied defaults may be implemented by the contract themselves?  Similar to setting directory index in Web servers (Web server directory index)     SamWilsn:  How would you handle resolving ENS names that use DNSSEC? For example supersaiyan.xyz is a valid ENS name.   Thanks for the comment.  Do not have a plan right now.  But we could create an extension EIP for supporting DNSSEC after finalizing this one? ",
                    "links": [
                        "https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax",
                        "https://en.wikipedia.org/wiki/Web_server_directory_index"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.78277706336217
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "13",
                    "likes": "0",
                    "time": "18/04/2022-18:35:52",
                    "content": "Some updates on EIP-4804  name type is replaced by address type add a principle to highlight that EIP-4804 should be maximum compatible with the HTTP-URL standard so that existing Web2 users can migrate to Web3 easily with minimal knowledge of this standard.  The second one is inspired by our discussion of interoperability with SVG (or more generally, any on-chain Web content), which is one of the most applications we want to support.  Please take a look.     SamWilsn:  If you\u2019re using a gateway (like foo.test), I\u2019m guessing the full URL would look something like https://example.eth.foo.test/balanceOf/bar.eth#uint256? If the gateway is returning the raw data, it wouldn\u2019t be able to access the anchor\u2026 So it makes sense to put it in the path component.   Yes, the URL may look like https://example.eth.foo.test/balanceOf/bar.eth#uint256 or https://foo.test/example.eth/balanceOf/bar.eth#uint256 where the ipfs\u2019s gateway has similar link to resolve ipfs resources.     qizhou:  Q3: If types are supplied, where to put the input argument types and return types (which can be a tuple)? E.g.,  web3://foo.eth/balanceOf(address):(uint256)/bar.eth web3://foo.eth/balanceOf(address)->(uint256)/bar.eth web3://foo.eth/balanceOf->(uint256)/address!bar.eth web3://foo.eth->(uint256)/balanceOf/address!bar.eth    Given the principle that we want to maximize compatibility with HTTP-URL, we the 5th option may be 5. web3://foo.eth/balanceOf/address!bar.eth?returnType=(uint256) which is more like a standard HTTP-URL. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.893772893772894
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "14",
                    "likes": "2",
                    "time": "25/04/2022-18:15:56",
                    "content": "An illustration of auto mode and manual mode for resolving web3 URLs  image1930\u00d7640 75.4 KB  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sbacha",
                    "index": "15",
                    "likes": "2",
                    "time": "24/05/2022-19:25:25",
                    "content": "EIP has been merged yesterday Create EIP-4804 (#4995) \u00b7 ethereum/EIPs@49fc53b \u00b7 GitHub ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/monkeyontheloose",
                    "index": "16",
                    "likes": "0",
                    "time": "26/06/2022-22:50:47",
                    "content": "hey sers, i\u2019m thinking about implementing this as a web2.0 service, would love to dm and talk about it. my telegram is @monkeyontheloose ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "17",
                    "likes": "0",
                    "time": "27/06/2022-10:22:44",
                    "content": "Hey peeps, I believe I found a similar technique and proposed it to standardize in CASA: eth_call signature combined with block number is a unique identifier \u00b7 Issue #87 \u00b7 ChainAgnostic/CAIPs \u00b7 GitHub ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.9375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "18",
                    "likes": "0",
                    "time": "27/06/2022-16:28:28",
                    "content": "Thanks for pointing this out.  Looks like there are a couple of overlaps, but it seems the target applications are quite different? E.g., ERC-4804 serves as an HTTP-style resource locator, which is designed with some unique features  MIME detection Auto-type detection to simplify the links CGI-style resolve model to allow \u201csmart contract as CGI script\u201d Do not ask for the block number (but we could add it if we really need this)  A couple of applications are  on-chain SVG generating: web3://cyberbrokers-meta.eth/renderBroker/2349  on-chain blogger (using Vitalik\u2019s as example): web3://vitalikblog.eth/   BTW: Our extension for supporting web3:// links is available at Firefox Web3Q: Fully Decentralized Web3 \u2013 Get this Extension for \ud83e\udd8a Firefox (en-US) ",
                    "links": [
                        "https://web3q.io/vitalikblog.eth/",
                        "https://addons.mozilla.org/en-US/firefox/addon/web3q/"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.1875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "19",
                    "likes": "1",
                    "time": "30/06/2022-15:52:44",
                    "content": "We discussed this proposal in today\u2019s CASA meeting:  According to RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax, the URI scheme namespace is managed by https://www.iana.org/ and so we think it is out of the scope of this proposal to use \u201cweb3://\u201d (unless you\u2019re planning to register it there or we\u2019ve missed something). As Ethereum is just one chain within \u201cweb3,\u201d we noted that a potentially better scheme identifier for this EIP would be \u201ceth://\u201d or e.g. \u201cevm://\u201d From what I understood, CASA would be happy to welcome this EIP on their side as to e.g. generalize the scheme towards \u201cweb3://\u201d (multi-chain)  ",
                    "links": [
                        "https://www.iana.org/"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 7.625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sbacha",
                    "index": "20",
                    "likes": "1",
                    "time": "01/07/2022-04:34:40",
                    "content": "Similar discussion wrt the uri identifier is being discussed by @SamWilsn and the in draft webRTC connection for web3 providers. Chrome blocks non standard uri identifiers as well ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "21",
                    "likes": "0",
                    "time": "02/07/2022-05:50:20",
                    "content": "    TimDaub:  According to RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax, the URI scheme namespace is managed by https://www.iana.org/ and so we think it is out of the scope of this proposal to use \u201cweb3://\u201d (unless you\u2019re planning to register it there or we\u2019ve missed something).   Many thanks for the information.  The assignment information is very helpful.  I just send a request for assigning web3:// schema of URI for EIP-4804 to iana and wait for their response  I will update the info if I get any response.     TimDaub:  As Ethereum is just one chain within \u201cweb3,\u201d we noted that a potentially better scheme identifier for this EIP would be \u201ceth://\u201d or e.g. \u201cevm://\u201d   Thanks for the comment.  EIP-4804 natively supports multiple EVM chains (i.e., rinkeby/kovan/arbi/optim/bsc by replacing port to chain id) so I feel using eth:// may be too narrow.  Further, one major application of EIP-4804 is to provide a web3 resource locator that can be dynamically generated on-chain, especially web resources such as SVG/HTML, therefore I feel that web3:// may better serve the purpose.     TimDaub:  From what I understood, CASA would be happy to welcome this EIP on their side as to e.g. generalize the scheme towards \u201cweb3://\u201d (multi-chain)   Many thanks for the invitation.  I am very glad to explore the applications of web3:// for non-EVM blockchains, and I am open to collaborating on the generalization and improving EIP-4804 accordingly. For the next step, one thing I would like to do is to give a presentation of the motivation, design thoughts, and applications of EIP-4804 at the next CASA meeting?  Then we could collect some consensus and move to future steps.  What do you think? ",
                    "links": [
                        "https://www.iana.org/"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party or author wants to collaborate on proposal"
                    ],
                    "Sentiment": 6.116477272727273
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "22",
                    "likes": "2",
                    "time": "06/07/2022-00:28:22",
                    "content": "Just let everyone know that we have registered web3:// URI scheme at IANA.  Anyone can find the assignment at  Uniform Resource Identifier (URI) Schemes  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/mango",
                    "index": "23",
                    "likes": "0",
                    "time": "06/07/2022-14:51:57",
                    "content": "How does gateway resolution work if I don\u2019t specify a gateway like foo.test? Is there any proof returned in the response to make sure that my gateway is not lying to me? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/high_byte",
                    "index": "24",
                    "likes": "0",
                    "time": "06/07/2022-15:49:00",
                    "content": "nice EIP. what I would suggest is to encode the entire signature at once like so: web3://.../balanceOf(address)/... since the entire canonical signature is used to encode the function selector. an error in parsing arguments (e.g. confusing bytes32/uint256, or bool/uint8/uint256 or bytes/strings, etc.) could lead to incorrect function called. if there\u2019s a fallback that behaves differently it would be unintuitive to debug. by specifying the exact function signature then you don\u2019t have ambiguities with params and can leave params out as defaults. (e.g. balanceOf(address) with no param would be balanceOf(0x0)) once you have the function 4bytes selector you can fetch the return type from a db such as 4bytes.directory. edit: if I may suggest it can be useful to pass an optional block number too, eg. in case you want to fetch balance in a previous block. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.37962962962963
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "25",
                    "likes": "0",
                    "time": "06/07/2022-16:42:16",
                    "content": "Generally, to avoid lying to the users, the browser needs to  become a light client of the blockchain (in the Ethereum PoW chain case, that means all headers, which need some time to download.) show the proof of data visited.  This is mostly the Merkle proof of the data in the state trie.  Note that asking the gateway to return these data for each web3:// request (especially all headers) may be over-burdened. To achieve a fully trustless web, one direction is to have a browser extension that  becomes a light client of the blockchain, which downloads the headers in the background (can from the gateway or p2p network); and ask the gateway to respond with the proof (or the extension itself can directly access p2p network). With the light client data, we can tell whether the gateway lies or not.  There are a lot of interesting things that need to be done, but I think the web3 URL will serve as a good starting point to enable a fully-decentralized web3! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.5249999999999995
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "26",
                    "likes": "0",
                    "time": "06/07/2022-17:30:58",
                    "content": "    high_byte:  what I would suggest is to encode the entire signature at once like so: web3://.../balanceOf(address)/... since the entire canonical signature is used to encode the function selector. an error in parsing arguments (e.g. confusing bytes32/uint256, or bool/uint8/uint256 or bytes/strings, etc.) could lead to incorrect function called. if there\u2019s a fallback that behaves differently it would be unintuitive to debug.   We have a discussion on where to put the argument types in the standard here EIP-4804: Web3 URL to EVM Call Message Translation - #13 by qizhou, where I think your suggestion is close to option 2  We have a regular URI/URL meeting every two weeks.  In the last meeting, we reached the agreement to use returnTypes attribute to specify the return types. I could include the topic of where to specify the input types in the next meeting (see here for more info URL/URI standard working group - HackMD)     high_byte:  once you have the function 4bytes selector you can fetch the return type from a db such as 4bytes.directory.   This seems to introduce the dependency on 3rd party db. I think we should avoid this because the standard is a decentralized resource locator that should not depend on any 3rd component.     high_byte:  edit: if I may suggest it can be useful to pass an optional block number too, eg. in case you want to fetch balance in a previous block.   This can be done by setting an optional block attribute in the attribute-value list.  However, we may not expect the gateway or browser to fully support it because calling a contract on a historical block requires running an archive node. ",
                    "links": [
                        "https://hackmd.io/@poojaranjan/URLWorkingGroup"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None"
                    ],
                    "Sentiment": 5.098039215686274
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "27",
                    "likes": "0",
                    "time": "07/07/2022-17:53:46",
                    "content": "Hey, I\u2019ve added the block number tag to CAIP-19:  CAIP-19: Add block number tag by TimDaub \u00b7 Pull Request #119 \u00b7 ChainAgnostic/CAIPs \u00b7 GitHub Add blockNumberTag by TimDaub \u00b7 Pull Request #25 \u00b7 ChainAgnostic/caip-js \u00b7 GitHub  Would be cool if this EIP also included it such that we can link to any historical chain state. ",
                    "links": [
                        "https://github.com/ChainAgnostic/caip-js/pull/25",
                        "https://ethereum-magicians.org/t/discussion-can-ethereum-be-a-linked-data-web/10932/5"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.583333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "28",
                    "likes": "1",
                    "time": "03/02/2023-03:06:25",
                    "content": "Hi everyone.  We have launched two gateways w3eth.io and w3link.io to support the standard. We have uploaded all @VitalikButerin\u2019s blog (40MB) on Arbitrum Nova mainnet permanently with only 0.13 ETH!  Using the standard and gateway, you can browse the unstoppable website at https://0xe4ba0e245436b737468c206ab5c8f4950597ab7f.arb-nova.w3link.io/ or with ENS https://vitalikblog.w3eth.io (or web3://vitalikblog.eth/) ! ",
                    "links": [
                        "http://w3link.io",
                        "https://twitter.com/VitalikButerin",
                        "https://0xe4ba0e245436b737468c206ab5c8f4950597ab7f.arb-nova.w3link.io/",
                        "https://vitalikblog.w3eth.io"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party advertising proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nand",
                    "index": "29",
                    "likes": "1",
                    "time": "17/03/2023-10:27:14",
                    "content": "Hi! Just discovered this EIP, nice! I\u2019ve been developping a electron-based proof-of-concept browser implementing a evm:// protocol I made up (&& refined with frolic), so I am happy to migrate to this EIP.   GitHub    GitHub - nand2/evm-browser: Make electron like browser easy and flexible. Make electron like browser easy and flexible. Contribute to nand2/evm-browser development by creating an account on GitHub.      I have several questions :  Auto mode: If I have a method that returns 3 strings, and I want the second one returned as string, not JSON, how do I do it? For example, a method that return a token representation in HTML, SVG, TXT(ascii art) that I put in . For tuples and non-bytes/string results, I feel there should be a way to say that we want the result either as raw or as json? Auto mode: If I have a method that returns a string and I want to return this string cast as a specific MIME type (e.g. image/svg+xml), how do I do it? Auto mode: If I have a mathod that returns returns 2 variables, and I want the second one cast as image/svg+xml ? Auto mode: Autodetection of the type of argument : I can see an issue with the autodetection of bytes : if the contract expect bytes, and we put bytes in the URL and don\u2019t explicitely set the type, and by bad luck it has 20 or 32 length, then autodetection switch to bytes32/address type and the call signature changes, and it breaks the call. So maybe, for the bytes type, the type must always be explicitely present, it should not be autodetectable, like string? Manual mode: how do you specify the return data types and MIME type, since the full path?query is sent to the smartcontract?  Thanks! ",
                    "links": [
                        "https://github.com/nand2/evm-browser"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.802268244575936
                }
            ]
        }
    ],
    "group_index": "1604"
}