{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/llvm-evm-backend-is-now-available/3992",
            "title": "LLVM-EVM backend is now available ",
            "index": 3992,
            "category": [
                "Tooling"
            ],
            "tags": [
                "solidity",
                "dapps",
                "smart-contracts"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/stev",
                    "index": "1",
                    "likes": "3",
                    "time": "10/02/2020-15:55:00",
                    "content": "LLVM-EVM backend is alpha release is available. Here\u2019s the announcement:    Medium \u2013 10 Feb 20    Announcing EVM-LLVM Alpha release\u200a\u2014\u200aThe next level in smart contract evolution! Announcing EVM-LLVM project alpha release! This has been a long-awaited release for the EthereumStack communities as it will play a\u2026 Reading time: 4 min read         more programming languages for smart contracts more toolchain support future-proof and long-term support  ",
                    "links": [
                        "https://medium.com/etc-core/announcing-evm-llvm-alpha-release-the-next-level-in-smart-contract-evolution-91a2119bd442"
                    ],
                    "GPT-summary": null,
                    "GPT-proposal-categories": null,
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.624255952380952
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "2",
                    "likes": "1",
                    "time": "10/02/2020-17:27:34",
                    "content": "Other benefits:  almost 20 years of advanced optimization techniques (cheaper smart contracts) nearly 100% adoption among the security community (safer smart contracts) no JIT bombs or other concerns from trying to adapt web technologies to our needs.  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.565476190476191
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "3",
                    "likes": "0",
                    "time": "10/02/2020-22:23:47",
                    "content": "This is not so simple. There are a ton of \u201cbuiltins\u201d defined specific to EVM, and all of them must be exposed in all frontends. I\u2019m guessing that\u2019s the reason there are no examples of a smart contract written in any of the mentioned programming languages. Here is a LLVM IR example I found on https://github.com/etclabscore/evm_llvm/wiki/Compiling-smart-contracts. declare i256 @llvm.evm.calldataload(i256) declare void @llvm.evm.return(i256, i256) declare void @llvm.evm.mstore(i256, i256)  define void @main() { entry:   call void @llvm.evm.mstore(i256 64, i256 128)   %0 = call i256 @llvm.evm.calldataload(i256 0)   %1 = call i256 @llvm.evm.calldataload(i256 32)   %2 = call i256 @add(i256 %0, i256 %1)   call void @llvm.evm.mstore(i256 0, i256 %2)   call void @llvm.evm.return(i256 0, i256 32)   unreachable }  define i256 @add(i256, i256) #0 {   %3 = alloca i256, align 4   %4 = alloca i256, align 4   store i256 %0, i256* %3, align 4   store i256 %1, i256* %4, align 4   %5 = load i256, i256* %3, align 4   %6 = load i256, i256* %4, align 4   %7 = add nsw i256 %5, %6   ret i256 %7 }  Some questions to this code:  Why is EVM memory also handled by EVM-specific intrinsics? Why not using LLVM IR memory? Why is the @add function generated? The %2 = call i256 @add(i256 %0, i256 %1) can be simply replaced with %2 = add i256 %0, %1. The nsw in %7 = add nsw i256 %5, %6 is wrong.  The LLVM 10 is in the release process. Are you going to rebase your work on top of that or LLVM master? Also Rust requires very specific LLVM revision (see https://github.com/rust-lang/llvm-project). This work cannot be easily used in Rust language.  ",
                    "links": [
                        "https://github.com/etclabscore/evm_llvm/wiki/Compiling-smart-contracts",
                        "https://github.com/rust-lang/llvm-project"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.452380952380952
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/lialan",
                    "index": "4",
                    "likes": "3",
                    "time": "11/02/2020-02:04:24",
                    "content": "Hey @chfast, let me answer your questions:   yes the intrinsics must be generated by the frontend. This is obvious because EVM is a very different architecture than usual machines \u2013 storage space is not available in other architectures. You have to explicitly control the storage IO in any case. This is inevitable in any IR, unless you implicitly define the behaviour of storage IO in some higher-level IR.   In this case I was trying to 100% mimic the behaviours of function dispatcher in SOLC. Notice that this function is at the very top level and is close to \u201cbare metal\u201d, its purpose is to initialize the execution environment for the actual executing function (in this case, the \u201cadd\u201d function), so it have to explicitly initialize a \u201cmstore\u201d to location 0x40. If you were to use LLVM IR memory, the location 0x40 is not guaranteed. The 0x40 location is fixed because it stores the stack frame pointer.   Yeah, the call can be simply replaced with an \u201cadd\u201d operate. My purpose there was to show a very simple program being compiled to EVM: the function dispatcher (aka the \u201cmain\u201d function) calls a function named \u201cadd\u201d. and retrieves the returned value and return it. To make it less confusing, I should have used a more complicated example such as Fibonacci.   You are right again here, the \u201cnsw\u201d is an incorrect flag which will create poison values, it should be changed. I created the test cases using some c function as templates\u2026 So when creating LLVM IR, please follow the manual.   yes, back-porting is required if we need specific base LLVM versions. It is not technically difficult,  just a lot of chores. We will figure out which version to backport to first. BTW, we are not targeting Rust at the beginning as it will be too much work for the team (so far the team consists only one person, but you are welcomed to participate!), we will start with smart contract DSLs and c-like languages.   Yup, the designs and implementations will definitely change over time. The alpha version serves as a start point for frontend integrations and a proof of concept of compiling EVM using LLVM infrastructure. Please provide more feedbacks, we need people like you to help find problems in the codebase and make it better over time! Thanks! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.290322580645162
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pinkiebell",
                    "index": "5",
                    "likes": "0",
                    "time": "12/02/2020-13:27:30",
                    "content": "Great work  ! This project is something I missed to have since the beginning. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 10.0
                }
            ]
        }
    ],
    "group_index": "1002"
}