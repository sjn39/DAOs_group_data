{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-erc-app-keys-application-specific-wallet-accounts/2742",
            "title": "EIP ERC App Keys: application specific wallet accounts ",
            "index": 2742,
            "category": [
                "EIPs"
            ],
            "tags": [
                "NONE"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "1",
                    "likes": "11",
                    "time": "26/02/2019-06:33:53",
                    "content": "Hi everyone, Our research at MetaMask has lead us to propose the following EIP and we would very much appreciate if the community gave us feedback such that we can come to an agreement on a standard that would be appropriate both for wallets and applications developers to guarantee cross-compatibility.   github.com/ethereum/EIPs       EIP ERC: App Keys, application specific wallet accounts     by Bunjin   on 11:27AM - 25 Feb 19 UTC   67 commits   changed 1 files   with 551 additions   and 0 deletions.       Simple Summary: Among others cryptographic applications, scalability and privacy solutions for ethereum blockchain require that an user performs a significant amount of signing operations. It may also require her to watch some state and be ready to sign data automatically (e.g. sign a state or contest a withdraw). The way wallets currently implement accounts poses several obstacles to the development of a complete web3.0 experience both in terms of UX, security and privacy. This proposal describes a standard and api for a new type of wallet accounts that are derived specifically for a each given application. We propose to call them  app keys . They allow to isolate the accounts used for each application, thus increasing privacy. They also allow to give more control to the applications developpers over account management and signing delegation. For these app keys, wallets can have a more permissive level of security (e.g. not requesting user\u2019s confirmation) while keeping main accounts secure. Finally wallets can also implement a different behavior such as allowing to sign transactions without broadcasting them. This new accounts type can allow to significantly improve UX and permit new designs for applications of the crypto permissionned web. Abstract: In a wallet, an user often holds most of her funds in her main accounts. These accounts require a significant level of security and should not be delegated in any way, this significantly impacts the design of cryptographic applications if a user has to manually confirm every action. Also often an user uses the same accounts across apps, which is a privacy and potentially also a security issue. We introduce here a new account type, app keys, which permits signing delegation and accounts isolation across applications for privacy and security. In this EIP, we provide a proposal how to uniquely identify and authenticate each application, how to derive the accounts along an Hierachical Deterministic (HD) path restricted for the domain and we finally define an API for applications to derive and use these app keys. This ERC aims at finding a standard that will fit the needs of wallets and application developers while also allowing app keys to be used across wallets and yield the same accounts for the user for each application. Elements to discuss: The motivation of this ERC is to get feedback about the following points:  Applications Hierarchical Deterministic Path The use of personas Applications unique identifiers (uid) and applications authentication Uid slicing for HD path Application Customisable sub path Api methods  Thanks, looking forward to discuss this with the community! Vincent ",
                    "links": [
                        "https://github.com/Bunjin",
                        "https://github.com/ethereum/EIPs/pull/1775",
                        "https://github.com/Bunjin",
                        "https://github.com/ethereum/EIPs/pull/1775",
                        "https://github.com/ethereum/EIPs/blob/c0608fbcfa9c541431e6ed2efd1c3160ded49c1a/EIPS/eip-draft-app-keys.md#applications-hd-path",
                        "https://github.com/ethereum/EIPs/blob/c0608fbcfa9c541431e6ed2efd1c3160ded49c1a/EIPS/eip-draft-app-keys.md#personas",
                        "https://github.com/ethereum/EIPs/blob/c0608fbcfa9c541431e6ed2efd1c3160ded49c1a/EIPS/eip-draft-app-keys.md#applications-unique-identifiers",
                        "https://github.com/ethereum/EIPs/blob/c0608fbcfa9c541431e6ed2efd1c3160ded49c1a/EIPS/eip-draft-app-keys.md#applications-uid-decomposition-to-get-a-bip32-hd-path",
                        "https://github.com/ethereum/EIPs/blob/c0608fbcfa9c541431e6ed2efd1c3160ded49c1a/EIPS/eip-draft-app-keys.md#api",
                        "https://github.com/ethereum/EIPs/blob/c0608fbcfa9c541431e6ed2efd1c3160ded49c1a/EIPS/eip-draft-app-keys.md#api",
                        "https://ethereum-magicians.org/t/meta-we-should-value-privacy-more/2475/18",
                        "https://ethereum-magicians.org/t/web3-login-permissions/3583/24"
                    ],
                    "GPT-summary": "The author of the post is proposing a new standard and API for a new type of wallet accounts called \"app keys\" that are derived specifically for each given application. The proposal aims to increase privacy, give more control to application developers over account management and signing delegation, and improve UX. The author is asking for feedback from the community on various aspects of the proposal.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Interoperability and Scalability",
                        "Privacy, Security and risk management",
                        "Community and engagement",
                        "Not a proposal"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None"
                    ],
                    "Sentiment": 5.8081890331890325
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jpitts",
                    "index": "2",
                    "likes": "1",
                    "time": "26/02/2019-07:46:04",
                    "content": "Cross-referencing to a recent post by someone who was pointing out that we should value privacy more      Meta: we should value privacy more Primordial Soup       Right now, Ethereum privacy is quite lacking. There are two reasons why. First, all of your activity is by default done through a single account, so it is all linkable on-chain. Second, and more insidiously, even if you have multiple accounts that you split your activity between (ideally, the default would be to use a different account for each application), the fact that you need to transfer ETH between accounts to pay for gas on all of them is itself a privacy leak.  This is a situation that c\u2026     ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.301948051948052
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "3",
                    "likes": "1",
                    "time": "26/02/2019-17:29:55",
                    "content": "A couple other points I\u2019d like to highlight:  Eventually this proposal could be extended to support other cryptographic curves, facilitating alternative cryptography like zk-STARKs. While this proposal generates a path for key generation per domain, a delegation system could allow groups of distinct domains to coordinate securely. To revoke these keys the client will need to keep track of the revoked keys, and skip them when generating keys in the future. This is an important requirement of any wallet implementing this standard (personal side-chains, anyone?).  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal"
                    ],
                    "Sentiment": 5.472222222222223
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "4",
                    "likes": "2",
                    "time": "27/02/2019-08:09:35",
                    "content": "This is a great proposal! This should allow for so much nicer user interface. I have been thinking along these lines for quite some time and I ll here shamlessly plug my related proposals as I think they bring a different perspective that might be helpful to be aware of:  3 Proposals For Making Web3 A Better Experience  There is 3 proposals in there. The two on signature are similar to appkey in intent but use the main account (no isolation) and is restricted to EIP712 signature in its current form. it allows them to be used without modification, except for an extra domain Seperator field in EIP712. The one on encryption could be applied to app keys. In that article, it is also mentioned the idea of smart contract domain approval by users. This would allow users to stay in control of which domain has the right to act on behalf of the users on each smart contract following the standard. For app keys I guess this can be done via address. Any plan to standardise such in this proposal?  Automatic Authentication Signature  This one (modified in this direction by @pedrouid) could also be used for app keys to let wallet.appkey.enable return an authenticated account by passing a challenge to the request, instead of having the application to do a signature request on top. As for general comments, I ll have a closer read later, but few things jumped to mind : the option to use app keys per content hash is I think very important for fully decentralised app where even the app creator and ENS name owner should be considered malicious. Relying on the ENS is prone to vulnerability as you mentioned. ENS should be used for discoverability not as the basis for security. As such app key should ideally be using the contentHash for the domain, when such is used. Having said that I think it could also be an option to have app keys for ENS names to allow application to update without having to scare their users with another enable popup or share data with earlier version easily. This should be clearly indicated to the user though as a warning when accepting such ENS name based app keys. Similarly: App keys should work with DNS names. I am not sure I understand the rational behind refusing them. Is it really not possible to come with a normalization scheme similar to ENS ? Looking forward to play with such proposal! ",
                    "links": [
                        "https://ethereum-magicians.org/t/automatic-authentication-signature/2429"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.692261904761905
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "5",
                    "likes": "1",
                    "time": "27/02/2019-08:47:50",
                    "content": "Hi Ronan, @widhawag, good to get your feedback! I\u2019ll take the time to review the links and your post in details, but for now I had a quick comment about your last part:     wighawag:  Similarly: App keys should work with DNS names. I am not sure I understand the rational behind refusing them. Is it really not possible to come with a normalization scheme similar to ENS ?   Agreed that we should find a way to support non ENS names (both for generality and to remove the requirement to register an ENS domain). DNS names are indeed a good candidate and should be fairly easy to support. Looking forward to discuss this more. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.996212121212121
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/BradleyC",
                    "index": "6",
                    "likes": "2",
                    "time": "27/02/2019-09:00:13",
                    "content": "Something like this is definitely needed. I\u2019d like to engage with it more but initial reaction - it seems like the system should be designed to accommodate all DNS names. I also wonder how long it will be safe to trust the domain model - if there is a valuable payload it may become worthwhile to attempt to access wallets from forged domains. Perhaps we can accept any app regardless of domain by requiring apps to use their own public / private keypair. Then the user proactively trusts the app (identified by keypair and not a hash of the name) similar to adding a public key to ssh authorized_keys. **Edit: an alternative to generating new accounts per app could be to leverage existing TLS certificates, since most web hosts (whether VPS or AWS style providers) have secure mechanisms built in to store secure signed data. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.089488636363636
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cartercarlson",
                    "index": "7",
                    "likes": "3",
                    "time": "27/02/2019-15:13:56",
                    "content": "I definitely agree that the EIP should offer support for all DNS names (assuming support for ENS), and with DNS names you could uniquely identify addresses just like ENS.  Overall, I know there\u2019s a different process to make a subdomain tied to a unique address on DNS than on ENS. Short term focus on DNS support could slow down overall progress on this EIP.  With other teams working on integrating DNS services with Ethereum addresses, DNS implementation may be out of the scope of this EIP. If this EIP focuses solely on ENS app accounts, other EIPs should come out to improve DNS standards of Ethereum address creation. As soon as that happens, it should be easy adding a feature for DNS support. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.1990740740740735
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/light",
                    "index": "8",
                    "likes": "1",
                    "time": "27/02/2019-22:20:45",
                    "content": " They allow to isolate the accounts used for each application, thus increasing privacy.  It could be worth enumerating on the use-cases where these app keys could increase privacy, and to document how a user can take advantage of this feature to protect privacy. For example if all a user is doing with these keys is signing messages, I can see it being relatively easy for a wallet to keep them isolated and thus prevent correlation between the keys. But if a user begins transacting with these keys, and funding them from their main account(s) then it becomes trivial through blockchain analysis to correlate the keys and provide a confidence score that they are owned by the same user. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/boris",
                    "index": "9",
                    "likes": "0",
                    "time": "27/02/2019-22:22:38",
                    "content": "    light:  But if a user begins transacting with these keys, and funding them from their main account(s) then it becomes trivial through blockchain analysis to correlate the keys and provide a confidence score that they are owned by the same user.   Yes, thank you for raising this. Anything that doesn\u2019t solve this is no better than what we have now. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.395833333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "10",
                    "likes": "2",
                    "time": "28/02/2019-06:26:55",
                    "content": "    light:  It could be worth enumerating on the use-cases where these app keys could increase privacy, and to document how a user can take advantage of this feature to protect privacy.   Agreed. So indeed if all an application needs to do with its keys is to sign messages and it does not require funding, then this EIP allows for privacy through the use of distinct keys for each application with a simple deterministic standard compatible across wallets. However if these application keys require funding, indeed there can be trail and the use of app keys would not fully solve the privacy problem there indeed. A few comments however about this:  Mixers or anonymous ways of funding an ethereum address (ring signatures) along with this proposal would guarantee privacy Even if privacy is not solved fully without this anonymous funding method, we still need a way to easily create and restore different accounts/addresses for each application  And importantly, this EIP is not only about privacy, it\u2019s also about delegation. So even in the case where your application require funding and that we have no way to obfuscate the funding trail, I really think that there is a lot to benefit from using this standard to derive accounts specific for the application for which I can delegate signing and to use these only for a single application. Current situation where accounts are used for several different applications and for transacting is both a privacy and a security concern but also very painful to manage if you are going to have to remember which account you are using for each specific application, and there is no standard for this to be managed in a compatible way across wallets. So even if this is not the end of the story for the privacy problem when you need to fund the app accounts, this EIP is a potential prerequisit since any private funding method will require seperate accounts and it also brings other benefits such as delegation and UX improvements. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.145380952380952
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "12",
                    "likes": "1",
                    "time": "03/03/2019-08:42:43",
                    "content": "Added support for DNS names, using the ENS hashing scheme and authenticated by the wallet through the loading of the DNS webpage. This can create some ambiguity when using ENS names that point to an DNS url. Thus adding an option in the .enable() that allows to specify which of the 2 the app would like to use for the app keys derivation path. @wighawag, I\u2019m still reviewing your links and comments, but your comments suggested me to add the following to the appkeys.enable method:  .enable() now returns the app\u2019s root account extended public key. This should allow for the app to derive all non hardened child public keys. If enable() options also include a challenge string the wallet will sign it with the app\u2019s root account and will return the signature. This should allow the applications to safely authenticate the users by verifying that they indeed own the private key of the public keys they are claiming to own.  Here is the commit that includes most of these changes:   github.com/ethereum/EIPs       added support for DNS, options for .enable, signing challenge     by Bunjin   on 08:28AM - 03 Mar 19 UTC     changed 1 files   with 18 additions   and 14 deletions.        Thanks again everyone for all the comments! ",
                    "links": [
                        "https://github.com/Bunjin",
                        "https://github.com/ethereum/EIPs/commit/d69b5d101639ff01a9ec1e2ce50116e331020c5f",
                        "https://github.com/Bunjin",
                        "https://github.com/ethereum/EIPs/commit/d69b5d101639ff01a9ec1e2ce50116e331020c5f"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.020833333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "13",
                    "likes": "0",
                    "time": "03/03/2019-16:43:26",
                    "content": "    Bunjin:  .enable() now returns the app\u2019s root account extended public key. This should allow for the app to derive all non hardened child public keys.   We should find a way to support this behavior without breaking the current API for other sites, possibly by adding a new option to the enable call. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.008116883116883
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "14",
                    "likes": "0",
                    "time": "03/03/2019-16:46:25",
                    "content": "    boris:  Anything that doesn\u2019t solve this is no better than what we have now.   It isn\u2019t much better for privacy, but some sites use signatures only to authenticate, and for them it is infinitely better for privacy. Also like Bunjin wrote, this is a prerequisite to other anonymization strategies like mixers. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/boris",
                    "index": "15",
                    "likes": "0",
                    "time": "03/03/2019-17:22:26",
                    "content": "I\u2019m totally in favour of the steps here (insofar as I understand them!) \u2013 I was quoting a very specific point that @light made. If out of the box all the keys can be correlated \u2013 then this is a step backwards. Theoretically today I can have multiple addresses and do my own app / key management. Was it Cipher Browser that generated like 10 addresses for you but you couldn\u2019t label them or do anything other than switch between them? The same as having multiple email addresses where it\u2019s all my own opsec to keep them from not being correlated. So perhaps this is better in the form of a question @danfinlay : given this method, how much can an external actor correlate? Can they trivially (just using the chain, not IP address or browser fingerprinting) correlate my fluffy-puppies address with my hardcore-metal address? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.776785714285715
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "16",
                    "likes": "0",
                    "time": "03/03/2019-17:54:29",
                    "content": "    danfinlay:  We should find a way to support this behavior without breaking the current API for other sites, possibly by adding a new option to the enable call.   No worries there, for now it\u2019s appkeys.enable(), a separate method than the EIP1102 .enable(). Not sure if we should merge them or not. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.761363636363637
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "17",
                    "likes": "1",
                    "time": "07/03/2019-20:05:02",
                    "content": "    boris:  given this method, how much can an external actor correlate? Can they trivially (just using the chain, not IP address or browser fingerprinting) correlate my fluffy-puppies address with my hardcore-metal address?   The app key is not correlated at all by default (it is generated from a hardened HD derivation path), but could be correlated by whatever means the account was funded. So it\u2019s privacy until funding, or continued privacy if the funding source can be obfuscated. There would theoretically be an XPub key capable of proving the correlation of an account and all of its app keys, but this proposal does not include any method for sharing that XPub at this time. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/boris",
                    "index": "18",
                    "likes": "0",
                    "time": "07/03/2019-20:18:52",
                    "content": "Great. Funding correlation of multiple accounts is already where we\u2019re at, so this is at least as good as that. Thanks! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.45
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "19",
                    "likes": "0",
                    "time": "09/03/2019-16:51:01",
                    "content": "Oh I did partly misspeak about the possibility of sharing an Xpub on this path, but the point you took away is the same. Vincent will clarify soon. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "20",
                    "likes": "0",
                    "time": "11/03/2019-08:38:27",
                    "content": "    danfinlay:  about the possibility of sharing an Xpub on this path   App Keys of each application are isolated one from another across applications because we harden the derivation path for each application keys. So even if you had the root extended public key (coming from the mnemonic), you would not be able to compute the child public keys of any application\u2019s keys. However, once at the application level, since the application sub path is not constrained, an application can choose to use non hardened indexes and would thus be able to compute the extended public keys (and thus addresses) of all this app\u2019s accounts from the application\u2019s root public key.     boris:  Funding correlation of multiple accounts is already where we\u2019re at, so this is at least as good as that.   Indeed and I\u2019ll try to explain why this proposal allows to be in a better state than currently in terms of privacy. It will allow to make using a new account for each application a default. So instead of having accounts used for several applications you will have separated accounts by default. If you don\u2019t need funding then that\u2019s fully private. If you need funding there is indeed a potential correlation by following the funding trail. Even in that case, it\u2019s already better than the status quo and for several reasons:  Following the funding trail does not give you certainty that these accounts belong to the same person, only some probability. If you use a mixer to fund the app account then it would obfuscate this trail. And with our proposal you have a proper way to create and manage a large amount of applications specific accounts.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.528971028971029
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "21",
                    "likes": "3",
                    "time": "11/03/2019-09:09:03",
                    "content": "ETHcc video where I introduce this work.  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gravityblast",
                    "index": "22",
                    "likes": "2",
                    "time": "12/03/2019-15:15:08",
                    "content": "hey @Bunjin, great proposal! We\u2019ve been thinking about something similar to this in Status for a long time, getting the derivation path from ENS names, and I like this solution!  we would love to contribute to this and implement it when it\u2019s finalized. I also think this can work on top of eip-1581, what do you think? I saw this in the proposal this:  EIP 1581: Non-wallet usage of keys derived from BIP-32 trees also discussed here proposes a scheme that relies on a list of indexes where application should register (similar to SLIP0044 list for instance).  But EIP-1581  only defines a standard way to derive non-wallet keys, without requiring apps to be registered. Only the key_type should be, so in this case the key type can be apps / dapps, and the the sub paths what you already proposed, which I like especially in the way we can get the derivation path from a ENS name. So if we have both we can have general non-wallet keys not based on app/domains, and apps keys based on specific apps/dapps. What do you think? ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-1581",
                        "https://ethereum-magicians.org/t/non-wallet-usage-of-keys-derived-from-bip-32-trees/1817/4"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.7644230769230775
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "23",
                    "likes": "0",
                    "time": "15/03/2019-09:06:17",
                    "content": "Hi @gravityblast, thanks a lot for your comment and suggestion! I think this EIP 1775 moves away from EIP1581 for several reasons: EIP1581 proposes to use a path starting by m / purpose' / coin_type' / subpurpose' / key_type' / key_index m / 43' / 60' / 1581' First of all BIP 43\u2019 is not a purpose field since it\u2019s the global standard for the purpose field structure. BIP44 is BIP 43 compliant. If we deviate from BIP44, we need a different purpose field than 43 and 44 altogether. Second, it uses coin type 60, which I think is not necessary here. We already have the BIP44 structure of main accounts for transacting Ether, here we are trying to define applications keys, which are not Ethereum specific, so I don\u2019t think we need a coin type field there. Third EIP 1581 would like to introduce a key type field which poses several questions imho. Why separate the keys by what this EIP calls type? The EIP says for this field:  Describes the purpose for which the key is being used.  What key types does this EIP propose? Where are they referenced, how is this list maintained? But a key is a key, there are no key types by definition, only potentially by use. We don\u2019t need impose to split the keys by purpose, or at least we don\u2019t need to impose that. What would be the benefit of this field? More importantly EIP1581 is silent about authentication. How does one request access to a given key (key type and key index)? How does one prove he is using the key type required? What\u2019s preventing you to use EIP1775 for \u201cnon wallet usage of keys\u201d? An application authenticated through its name and then gets access to the keys for its domain (we are not retricted to DNS or ENS names). If you\u2019d like to introduce a general application such as \u201cssh\u201d at the wallet level, then we can use EIP1775 to derive keys for this domain\u2019s name and skip authentication. So all things considered I think the EIP we propose here is more global than EIP1581 and that it solves several issues of EIP1581. Why would you like to preserve EIP1581, what do you think that EIP would allow that EIP1775 would not? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.267156862745098
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gravityblast",
                    "index": "24",
                    "likes": "3",
                    "time": "15/03/2019-14:22:03",
                    "content": "thank you @Bunjin! I\u2019m happy to both use 1775 or 1581, if we find that they have many things in common it might make sense!     Bunjin:  First of all BIP 43\u2019 is not a purpose field since it\u2019s the global standard for the purpose field structure. BIP44 is BIP 43 compliant. If we deviate from BIP44, we need a different purpose field than 43 and 44 altogether   We started with a single m/EIP_NUMBER too, but then @Arachnid helped us using the right path according to BIP43:  Purpose code 43 is reserved for usage by non-Bitcoin cryptocoins. In this case, the level immediately below the purpose code is hardened derivation using the index for the cryptocoin specified by SLIP-0044. The details of levels below this coin type are to be entirely decided by the standard process of the specific cryptocoin, but it is recommended that the very next level be a sub-purpose code with a similar use as this BIP\u2019s purpose code. So that the recommended use for non-Bitcoin cryptocoins is: m / 43' / coin_type' / subpurpose' / ...   that\u2019s why we ended up using that path.     Bunjin:  What\u2019s preventing you to use EIP1775 for \u201cnon wallet usage of keys\u201d? An application authenticated through its name and then gets access to the keys for its domain (we are not retricted to DNS or ENS names). If you\u2019d like to introduce a general application such as \u201cssh\u201d at the wallet level, then we can use EIP1775 to derive keys for this domain\u2019s name and skip authentication.   In our case we were thinking about 2 different native chat apps, where a user can recover an account from  the mnemonic and in both apps use the same keys, so different apps where the only common thing is the \u201cpurpose\u201d of the key (chat, storage, etc\u2026).  I see the difference since in the other case it\u2019s a wallet/dapp-browser that manages the keys for the current app.     Bunjin:  What key types does this EIP propose? Where are they referenced, how is this list maintained? But a key is a key, there are no key types by definition, only potentially by use. We don\u2019t need impose to split the keys by purpose, or at least we don\u2019t need to impose that. What would be the benefit of this field?   Yeah you are completely right! A key is a key, so it can be used for anything. But in our case we wanted to have a standard based on the purpose so that if I\u2019m chatting with you, I can change to a different native app and still using the same key if the other client uses the right \u201cchat\u201d key. Same like BIP44, I can change wallet but I have the same keys based on the coin type.     Bunjin:  More importantly EIP1581 is silent about authentication. How does one request access to a given key (key type and key index)? How does one prove he is using the key type required?   Yeah that\u2019s not covered because it\u2019s not intended to be chosen by a dapp, but by the wallet itself. I see your point though, that\u2019s why I thought 1775 can add those points on top of 1581.     Bunjin:  What\u2019s preventing you to use EIP1775 for \u201cnon wallet usage of keys\u201d? An application authenticated through its name and then gets access to the keys for its domain (we are not retricted to DNS or ENS names). If you\u2019d like to introduce a general application such as \u201cssh\u201d at the wallet level, then we can use EIP1775 to derive keys for this domain\u2019s name and skip authentication.   I\u2019m still thinking about a native app. What would you use instead of the dapp domain or name so that the same key can be shared in different apps? Let\u2019s see if we can find some common points, or maybe they are just 2 completely different use cases and it\u2019s fine too  ",
                    "links": [
                        "https://github.com/satoshilabs/slips/blob/master/slip-0044.md"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.237187247780469
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "25",
                    "likes": "0",
                    "time": "18/03/2019-16:01:21",
                    "content": "Thanks for your detailed answer @gravityblast. Now I think understand better what you are aiming at and how our efforts relate. A] First of all a few comments about your EIP1581 and what you mentionned about your choice of an HD Path:  HD path BIP44:  HD Path BIP32 compliant BIP 43 only suggests that the first field should be a purpose field, m / purpose' / * Then there is BIP 44 that specifies the whole path as m / purpose' / coin_type' / account' / change / address_index and SLIP44 This uses a purpose field of 44 and not 43 as mentioned in your link by arachnid and a PR (not merged by LukeJr). See my references and also the Ethereum EIPs that specifies that we should use m/44'/60'/a'/0/n'   github.com/ethereum/EIPs      Issue: Standardizing of HD wallet derivation paths (BIP32, BIP39, BIP44)  \t \topened by christianlundkvist \ton 2016-03-26 \t \t \t  References: BIP32 BIP39 BIP44 We are now seeing a few different Ethereum HD wallet implementations with different HD derivation paths. When we wrote Lightwallet I considered...   \tERC       and slip44 list : https://github.com/satoshilabs/slips/blob/master/slip-0044.md So in any case if you are willing to use BIP44, I think you should use purpose field 44\u2019 and not 43\u2019, no matter the coin type.  HD path BIP43 deviating from BIP44:  When deviating from BIP44, one should use a different purpose field than 44\u2019 but it has not been standardized to use 43\u2019 and cointype\u2019. In fact several other indexes have been already used and standardized see:   bitcoin.stackexchange.com       Is there a comprehensive list of registered BIP43 purposes?   bip44     asked by           Bilthon      on 05:12PM - 09 Oct 17 UTC       and what I mention in the EIP, where I reference all these:   github.com   ethereum/EIPs/blob/1ae40193625ddaf9f1ac1c28d661fbce5ed5feac/EIPS/eip-1775.md#hd-derivation-path-purpose-field --- eip: 1775 title: App Keys, application specific wallet accounts author: Vincent Eli (@Bunjin), Dan Finlay (@DanFinlay) discussions-to: https://ethereum-magicians.org/t/eip-erc-app-keys-application-specific-wallet-accounts/2742 status: Draft type: Standards Track category: ERC created: 2019-02-20 requires: 137 replaces: 1581 ---  <!--You can leave these HTML comments in your merged EIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new EIPs. Note that an EIP number will be assigned by an editor. When opening a pull request to submit your EIP, please use an abbreviated title in the filename, `eip-draft_title_abbrev.md`. The title should be 44 characters or less.--> ## Simple Summary <!--\"If you can't explain it simply, you don't understand it well enough.\" Provide a simplified and layman-accessible explanation of the EIP.-->  Among others cryptographic applications, scalability and privacy solutions for ethereum blockchain require that an user performs a significant amount of signing operations. It may also require her to watch some state and be ready to sign data automatically (e.g. sign a state or contest a withdraw). The way wallets currently implement accounts poses several obstacles to the development of a complete web3.0 experience both in terms of UX, security and privacy.  This proposal describes a standard and api for a new type of wallet accounts that are derived specifically for a each given application. We propose to call them `app keys`. They allow to isolate the accounts used for each application, thus potentially increasing privacy. They also allow to give more control to the applications developpers over account management and signing delegation. For these app keys, wallets can have a more permissive level of security (e.g. not requesting user's confirmation) while keeping main accounts secure. Finally wallets can also implement a different behavior such as allowing to sign transactions without broadcasting them.     This file has been truncated. show original      Importantly, I don\u2019t see why these standards should be related to a coin type and I would refuse to restrict to what luke JR suggested (that wasn\u2019t merged) as : m / 43' / coin_type' / subpurpose' / Imho that\u2019s too restrictive to subject these to a coin_type. B] Now about your use case and how EIP1775 could allow for it: I understand and agree that it\u2019s an important use case to be able to implement non transacting, cross apps/domains keys (for instance for chat or others). For that I see two alternatives:   develop an EIP alongside 1775, such as yours but then I\u2019d recommend to use a different purpose field than 43 and 44, and not used already also I think we should remove the coin type since apps such as chat are not necessarly related to a coin.   [I favor this approach for the sake of simplicity] Use EIP 1775 to encompass all in the following way: For cross applications non transacting keys (not main accounts), we need a different naming scheme than DNS or ENS and we assume that the wallet or the clients will not have to authenticate these but will include them in their core logic.   This naming scheme would be something like cak:[name] where cak (cross app key is just a header that allows to fully distinguish these from DNS/ENS) and name is the standardized name of the use case. e.g.:    cak:whisper, cak:ssh, cak:swarm \u2026 we also need to specify the hashing scheme for these in a way that ensures no collision with the current hashing in EIP1775 of ENS/DNS names. It should be fairly easy. With this 2nd approach, this would mean 3 types of keys:  main accounts (along BIP44 eth standard, and potentially for other cryptocurencies too) EIP1775 app specific keys authenticated through ENS and/or DNS EIP1775 cross apps/domains keys not authenticated but included in the wallet/client.  ",
                    "links": [
                        "https://github.com/christianlundkvist",
                        "https://github.com/ethereum/EIPs/issues/84",
                        "https://github.com/christianlundkvist",
                        "https://github.com/ethereum/EIPs/issues/84",
                        "https://github.com/satoshilabs/slips/blob/master/slip-0044.md",
                        "https://bitcoin.stackexchange.com/questions/60470/is-there-a-comprehensive-list-of-registered-bip43-purposes",
                        "https://bitcoin.stackexchange.com/users/16981/bilthon",
                        "https://bitcoin.stackexchange.com/questions/60470/is-there-a-comprehensive-list-of-registered-bip43-purposes",
                        "https://bitcoin.stackexchange.com/users/16981/bilthon",
                        "https://bitcoin.stackexchange.com/questions/60470/is-there-a-comprehensive-list-of-registered-bip43-purposes",
                        "https://github.com/ethereum/EIPs/blob/1ae40193625ddaf9f1ac1c28d661fbce5ed5feac/EIPS/eip-1775.md#hd-derivation-path-purpose-field",
                        "https://github.com/ethereum/EIPs/blob/1ae40193625ddaf9f1ac1c28d661fbce5ed5feac/EIPS/eip-1775.md#hd-derivation-path-purpose-field",
                        "https://github.com/ethereum/EIPs/blob/1ae40193625ddaf9f1ac1c28d661fbce5ed5feac/EIPS/eip-1775.md#hd-derivation-path-purpose-field"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.4426106301106305
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "26",
                    "likes": "0",
                    "time": "19/03/2019-08:43:51",
                    "content": "See ongoing discussion here (comments by @Arachnid ) about the BIP43 purpose field:   github.com/ethereum/EIPs       EIP 1775 - App Keys, application specific wallet accounts     by Bunjin   on 11:27AM - 25 Feb 19 UTC   87 commits   changed 1 files   with 571 additions   and 0 deletions.       ",
                    "links": [
                        "https://github.com/Bunjin",
                        "https://github.com/ethereum/EIPs/pull/1775",
                        "https://github.com/Bunjin",
                        "https://github.com/ethereum/EIPs/pull/1775"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "27",
                    "likes": "0",
                    "time": "19/03/2019-09:30:26",
                    "content": "    Bunjin:  When deviating from BIP44, one should use a different purpose field than 44\u2019 but it has not been standardized to use 43\u2019 and cointype\u2019.   There is no standardised prefix for coins other than Bitcoin besides BIP44 - which is organised around UTXO coins and one specific use-case. Given the Bitcoin community\u2019s resistance to expending effort on helping other projects with standardisation, it\u2019s unlikely we\u2019ll ever have one - so the unmerged proposal from luke-jr is the closest we\u2019re likely to come. It\u2019s definitely in contravention of BIP44 to use m/44'/60'/ as a prefix and not use the remaining fields as specified.     Bunjin:  Importantly, I don\u2019t see why these standards should be related to a coin type and I would refuse to restrict to what luke JR suggested (that wasn\u2019t merged) as : m / 43' / coin_type' / subpurpose' / Imho that\u2019s too restrictive to subject these to a coin_type.   I\u2019m not sure why you think this is a restriction, or unacceptable. Can you clarify? When there\u2019s multiple independent teams trying to use a namespace without collisions, we need a way to divide it up to ensure that collisions don\u2019t happen. Using this proposal is one way to do that, and allows us to define any subtree we want without any chance of overlap. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.705128205128205
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitgamma",
                    "index": "28",
                    "likes": "1",
                    "time": "19/03/2019-09:50:20",
                    "content": "    Bunjin:  e.g.: cak:whisper , cak:ssh , cak:swarm \u2026   using hashes generates very long paths, which is a performance issue for resource-limited wallets like the Keycard or the Ledger (there can even be limits on the allowed nesting in some wallets). This is the reason why we went with a key usage specifier instead in EIP-1581 for the general case, still allowing a hashing scheme like the one defined in EIP-1775 to be implemented in the key_index field ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 4.975
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "29",
                    "likes": "0",
                    "time": "19/03/2019-11:03:46",
                    "content": "    Arachnid:  I\u2019m not sure why you think this is a restriction, or unacceptable. Can you clarify?   Of course, I\u2019ll try to clarify. Imho the EIP1775 or also EIP1581 are transversal to all cryptocurrencies and even more global than that because one could like to use chat keys or application specific keys without using any cryptocurrency. Thus EIP1775 or EIP1581 should in fact be global Crypto IPs. Therefore any standard we propose here should not be a subset of a coin_type. I know that it\u2019s only something that\u2019s in the HD path, but I think it would matter and for instance that would mean that if other cryptocurrencies teams would like to use app keys or non wallet keys, then they would use a path that includes Ethereum coin_type which is kind of weird and would lead to confusion imho.     Arachnid:  When there\u2019s multiple independent teams trying to use a namespace without collisions, we need a way to divide it up to ensure that collisions don\u2019t happen. Using this proposal is one way to do that, and allows us to define any subtree we want without any chance of overlap.   I fully agree about the need to avoid collision in a proper way. What you suggest is one way indeed (and it relies on the IPs list to be fully separated within each \u201ccryptocurrency space\u201d), however like I mentioned above it imposes a separation per crypto currency (and these to be subjected to cryptocurrencies). What we propose here is another approach to avoid collision: using a purpose field list, which in any case will be required at the BIP43 level since several purpose fields are already in use (and some of them are not BIP related). In any case, I\u2019m open to solving this in another way, similar to what you subject but philosophically (and not only) I\u2019m against imposing the use of a  coin_type in the path for the reasons mentioned above. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.944746376811594
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "30",
                    "likes": "0",
                    "time": "19/03/2019-11:11:38",
                    "content": "    bitgamma:  using hashes generates very long paths, which is a performance issue for resource-limited wallets like the Keycard or the Ledger (there can even be limits on the allowed nesting in some wallets)   Good point, and yes you are right, the depth of the HD path matters. We are currently trying to get feedback from HW dev to understand their limitations with respect to this. However it seems the computational complexity is linear with the depth of the HD tree. Also there are other ways to reduce the depth of the EIP1775 path, such as only using 128bits Uids. In any case, that\u2019s a good point and I\u2019ll report here the results of discussions with HW devs. Edit: Just talked to Ledger CTO we will do a benchmark (time / depth) analysis and report the findings. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.9348214285714285
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "31",
                    "likes": "1",
                    "time": "19/03/2019-19:14:45",
                    "content": "As I said - the presence of the coin type field is only namespacing. It doesn\u2019t limit the use of the standard, it\u2019s simply where it\u2019s defined. You\u2019re defining something in the EIP process; the only part of the namespace you can issue yourself is the part (nominally) controlled by that process. Analagously, suppose you\u2019re producing a product for sale worldwide, and you need a UPC (barcode) number. Because you are in the US, your UPC codes will be prefixed with that because that is where the product originated - but that says nothing about where the product can be sold. The root of the HD key namespace is controlled by BIP43, which says that the first field will be a BIP number. If you want to use any part of the namespace other than the one we\u2019ve managed to get somewhat ad-hoc allocated to non-Bitcoin projects, you\u2019ll need to write a BIP and get it approved. The EIP process can\u2019t help with that. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0892857142857135
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "32",
                    "likes": "0",
                    "time": "20/03/2019-18:32:27",
                    "content": "Thanks a lot for your answer @Arachnid ! Great analogy, however for this proposal, I think we would be more in a situation where we are defining a new way of defining bar codes (fully compatible with the previous technology), defining a core standard for wallets, not labeling a product. For the sake of pragmatism, I\u2019m ok with using a path like you suggest (m/43\u2019/60\u2019/1775\u2019) but there may be an advantage of using a child depth of 1 (like I initially suggested) for the purpose field is that it\u2019s obviously less depth than 3 and thus less computationally heavy (see comments by @bitgamma above). Another option may be indeed to submit part of this as a BIP to claim a first depth BIP43 purpose field. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.6678321678321675
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/bitgamma",
                    "index": "33",
                    "likes": "0",
                    "time": "21/03/2019-06:58:02",
                    "content": "    Bunjin:  For the sake of pragmatism, I\u2019m ok with using a path like you suggest (m/43\u2019/60\u2019/1775\u2019) but there may be an advantage of using a child depth of 1 (like I initially suggested) for the purpose field is that it\u2019s obviously less depth than 3 and thus less computationally heavy (see comments by @bitgamma above).   Since the prefix is fixed it doesn\u2019t add much to computation time, it can be easily computed once, cached and used as the derivation root for this kind of key (of course, this requires changes to the firmware). What is more of concern is the dynamic part of the key, especially when using hashes or random UIDs, since it changes completely from app to app without any common prefix. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.305555555555555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "34",
                    "likes": "0",
                    "time": "20/04/2019-07:12:46",
                    "content": "Hi, It took me a while but I finally had to time to think a bit more about the proposal and I am bit concerned about its practicalities. The idea of isolating apps as much as this proposal does is in my opinion not necessarily a good thing. Of course this is use case dependent but I think users would benefit more in isolating a subset of apps, like games vs defi vs social platforms, instead of apps themselves. After all one of the main benefit of blockchain is interoperability and while such proposal does not block interoperability it makes it harder for let say 2 games to easily let players use their items in both. The reason why, is that the proposal hide away the persona account. I\u2019d like to propose a change so that app keys would only act as delegate signing keys on behalf of the persona account. In a way that smart contract can validate that such delegate has indeed right to act on behalf of the persona for that particular action. This means that such appkeys would never perform any transaction and should not hold any fund. This is obviously a considerable change to the idea but this is what I am looking for as an app developer and that is why I proposed a similar mechanism via changes to EIP-712 so that the account remain a identifier shared across app. Appkeys would be able to integrating it at a lower level though, supporting all signature scheme. Also, as mentioned in my previous comment I really think the proposal should add a mechanism to use content-addressable network URI as application names. This should actually be the preferred method since it ensure the application code cannot change (assuming it is not linking to other URI, in which case the browser can show a warning). ENS names and DNS names on the other hand should not be considered for app keys without a warning to the user. After all ENS and DNS are vulnerable to the name owner changing the underlying application. For ENS, if the name resolve to a content-addressable URI as mentioned above, then the application name should be based on the URI and in that case no warning would be necessary. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.39367816091954
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "35",
                    "likes": "0",
                    "time": "26/06/2019-10:28:02",
                    "content": "Hi, Sorry I wasn\u2019t able to answer before to your important comments. Regarding the concern about not necessarily isolating apps, EIP 1775 also mentions \u201ccross app keys\u201d which can use a different naming scheme than ENS or DNS. Their names (to be standardized and referenced in some lists) would be \u201ccak:name\u201d (e.g. \u201ccak:dex\u201d, or \u201ccak:gambling\u201d \u2026) and we would derive an uid in the same way as from ens names. (see here: EIP ERC App Keys: application specific wallet accounts) This would allow several and independant apps to use the same set of accounts (if the user authorizes the visited website to have access to her dex or gambling keys for instance) while still allowing each app to have access to isolated and app specific accounts using the ENS / DNS naming. Agreed about the importance of warning users about ENS / DNS names vulnerabilities, however this is already somewhat the case when you visit a website and trust it to generate transactions on your behalf. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.2
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "36",
                    "likes": "1",
                    "time": "26/06/2019-19:41:25",
                    "content": "    Bunjin:  Regarding the concern about not necessarily isolating apps, EIP 1775 also mentions \u201ccross app keys\u201d which can use a different naming scheme than ENS or DNS.   Ok, I missed the part about \u201ccross app keys\u201d. Maybe the proposal should clarify how these are chosen. Is it the application itself who propose the key to use or is the idea that wallet will ask the user upfront into which \u201ccategory\u201d the app should fit ? Actually this should be the latter as the user is best placed to decide how it organise its applications  Agreed about the importance of warning users about ENS / DNS names vulnerabilities, however this is already somewhat the case when you visit a website and trust it to generate transactions on your behalf.  My point is that it is not the case for content-addressable uri like ipfs. Like a smart contract, such website could be audited or even formaly verified to never do anything without a confirmation popup for example. Then since their content can\u2019t change without a uri change, you are guaranteed that a key derived from it will different. That\u2019s why they should be the first case supported by such proposal. ENS and DNS should be seen as convenience only. So if these redirect to a content-addressable uri, such uri should be used for key derivation, instead of the domain name itself. This way if the domain name change to a new uri, the key is a different one. The one associated with the original uri is thus protected. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.684678416821274
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "37",
                    "likes": "3",
                    "time": "22/08/2019-00:27:29",
                    "content": "At MetaMask, we have begun to experiment internally with a variation of this app keys proposal. Its implementation is a bit simpler: const appKeyPrivKey = ethUtil.keccak(privKey + originString, 256)    github.com/MetaMask/eth-simple-keyring       Add getAppKeyAddress() and support for signing with app keys     by danjm   on 03:02PM - 21 Aug 19 UTC   5 commits   changed 2 files   with 114 additions   and 9 deletions.       This could be exposed as an RPC method to allow any domain to request its own app key associated with the current requested account (if available): const appKey = await provider.send({   method: 'wallet_getAppKeyForAccount',   params: [address1] });  An important thing to define here will be how we generate originString, since this needs to be completely unique to the requesting domain. We may be able to simply include the protocol prefix domain separator like : to separate a unique type string from the main domain identifier. For example, a few valid origin strings might be: https://ethereum-magicians.org ens://danfinlay.eth eth://0x5A0b54D5dc17e0AadC383d2db43B0a0D3E029c4c ipfs://QmVhFMu7ryuFyRXm8gpxWmVuSsLR5H9Z91j8YcTrc9GmUL  This allows each page to have its own per-account deterministic seed. While this does not explicit cover cases of sharing these app keys between pages on its own, I believe that need can be met by composition: Since a domain would get a unique key, and because domains can intercommunicate, one domain (app) could request another domain (signer) to perform its cryptographic operation on some data, with its appKey as a seed, potentially allowing new signing strategies to be added as easily as new websites. This could also pass it to domains that are loading specific signing strategies. This may sound dangerous at first, but if a domain represents a static hash of a trusted cryptographic function implementation, it could be as safe as calling any audited internal dependency. Anyways, posting it here because we\u2019re experimenting with this variant, and I wanted to get it out there in case anyone else is about to implement the parent EIP, which I may revise or submit an alternative to soon. ",
                    "links": [
                        "https://github.com/danjm",
                        "https://github.com/MetaMask/eth-simple-keyring/pull/16",
                        "https://github.com/danjm",
                        "https://github.com/MetaMask/eth-simple-keyring/pull/16"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.806141774891774
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "38",
                    "likes": "1",
                    "time": "04/09/2019-00:50:57",
                    "content": "I haven\u2019t read through everything here but I wanted to drop a quick comment: I\u2019m not a fan of privacy theater.  People can create multiple accounts all they want, but until there are better mechanisms for laundering assets between accounts anything that tries to separate accounts is just privacy theater.  We have seen this in Bitcoin that even with the UTXO model and people actively taking steps to remain anonymous they still get pinpointed via chain analysis. With Ethereum, I feel like it is made much more clear to the user \u201cyour transactions are all linkable to each other\u201d, rather than giving them a false sense of privacy where privacy doesn\u2019t exist.  If people really want to disassociate their various transactions, they have to go through a lot of effort and while I do think that we should try to enable/simplify that (e.g., tornado.cash) that, we don\u2019t yet have the primitives to achieve true privacy on Ethereum. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.613636363636364
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "39",
                    "likes": "1",
                    "time": "04/09/2019-05:40:51",
                    "content": "    MicahZoltu:  I\u2019m not a fan of privacy theater.   This proposal is not motivated mostly by privacy, but also has implications for supporting additional key types, and other cryptography, where an app requires access to a unique secret. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Bunjin",
                    "index": "40",
                    "likes": "1",
                    "time": "15/11/2019-07:18:05",
                    "content": "We updated EIP1775 to a skinnier and simpler version, using what Dan suggested in one of his last posts in this thread: const appKeyPrivKey = ethUtil.keccak(privKey + originString, 256)  See here:   github.com   ethereum/EIPs/blob/master/EIPS/eip-1775.md --- eip: 1775 title: App Keys, application specific wallet accounts author: Vincent Eli (@Bunjin), Dan Finlay (@DanFinlay), Erik Marks (@rekmarks) discussions-to: https://ethereum-magicians.org/t/eip-erc-app-keys-application-specific-wallet-accounts/2742 status: Draft type: Standards Track category: ERC created: 2019-02-20 ---  <!--You can leave these HTML comments in your merged EIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new EIPs. Note that an EIP number will be assigned by an editor. When opening a pull request to submit your EIP, please use an abbreviated title in the filename, `eip-draft_title_abbrev.md`. The title should be 44 characters or less.--> ## Simple Summary <!--\"If you can't explain it simply, you don't understand it well enough.\" Provide a simplified and layman-accessible explanation of the EIP.-->  Among others cryptographic applications, scalability and privacy solutions for ethereum blockchain require that an user performs a significant amount of signing operations. It may also require her to watch some state and be ready to sign data automatically (e.g. sign a state or contest a withdraw). The way wallets currently implement accounts poses several obstacles to the development of a complete web3.0 experience both in terms of UX, security and privacy.  This proposal describes a standard and api for a new type of wallet accounts that are derived specifically for a each given application. We propose to call them `app keys`. They allow to isolate the accounts used for each application, thus potentially increasing privacy. They also allow to give more control to the applications developers over account management and signing delegation. For these app keys, wallets can have a more permissive level of security (e.g. not requesting user's confirmation) while keeping main accounts secure. Finally wallets can also implement a different behavior such as allowing to sign transactions without broadcasting them.  This new accounts type can allow to significantly improve UX and permit new designs for applications of the crypto permissionned web.     This file has been truncated. show original      ",
                    "links": [
                        "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1775.md",
                        "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1775.md"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.670600233100234
                }
            ]
        }
    ],
    "group_index": "718"
}