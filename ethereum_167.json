{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-5773-context-dependent-multi-asset-tokens/11326",
            "title": "EIP-5773: Context-Dependent Multi-Asset Tokens ",
            "index": 11326,
            "category": [
                "EIPs"
            ],
            "tags": [
                "nft"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/ThunderDeliverer",
                    "index": "1",
                    "likes": "4",
                    "time": "15/10/2022-19:44:56",
                    "content": "We are proposing a MultiResource token standard, where one token can be represented by multiple different resources. The whole concept has been outlined in the RMRK MultiResource documentation as well as our EIP:   eip: 5773 title: Context-Dependent Multi-Asset Tokens description: An interface for Multi-Asset tokens with context dependent asset type output controlled by owner\u2019s preference. author: Bruno \u0160kvorc, Cicada, Steven Pineda, Stevan Bogosavljevic, Jan Turk discussions-to: here status: Draft type: Standards Track category: ERC created: 2022-10-10 requires: 165, 721  Abstract The Multi-Asset NFT standard allows for the construction of a new primitive: context-dependent output of information per single NFT. The context-dependent output of information means that the asset in an appropriate format is displayed based on how the token is being accessed. I.e. if the token is being opened in an e-book reader, the PDF asset is displayed, if the token is opened in the marketplace, the PNG or the SVG asset is displayed, if the token is accessed from within a game, the 3D model asset is accessed and if the token is accessed by the (Internet of Things) IoT hub, the asset providing the necessary addressing and specification information is accessed. An NFT can have multiple assets (outputs), which can be any kind of file to be served to the consumer, and orders them by priority. They do not have to match in mimetype or tokenURI, nor do they depend on one another. Assets are not standalone entities, but should be thought of as \u201cnamespaced tokenURIs\u201d that can be ordered at will by the NFT owner, but only modified, updated, added, or removed if agreed on by both the owner of the token and the issuer of the token.  Motivation With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having multiple assets associated with a single NFT allows for greater utility, usability and forward compatibility. In the four years since EIP-721 was published, the need for additional functionality has resulted in countless extensions. This EIP improves upon EIP-721 in the following areas:  Cross-metaverse compatibility Multi-media output Media redundancy NFT evolution   Cross-metaverse compatibility At the time of writing this proposal, the metaverse is still a fledgling, not full defined, term. No matter how the definition of metaverse evolves, the proposal can support any number of different implementations. Cross-metaverse compatibility could also be referred to as cross-engine compatibility. An example of this is where a cosmetic item for game A is not available in game B because the frameworks are incompatible. Such NFT can be given further utility by means of new additional assets: more games, more cosmetic items, appended to the same NFT. Thus, a game cosmetic item as an NFT becomes an ever-evolving NFT of infinite utility. The following is a more concrete example. One asset is a cosmetic item for game A, a file containing the cosmetic assets. Another is a cosmetic asset file for game B. A third is a generic asset intended to be shown in catalogs, marketplaces, portfolio trackers, or other generalized NFT viewers, containing a representation, stylized thumbnail, and animated demo/trailer of the cosmetic item. This EIP adds a layer of abstraction, allowing game developers to directly pull asset data from a user\u2019s NFTs instead of hard-coding it.  Multi-media output An NFT of an eBook can be represented as a PDF, MP3, or some other format, depending on what software loads it. If loaded into an eBook reader, a PDF should be displayed, and if loaded into an audiobook application, the MP3 representation should be used. Other metadata could be present in the NFT (perhaps the book\u2019s cover image) for identification on various marketplaces, Search Engine Result Pages (SERPs), or portfolio trackers.  Media redundancy Many NFTs are minted hastily without best practices in mind - specifically, many NFTs are minted with metadata centralized on a server somewhere or, in some cases, a hardcoded IPFS gateway which can also go down, instead of just an IPFS hash. By adding the same metadata file as different assets, e.g., one asset of a metadata and its linked image on Arweave, one asset of this same combination on Sia, another of the same combination on IPFS, etc., the resilience of the metadata and its referenced information increases exponentially as the chances of all the protocols going down at once become less likely.  NFT evolution Many NFTs, particularly game related ones, require evolution. This is especially the case in modern metaverses where no metaverse is actually a metaverse - it is just a multiplayer game hosted on someone\u2019s server which replaces username/password logins with reading an account\u2019s NFT balance. When the server goes down or the game shuts down, the player ends up with nothing (loss of experience) or something unrelated (assets or accessories unrelated to the game experience, spamming the wallet, incompatible with other \u201cverses\u201d - see cross-metaverse compatibility above). With Multi-Asset NFTs, a minter or another pre-approved entity is allowed to suggest a new asset to the NFT owner who can then accept it or reject it. The asset can even target an existing asset which is to be replaced. Replacing an asset could, to some extent, be similar to replacing an EIP-721 token\u2019s URI. When an asset is replaced a clear line of traceability remains; the old asset is still reachable and verifiable. Replacing an asset\u2019s metadata URI obscures this lineage. It also gives more trust to the token owner if the issuer cannot replace the asset of the NFT at will. The propose-accept asset replacement mechanic of this proposal provides this assurance. This allows level-up mechanics where, once enough experience has been collected, a user can accept the level-up. The level-up consists of a new asset being added to the NFT, and once accepted, this new asset replaces the old one. As a concrete example, think of Pokemon\u2122\ufe0f evolving - once enough experience has been attained, a trainer can choose to evolve their monster. With Multi-Asset NFTs, it is not necessary to have centralized control over metadata to replace it, nor is it necessary to airdrop another NFT into the user\u2019s wallet - instead, a new Raichu asset is minted onto Pikachu, and if accepted, the Pikachu asset is gone, replaced by Raichu, which now has its own attributes, values, etc. Alternative example of this, could be version control of an IoT device\u2019s firmware. An asset could represent its current firmware and once an update becomes available, the current asset could be replaced with the one containing the updated firmware.  Specification The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119. /// @title EIP-5773 Multi-Asset context-dependent tokens /// @dev See https://eips.ethereum.org/EIPS/eip-5773 /// @dev Note: the ERC-165 identifier for this interface is 0xd1526708.  pragma solidity ^0.8.16;  interface IMultiAsset {     /**      * @notice Used to notify listeners that an asset object is initialised at `assetId`.      * @param assetId ID of the asset that was initialised      */     event AssetSet(uint64 assetId);      /**      * @notice Used to notify listeners that an asset object at `assetId` is added to token's pending asset      *  array.      * @param tokenId ID of the token that received a new pending asset      * @param assetId ID of the asset that has been added to the token's pending assets array      * @param replacesId ID of the asset that would be replaced      */     event AssetAddedToToken(         uint256 indexed tokenId,         uint64 indexed assetId,         uint64 indexed replacesId     );      /**      * @notice Used to notify listeners that an asset object at `assetId` is accepted by the token and migrated      *  from token's pending assets array to active assets array of the token.      * @param tokenId ID of the token that had a new asset accepted      * @param assetId ID of the asset that was accepted      * @param replacesId ID of the asset that was replaced      */     event AssetAccepted(         uint256 indexed tokenId,         uint64 indexed assetId,         uint64 indexed replacesId     );      /**      * @notice Used to notify listeners that an asset object at `assetId` is rejected from token and is dropped      *  from the pending assets array of the token.      * @param tokenId ID of the token that had an asset rejected      * @param assetId ID of the asset that was rejected      */     event AssetRejected(uint256 indexed tokenId, uint64 indexed assetId);      /**      * @notice Used to notify listeners that token's priority array is reordered.      * @param tokenId ID of the token that had the asset priority array updated      */     event AssetPrioritySet(uint256 indexed tokenId);      /**      * @notice Used to notify listeners that owner has granted an approval to the user to manage the assets of a      *  given token.      * @dev Approvals must be cleared on transfer      * @param owner Address of the account that has granted the approval for all token's assets      * @param approved Address of the account that has been granted approval to manage the token's assets      * @param tokenId ID of the token on which the approval was granted      */     event ApprovalForAssets(         address indexed owner,         address indexed approved,         uint256 indexed tokenId     );      /**      * @notice Used to notify listeners that owner has granted approval to the user to manage assets of all of their      *  tokens.      * @param owner Address of the account that has granted the approval for all assets on all of their tokens      * @param operator Address of the account that has been granted the approval to manage the token's assets on all of the      *  tokens      * @param approved Boolean value signifying whether the permission has been granted (`true`) or revoked (`false`)      */     event ApprovalForAllForAssets(         address indexed owner,         address indexed operator,         bool approved     );      /**      * @notice Accepts an asset at from the pending array of given token.      * @dev Migrates the asset from the token's pending asset array to the token's active asset array.      * @dev Active assets cannot be removed by anyone, but can be replaced by a new asset.      * @dev Requirements:      *      *  - The caller must own the token or be approved to manage the token's assets      *  - `tokenId` must exist.      *  - `index` must be in range of the length of the pending asset array.      * @dev Emits an {AssetAccepted} event.      * @param tokenId ID of the token for which to accept the pending asset      * @param index Index of the asset in the pending array to accept      * @param assetId Id of the asset expected to be in the index      */     function acceptAsset(         uint256 tokenId,         uint256 index,         uint64 assetId     ) external;      /**      * @notice Rejects an asset from the pending array of given token.      * @dev Removes the asset from the token's pending asset array.      * @dev Requirements:      *      *  - The caller must own the token or be approved to manage the token's assets      *  - `tokenId` must exist.      *  - `index` must be in range of the length of the pending asset array.      * @dev Emits a {AssetRejected} event.      * @param tokenId ID of the token that the asset is being rejected from      * @param index Index of the asset in the pending array to be rejected      * @param assetId Id of the asset expected to be in the index      */     function rejectAsset(         uint256 tokenId,         uint256 index,         uint64 assetId     ) external;      /**      * @notice Rejects all assets from the pending array of a given token.      * @dev Effectively deletes the pending array.      * @dev Requirements:      *      *  - The caller must own the token or be approved to manage the token's assets      *  - `tokenId` must exist.      * @dev Emits a {AssetRejected} event with assetId = 0.      * @param tokenId ID of the token of which to clear the pending array      * @param maxRejections to prevent from rejecting assets which arrive just before this operation.      */     function rejectAllAssets(uint256 tokenId, uint256 maxRejections) external;      /**      * @notice Sets a new priority array for a given token.      * @dev The priority array is a non-sequential list of `uint16`s, where the lowest value is considered highest      *  priority.      * @dev Value `0` of a priority is a special case equivalent to uninitialised.      * @dev Requirements:      *      *  - The caller must own the token or be approved to manage the token's assets      *  - `tokenId` must exist.      *  - The length of `priorities` must be equal the length of the active assets array.      * @dev Emits a {AssetPrioritySet} event.      * @param tokenId ID of the token to set the priorities for      * @param priorities An array of priorities of active assets. The succession of items in the priorities array      *  matches that of the succession of items in the active array      */     function setPriority(uint256 tokenId, uint16[] calldata priorities)         external;      /**      * @notice Used to retrieve IDs of the active assets of given token.      * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call      *  `getAssetMetadata(tokenId, assetId)`.      * @dev You can safely get 10k      * @param tokenId ID of the token to retrieve the IDs of the active assets      * @return uint64[] An array of active asset IDs of the given token      */     function getActiveAssets(uint256 tokenId)         external         view         returns (uint64[] memory);      /**      * @notice Used to retrieve IDs of the pending assets of given token.      * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call      *  `getAssetMetadata(tokenId, assetId)`.      * @param tokenId ID of the token to retrieve the IDs of the pending assets      * @return uint64[] An array of pending asset IDs of the given token      */     function getPendingAssets(uint256 tokenId)         external         view         returns (uint64[] memory);      /**      * @notice Used to retrieve the priorities of the active assets of a given token.      * @dev Asset priorities are a non-sequential array of uint16 values with an array size equal to active asset      *  priorites.      * @param tokenId ID of the token for which to retrieve the priorities of the active assets      * @return uint16[] An array of priorities of the active assets of the given token      */     function getActiveAssetPriorities(uint256 tokenId)         external         view         returns (uint16[] memory);      /**      * @notice Used to retrieve the asset that will be replaced if a given asset from the token's pending array      *  is accepted.      * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call      *  `getAssetMetadata(tokenId, assetId)`.      * @param tokenId ID of the token to check      * @param newAssetId ID of the pending asset which will be accepted      * @return uint64 ID of the asset which will be replaced      */     function getAssetReplacements(uint256 tokenId, uint64 newAssetId)         external         view         returns (uint64);      /**      * @notice Used to fetch the asset metadata of the specified token's active asset with the given index.      * @dev Can be overriden to implement enumerate, fallback or other custom logic.      * @param tokenId ID of the token from which to retrieve the asset metadata      * @param assetId Asset Id, must be in the active assets array      * @return string The metadata of the asset belonging to the specified index in the token's active assets      *  array      */     function getAssetMetadata(uint256 tokenId, uint64 assetId)         external         view         returns (string memory);      /**      * @notice Used to grant permission to the user to manage token's assets.      * @dev This differs from transfer approvals, as approvals are not cleared when the approved party accepts or      *  rejects an asset, or sets asset priorities. This approval is cleared on token transfer.      * @dev Only a single account can be approved at a time, so approving the `0x0` address clears previous approvals.      * @dev Requirements:      *      *  - The caller must own the token or be an approved operator.      *  - `tokenId` must exist.      * @dev Emits an {ApprovalForAssets} event.      * @param to Address of the account to grant the approval to      * @param tokenId ID of the token for which the approval to manage the assets is granted      */     function approveForAssets(address to, uint256 tokenId) external;      /**      * @notice Used to retrieve the address of the account approved to manage assets of a given token.      * @dev Requirements:      *      *  - `tokenId` must exist.      * @param tokenId ID of the token for which to retrieve the approved address      * @return address Address of the account that is approved to manage the specified token's assets      */     function getApprovedForAssets(uint256 tokenId)         external         view         returns (address);      /**      * @notice Used to add or remove an operator of assets for the caller.      * @dev Operators can call {acceptAsset}, {rejectAsset}, {rejectAllAssets} or {setPriority} for any token      *  owned by the caller.      * @dev Requirements:      *      *  - The `operator` cannot be the caller.      * @dev Emits an {ApprovalForAllForAssets} event.      * @param operator Address of the account to which the operator role is granted or revoked from      * @param approved The boolean value indicating whether the operator role is being granted (`true`) or revoked      *  (`false`)      */     function setApprovalForAllForAssets(address operator, bool approved)         external;      /**      * @notice Used to check whether the address has been granted the operator role by a given address or not.      * @dev See {setApprovalForAllForAssets}.      * @param owner Address of the account that we are checking for whether it has granted the operator role      * @param operator Address of the account that we are checking whether it has the operator role or not      * @return bool The boolean value indicating whether the account we are checking has been granted the operator role      */     function isApprovedForAllForAssets(address owner, address operator)         external         view         returns (bool); }  The getAssetMetadata function returns the asset\u2019s metadata URI. The metadata, to which the metadata URI of the asset points, MAY contain a JSON response with the following fields: {   \"title\": \"Asset Metadata\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"type\": \"string\",       \"description\": \"Identifies the name of the asset associated with the asset\"     },     \"description\": {       \"type\": \"string\",       \"description\": \"Identifies the general notes, abstracts, or summaries about the contents of the asset\"     },     \"type\": {       \"type\": \"string\",       \"description\": \"Identifies the definition of the type of content of the asset\"     },     \"locale\": {       \"type\": \"string\",       \"description\": \"Identifies metadata locale in ISO 639-1 format for translations and localisation of the asset\"     },     \"license\": {       \"type\": \"string\",       \"description\": \"Identifies the license attached to the asset\"     },     \"licenseUri\": {       \"type\": \"string\",       \"description\": \"Identifies the URI to the license statement of the license attached to the asset\"     },     \"mediaUri\": {       \"type\": \"string\",       \"description\": \"Identifies the URI of the main media file associated with the asset\"     },     \"thumbnailUri\": {       \"type\": \"string\",       \"description\": \"Identifies the URI of the thumbnail image associated with the asset to be used for preview of the asset in the wallets and client applications (the recommended maximum size is 350x350 px)\"     },     \"externalUri\": {       \"type\": \"string\",       \"description\": \"Identifies the URI to the additional information about the subject or content of the asset\"     },     \"properties\": {       \"type\": \"object\",       \"properties\": \"Identifies the optional custom attributes of the asset\"     }   } }  While this is the suggested JSON schema for the asset metadata, it is not enforced and MAY be structured completely differently based on implementer\u2019s preference. The optional properties of the metadata JSON MAY include the following fields, or it MAY incorporate any number of custom fields, but MAY also not be included in the schema at all:     \"properties\": {       \"rarity\": {         \"type\": \"string\",         \"value\": \"epic\"       },       \"color\": {         \"type\": \"string\",         \"value\": \"red\"       },       \"height\": {         \"type\": \"float\",         \"value\": 192.4       },       \"tags\": {         \"type\": \"array\",         \"value\": [\"music\", \"2020\", \"best\"]       }     }   Rationale Designing the proposal, we considered the following questions:  Should we use Asset or Resource when referring to the structure that comprises the token?  The original idea was to call the proposal Multi-Resource, but while this denoted the broadness of the structures that could be held by a single token, the term asset represents it better. An asset is defined as something that is owned by a person, company, or organization, such as money, property, or land. This is the best representation of what an asset of this proposal can be. An asset in this proposal can be a multimedia file, technical information, a land deed, or anything that the implementer has decided to be an asset of the token they are implementing.  Why are EIP-712 permit-style signatures to manage approvals not used?  For consistency. This proposal extends EIP-721 which already uses 1 transaction for approving operations with tokens. It would be inconsistent to have this and also support signing messages for operations with assets.  Why use indexes?  To reduce the gas consumption. If the asset ID was used to find which asset to accept or reject, iteration over arrays would be required and the cost of the operation would depend on the size of the active or pending assets arrays. With the index, the cost is fixed. A list of active and pending assets arrays per token need to be maintained, since methods to get them are part of the proposed interface. To avoid race conditions in which the index of an asset changes, the expected asset ID is included in operations requiring asset index, to verify that the asset being accessed using the index is the expected asset. Implementation that would internally keep track of indices using mapping was attempted. The average cost of adding an asset to a token increased by over 25%, costs of accepting and rejecting assets also increased 4.6% and 7.1% respectively. We concluded that it is not necessary for this proposal and can be implemented as an extension for use cases willing to accept this cost. In the sample implementation provided, there are several hooks which make this possible.  Why is a method to get all the assets not included?  Getting all assets might not be an operation necessary for all implementers. Additionally, it can be added either as an extension, doable with hooks, or can be emulated using an indexer.  Why is pagination not included?  Asset IDs use uint64, testing has confirmed that the limit of IDs you can read before reaching the gas limit is around 30.000. This is not expected to be a common use case so it is not a part of the interface. However, an implementer can create an extension for this use case if needed.  How does this proposal differ from the other proposals trying to address a similar problem?  After reviewing them, we concluded that each contains at least one of these limitations:  Using a single URI which is replaced as new assets are needed, this introduces a trust issue for the token owner. Focusing only on a type of asset, while this proposal is asset type agnostic. Having a different token for each new use case, this means that the token is not forward-compatible.   Multi-Asset Storage Schema Assets are stored within a token as an array of uint64 identifiers. In order to reduce redundant on-chain string storage, multi asset tokens store assets by reference via inner storage. An asset entry on the storage is stored via a uint64 mapping to asset data. An asset array is an array of these uint64 asset ID references. Such a structure allows that, a generic asset can be added to the storage one time, and a reference to it can be added to the token contract as many times as we desire. Implementers can then use string concatenation to procedurally generate a link to a content-addressed archive based on the base SRC in the asset and the token ID. Storing the asset in a new token will only take 16 bytes of storage in the asset array per token for recurrent as well as tokenId dependent assets. Structuring token\u2019s assets in such a way allows for URIs to be derived programmatically through concatenation, especially when they differ only by tokenId.  Propose-Commit pattern for asset addition Adding assets to an existing token MUST be done in the form of a propose-commit pattern to allow for limited mutability by a 3rd party. When adding an asset to a token, it is first placed in the \u201cPending\u201d array, and MUST be migrated to the \u201cActive\u201d array by the token\u2019s owner. The \u201cPending\u201d assets array SHOULD be limited to 128 slots to prevent spam and griefing.  Asset management Several functions for asset management are included. In addition to permissioned migration from \u201cPending\u201d to \u201cActive\u201d, the owner of a token MAY also drop assets from both the active and the pending array \u2013 an emergency function to clear all entries from the pending array MUST also be included.  Backwards Compatibility The MultiAsset token standard has been made compatible with EIP-721 in order to take advantage of the robust tooling available for implementations of EIP-721 and to ensure compatibility with existing EIP-721 infrastructure.  Test Cases Tests are included in multiasset.ts. To run them in terminal, you can use the following commands: cd ../assets/eip-5773 npm install npx hardhat test   Reference Implementation See MultiAssetToken.sol.  Security Considerations The same security considerations as with EIP-721 apply: hidden logic may be present in any of the functions, including burn, add asset, accept asset, and more. Caution is advised when dealing with non-audited contracts.  Copyright Copyright and related rights waived via CC0. ",
                    "links": [
                        "https://github.com/Swader",
                        "https://github.com/CicadaNCR",
                        "https://github.com/steven2308",
                        "https://github.com/stevyhacker",
                        "https://github.com/ThunderDeliverer",
                        "https://eips.ethereum.org/EIPS/eip-721",
                        "https://eips.ethereum.org/EIPS/eip-712",
                        "https://eips.ethereum.org/EIPS/eip-721",
                        "https://github.com/ethereum/EIPs/assets/eip-5773/test/multiasset.ts",
                        "https://github.com/ethereum/EIPs/assets/eip-5773/contracts/MultiAssetToken.sol",
                        "https://eips.ethereum.org/EIPS/eip-721",
                        "https://github.com/ethereum/EIPs/LICENSE.md"
                    ],
                    "GPT-summary": null,
                    "GPT-proposal-categories": null,
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.8768204384944465
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "2",
                    "likes": "1",
                    "time": "01/11/2022-15:18:47",
                    "content": "There are at least two other EIPs that are working on solving similar ideas. One of them is: EIP-4955: Vendor Metadata Extension for NFTs by @0xnacho. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.291666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "3",
                    "likes": "1",
                    "time": "01/11/2022-15:30:04",
                    "content": "If the pending array order is not preserved when accepting resources, and two acceptResource transactions are in-flight, could the owner end up approving a resource they didn\u2019t intend? I\u2019d maybe suggest not using index directly, or preserving array order, or using a permit-style EIP-712 signature to do all the pending changes work off-chain. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ThunderDeliverer",
                    "index": "4",
                    "likes": "1",
                    "time": "15/11/2022-13:18:09",
                    "content": "We\u2019ve take a look the the proposals that are addressing similar problems, but we found that they all include at least one of the following limitations:   Using a single URI which is replaced as new resources are needed, this introduces a trust issue for the token owner.   Focusing only on a type of resource, while this proposal is resource type agnostic.   Having a different token for each new use case, this means that the token is not forward-compatible.   In case we misinterpreted any of them, we will be glad to receive any feedback. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.2229437229437226
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ThunderDeliverer",
                    "index": "5",
                    "likes": "2",
                    "time": "15/11/2022-13:21:31",
                    "content": "We addressed the race condition where unintended resource managed by index could be accepted/rejected by adding ID of the resource expected to be located at the given index to the calls, this way a check can be added to ensure only the intended resource is accepted/rejected. We also reviewed the possibility of doing permit-style EIP-721 signatures, but found that since this proposal extends ERC-721 which already uses 1 transaction for approving operations with tokens. It would be inconsistent to have this and also support signing messages for operations with resources. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "6",
                    "likes": "0",
                    "time": "16/11/2022-05:47:22",
                    "content": "Would it make sense to collaborate with those authors (eg. @0xnacho)? Do you think your proposal solves the same issues as theirs? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "7",
                    "likes": "0",
                    "time": "16/11/2022-05:54:56",
                    "content": "I think EIP-4494: Permit for ERC-721 NFTs extends EIP-721 with a permit, so I don\u2019t think it would be unusual to support off-chain signatures. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ThunderDeliverer",
                    "index": "8",
                    "likes": "0",
                    "time": "16/11/2022-22:45:14",
                    "content": "I\u2019m not really sure\u2026 Our proposal solves the issue that EIP-4955 is tackling, but it also supports a significantly broader spectrum of applications. You could use EIP-5773 for cross-metaverse compatibility (this is what EIP-4955 tackles), but also for any kind of media consuming dApps (ebooks, music, art,\u2026), and real world applications (realastate, smart cities, collaborative robotics, IoT, \u2026), and probably much more that we haven\u2019t even considered. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.491071428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ThunderDeliverer",
                    "index": "9",
                    "likes": "0",
                    "time": "16/11/2022-22:48:33",
                    "content": "It does and I\u2019ve used it before, but we feel that EIP-4494 could be applied to the EIP-5773 by an implementer. It seems that including this would add additional functionality, but is not necessary for the proposal. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "10",
                    "likes": "2",
                    "time": "25/11/2022-21:14:00",
                    "content": "We\u2019re trying a new process where we get a volunteer peer reviewer to read through your proposal and post any feedback here. Your peer reviewer is @waichung! If any of this EIP\u2019s authors would like to participate in the volunteer peer review process, shoot me a message!  @waichung please take a look through EIP-5773 and comment here with any feedback or questions. Thanks! ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-5773"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.157670454545454
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/WaiChung",
                    "index": "11",
                    "likes": "0",
                    "time": "28/11/2022-07:26:01",
                    "content": "100%. I\u2019m in the middle of it. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/WaiChung",
                    "index": "12",
                    "likes": "3",
                    "time": "28/11/2022-12:03:16",
                    "content": "Hi @ThunderDeliverer, I dug into the implementation of MultiAssetToken.sol and have some questions regarding the _addAssetEntry and _addAssetToToken APIs. I don\u2019t see those APIs being consumed anywhere so I\u2019m just wondering if there\u2019re more files you can share with me so I can get a holistic view of the implementation. I look forward to your reply. Cheers! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 8.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ThunderDeliverer",
                    "index": "13",
                    "likes": "0",
                    "time": "29/11/2022-21:32:06",
                    "content": "Hi @WaiChung, thank you for prompt review. We have an example repository with all of our \u201clegos\u201d. The MultiAsset lego is our implementation of EIP-5773 and you can take a look at it here: evm-sample-contracts/README.md at master \u00b7 rmrk-team/evm-sample-contracts \u00b7 GitHub We also provide a user journey for MultiAsset that uses both here: evm-sample-contracts/multiAssetUserJourney.ts at master \u00b7 rmrk-team/evm-sample-contracts \u00b7 GitHub I hope this is useful. Cheers! ",
                    "links": [
                        "https://github.com/rmrk-team/evm-sample-contracts/blob/master/scripts/multiAssetUserJourney.ts"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/stoicdev0",
                    "index": "14",
                    "likes": "0",
                    "time": "01/12/2022-23:37:15",
                    "content": "The reason we provide them but don\u2019t use them nor include them in the interface is to have a non opinionated  implementation. This is inspired by OpenZeppelin\u2019s implementation of ERC721, where for instance mint is only included as an internal method (_mint), but is up to the final implementer to add it with the right permissioning. We believe this applies exactly to the methods you\u2019re mentioning. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.5357142857142865
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ThunderDeliverer",
                    "index": "15",
                    "likes": "0",
                    "time": "06/12/2022-23:27:11",
                    "content": "Hey, I don\u2019t want to pressure you, but have you managed to go through our proposal yet? Do you have any feedback or additional questions? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/WaiChung",
                    "index": "16",
                    "likes": "0",
                    "time": "07/12/2022-01:52:09",
                    "content": "apologies. My go live date got brought forward and the whole tech team is in fire fighting mode right now. I will try complete this by this week. Thank you for your patience! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.933847402597403
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ThunderDeliverer",
                    "index": "17",
                    "likes": "0",
                    "time": "17/12/2022-20:41:14",
                    "content": "I hope your live date went as planned  Do you have some time available for the review in the near future? We are really looking forward to your feedback! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.886363636363637
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/WaiChung",
                    "index": "18",
                    "likes": "0",
                    "time": "19/12/2022-07:26:19",
                    "content": "Thanks for asking! Everything went well. Sorry I wanted to get on it last week but got very sick. I feel better now and will get on the review this week. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.321428571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/WaiChung",
                    "index": "19",
                    "likes": "0",
                    "time": "21/12/2022-10:12:20",
                    "content": "Hey @ThunderDeliverer, I found some time to review the code this week. I\u2019m currently in the process of doing so. I\u2019ve cloned your code and starting testing what I think are edge cases. If you go to this link eip-5773/multiasset.ts at master \u00b7 waichung/eip-5773 \u00b7 GitHub from line 403 to 437. There\u2019s an unexpected error. Could you clarify if this was by design? I\u2019d think that there should be some check in the _addAssetToToken method  to prevent this from happening but maybe I\u2019m using it wrongly? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/stoicdev0",
                    "index": "20",
                    "likes": "0",
                    "time": "21/12/2022-12:09:16",
                    "content": "There\u2019s a bug we discovered 2 weeks ago in the sample implementation but I haven\u2019t taken the time to push the fix to the EIPs repo. It\u2019s related with overwriting so hopefully it\u2019s the same one you\u2019re facing. I\u2019ll do it in the next hours and ping you. Thanks! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.3125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/stoicdev0",
                    "index": "21",
                    "likes": "0",
                    "time": "21/12/2022-12:32:15",
                    "content": "I created the PR already, will try to get it merged soon but in the meantime you can try with the fix from the PR here I included your failing test and with this fix it passes.  I\u2019m glad you found this problem, it really shows you\u2019re doing a detailed review, thanks @WaiChung ! Edit: Fix now merged. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.6875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/WaiChung",
                    "index": "22",
                    "likes": "1",
                    "time": "03/01/2023-03:59:32",
                    "content": "Thank you so much! I hope you\u2019ve had a good break and managed to spend some time with your loved ones. I will be continuing work on it this week. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.749999999999999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/WaiChung",
                    "index": "23",
                    "likes": "0",
                    "time": "05/01/2023-04:33:21",
                    "content": "Hey @stoicdev0 I\u2019ve a couple of questions regarding implementation.   I cannot find any documentation around the removeItemByIndex method used in the acceptAsset and rejectAsset functions. I assume it\u2019s of O(n) complexity. Do you think it makes sense to do it in O(1) time? This way perhaps we can remove the 128 upper bound on the _pendingAssets list and make it consistent with how _addAssetsToToken is designed?   Do you think it makes sense for us to add a unit test to handle the race condition below?    We addressed the race condition where unintended resource managed by index could be accepted/rejected by adding ID of the resource expected to be located at the given index to the calls, this way a check can be added to ensure only the intended resource is accepted/rejected.  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.1875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/stoicdev0",
                    "index": "24",
                    "likes": "0",
                    "time": "05/01/2023-20:27:36",
                    "content": " The implementation of removeItemByIndex is here it\u2019s O(1) because we know the index (and it\u2019s actually the reason we require indexes, so we don\u2019t have to loop to search). The 128 limitation is just for practical reasons, we consider it would be unmanageable for UIs to go beyond that. We have tests for this on our original repo but I just see they are not updated in the EIP repo. Let me add them and ping you. We have 3 tests for accept, reject and reject all.  Thanks again for your time  ",
                    "links": [
                        "https://github.com/rmrk-team/evm/blob/master/test/behavior/multiasset.ts#L251",
                        "https://github.com/rmrk-team/evm/blob/master/test/behavior/multiasset.ts#L333",
                        "https://github.com/rmrk-team/evm/blob/master/test/behavior/multiasset.ts#L340"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.958333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/0xnacho",
                    "index": "25",
                    "likes": "0",
                    "time": "13/01/2023-19:27:14",
                    "content": "EIP 4955 has been moved to Last Call. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wrencrypt",
                    "index": "26",
                    "likes": "0",
                    "time": "27/01/2023-16:30:47",
                    "content": "I would suggest adding a ConsecutiveAssetAddedToTokens Event. It would allow you to add one asset to all tokens pending lists more efficiently (or when adding tokenId dependent baseURL assets): event ConsecutiveAssetAddedToTokens(         uint256 indexed fromTokenId,         uint256 toTokenId,         uint64 indexed assetId,         uint64 indexed replacesId     );  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/stoicdev0",
                    "index": "27",
                    "likes": "0",
                    "time": "27/01/2023-21:30:59",
                    "content": "    wrencrypt:  allow you to add one asset to all tokens pending lists more efficiently (or when adding tokenId dependent baseURL   Maybe a method instead of an event? It\u2019s a good idea, but I don\u2019t think it\u2019s crucial for the implementation, we try to keep the interface minimal. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wrencrypt",
                    "index": "28",
                    "likes": "0",
                    "time": "28/01/2023-13:53:13",
                    "content": "The implementation method would need to send 10k AssetAddedToToken Events, right? This could cost 15 million gas / around 0.3eth at current gas price. In many cases it will also also not be possible to implement this in a single transaction because of the block gas limit. Considering this will likely be the most common use case, a O(1) instead of O(N) event seems necessary to me and would allow adding assets to all tokens pretty much for free. Not including it from the start may result in a similar messy situation like with ERC-2309, where some indexers support it and some don\u2019t. Adding a second interface to this EIP or using a less opinionated event like AssetAddedToAllTokens are also options. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.4367559523809526
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/stoicdev0",
                    "index": "29",
                    "likes": "0",
                    "time": "30/01/2023-12:01:27",
                    "content": "It\u2019s a great point.  What about replacing AssetAddedToToken with AssetAddedToTokens? The second one receiving the range as you recommend. I fear if we have 2 events, not everyone will track them both.  The ranged version still does the job for a single token. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.214285714285714
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wrencrypt",
                    "index": "30",
                    "likes": "0",
                    "time": "31/01/2023-16:47:24",
                    "content": "Yes, I think that will work. With the range it will also be good to address wether tokenIds need to exist or not. If they don\u2019t have to exist, are they ignored or is the asset still added to the token after the mint happened (probably not good for indexers). Another question I\u2019ve had is wether you always have to emit both an AssetAddedToToken and AssetAccepted Event in order to add an asset to the active list. It could make sense to only require AssetsAccepted and allow skipping AssetAddedToToken especially during the mint process to add the initial asset. It would also be possible to allow assets being added to the active list without emitting any events during the mint, but this might be bad for indexers. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.657407407407407
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/stoicdev0",
                    "index": "31",
                    "likes": "0",
                    "time": "21/02/2023-14:11:50",
                    "content": "We ended up with this:     event AssetAddedToTokens(         uint256[] tokenIds,         uint64 indexed assetId,         uint64 indexed replacesId     );  We feel is more flexible than a range, and you can still emit it with a few thousands before hitting gas limits. Regarding the 2 events, you said it your self: it would be bad for indexers. We wouldn\u2019t be able to distinguish pending assets from active assets. And only pending can be rejected, so it\u2019s an important distinction. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.261904761904762
                }
            ]
        }
    ],
    "group_index": "167"
}