{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-5573-siwe-recap/10627",
            "title": "EIP-5573: SIWE ReCap ",
            "index": 10627,
            "category": [
                "EIPs"
            ],
            "tags": [
                "NONE"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/awoie",
                    "index": "1",
                    "likes": "3",
                    "time": "01/09/2022-14:16:30",
                    "content": "Discussion on EIP-5573: a mechanism on top of Sign-In With Ethereum for informed consent to delegate capabilities with an extensible scope mechanism. PR here: https://github.com/ethereum/EIPs/pull/5573 ",
                    "links": [],
                    "GPT-summary": "The post is a discussion about EIP-5573, which proposes a mechanism on top of Sign-In With Ethereum for informed consent to delegate capabilities with an extensible scope mechanism. The author is explaining the proposal, while third parties are giving constructive criticism and asking questions about it.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Identity and reputation systems",
                        "Privacy, Security and risk management",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/unenunciate",
                    "index": "2",
                    "likes": "0",
                    "time": "15/09/2022-01:52:37",
                    "content": "Can this be modified so that it is calling its own personal_sign_swie method, probaly not that method name though, so we can both enforce the data structure and so that, from the extension level, the request could be modified to represent the contract wallet if one is in place? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 8.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/awoie",
                    "index": "3",
                    "likes": "0",
                    "time": "15/09/2022-11:44:32",
                    "content": "Can you elaborate what you mean by \u201ccalling its own personal_sign_siwe method\u201d? The spec is fully personal_sign and SIWE compliant which means it uses the same data structure, same JSON RPC signing methods. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.7875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/unenunciate",
                    "index": "4",
                    "likes": "0",
                    "time": "15/09/2022-15:56:40",
                    "content": "Its not about it not being compliant. Its about this being compatible with ERC 4337 account abstraction adding in separate sign where the form is further conscribed would allow for the extension simply modify the request via injecting the correct address for the SIWE request. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cobward",
                    "index": "5",
                    "likes": "1",
                    "time": "07/10/2022-10:09:17",
                    "content": "I think that is out of scope for EIP-5573. EIP-5573 is simply describing a common SIWE format that can be used to encode object capabilities. It is not prescriptive on how such a message should be constructed or signed. If a personal_sign_siwe method is needed for SIWE to be compatible with ERC 4337, then that should be addressed in another EIP in my opinion. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 4.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/unenunciate",
                    "index": "6",
                    "likes": "0",
                    "time": "08/10/2022-02:34:52",
                    "content": "It has been why most are against 4361 so it tracks that it will be continually recurring issue and shouldn\u2019t be separated considering the eventual road map that includes the of removing EOAs altogether. Unless I am misunderstanding the meaning of that. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cobward",
                    "index": "7",
                    "likes": "0",
                    "time": "10/10/2022-08:35:08",
                    "content": "    unenunciate:  it will be continually recurring issue and shouldn\u2019t be separated considering the eventual road map that includes the of removing EOAs altogether   Sorry I\u2019m not sure I understand what you mean by this. What road map are you talking about, and how does this affect 5573? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 3.229166666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/unenunciate",
                    "index": "8",
                    "likes": "0",
                    "time": "11/10/2022-16:50:06",
                    "content": "I am not going to lie this might be either an internal document or something more ethereal in Vitalik\u2019s head either way he has mentioned it several times being on the \u2018roadmap\u2019, but I can find no public roadmap that goes out that far. 4337 wallets will become very quickly adopted not only as a better wallet option but also because they provide a better UX. Any SIWE EIP that does not support them will ultimately not be widely adopted. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.041666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cobward",
                    "index": "9",
                    "likes": "1",
                    "time": "12/10/2022-11:16:40",
                    "content": "EIP-5573 is not concerned with signing or verification of a SIWE message (it simply uses the methods described in EIP-4361), so I would argue there is no need to concern it with the requirements of EIP-4337. I agree there will need to be work (possibly an extension EIP) to make SIWE compatible with EIP-4337, however that is not a concern for this 5573. From my understanding there are ongoing conversations on how this could be done. 5573 would not disrupt this work, nor make 4361 less compatible with 4337. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 4.722222222222222
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/unenunciate",
                    "index": "10",
                    "likes": "0",
                    "time": "12/10/2022-14:22:08",
                    "content": "Any link to those aforementioned conversations? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cobward",
                    "index": "11",
                    "likes": "0",
                    "time": "12/10/2022-16:29:16",
                    "content": "I don\u2019t think there\u2019s been anything in the public yet, but the internal conversations will start bringing things up. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "12",
                    "likes": "2",
                    "time": "15/10/2022-23:05:59",
                    "content": "Hi there, I\u2019ve lightly reviewed the proposal. I\u2019m a pretty big object capability enthusiast, and there are some things here that I like and some things that I think are going to make it challenging to adopt or expensive to use. Anyways, here are my notes, syndicated from my Roam graph:  Aims to provide a [[EIP-4361: Sign in with Ethereum]] extension that allows any cryptographic [[capability]] to also be delegated as part of the same signature.  Uses the terms [[capability]] and [[object capability (ocap)]], unclear if they fulfill [[rich sharing]] criteria.  At the very least, this seems to be more cap than ocap, since the designation is not being conveyed as a programming language object.   Claims to enable \u201cany protocols and APIs that support [[object capability (ocap)]].\u201d  This is not possible, since a capability format may require additional signatures that are not part of this one.     Uses the term [[delegee]] for the recipient of a [[delegation]]. New to me, appears to be a real word! Since it overloads [[EIP-4361: Sign in with Ethereum]], it\u2019s building on top of [[personal_sign]]  This ensures the signature will be somewhat less efficient to parse on chain (string parsing). Making the signature challenge human readable will either need to be  Plain text  This appears to be what it does. more expensive to parse on chain Not multi-lingual Uses a URI as the delegate in the signature  Unclear how a URI should be interpreted as the designee of a capability. Shows an example with [[DID]]s  So the implementation needs to be able to interpret them. Who is implementing that? Which schemes will be supported?       More dense format  This may also be used, via the ReCap URI Scheme.  Since there is both a human-readable and \u201cURI Scheme\u201d representation of the delegation, there needs to be some measure to ensure these are the same thing, so the user does not sign one thing that means another.    Would require feature additions of [[wallet]] software.  Implementation/distribution can be simplified using [[[[MetaMask]] Snaps]]       Will probably not work for [[contract account]]s  I hope to address this with [[[[Delegatable Eth]] and [[[[EIP]] 4337: [[account abstraction (AA)]] via Entry Point Contract]] synthesis]]     Includes a new [[JSON-RPC API]] method that allows requesting methods.  Each capability is specified by a sort of resource identifier like my.resource.1.  This is not open ended enough to satisfy the kind of reference passing across domains that really distinguishes true [[rich sharing]] and avoids the [[Confused Deputy]] problem. Ideally capabilities would be represented as objects that could have been granted from other methods/sources.  This isn\u2019t a show stopper. There is still lots of value to having a way of requesting multiple resources from a user, I\u2019m just being very specific about what distinguishes this method from some of the approaches it is borrowing language from.     I\u2019m largely skimming this schema for now.   Does not seem to have an implementation today, which leaves a lot of questions open. I think a lot here is left to the implementers.  Can the holder of a ReCap also delegate it? How is a ReCap used/redeemed? Can contract accounts interact with these?    ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.559602784602785
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cobward",
                    "index": "13",
                    "likes": "1",
                    "time": "16/10/2022-07:47:23",
                    "content": "Thanks for sharing your extensive notes. Hopefully I can address at least some of the issues you raise. I\u2019ll start with the easier ones!     danfinlay:  Does not seem to have an implementation today   We have an implementation here.     danfinlay:   Can the holder of a ReCap also delegate it? How is a ReCap used/redeemed?    Yes a holder can delegate any of the capabilities in a ReCap, but the ReCap spec doesn\u2019t define a method for how that should be done. If the secondary delegation is also a ReCap, we have an expectation that a link/cid/encoding of the primary delegation would be inserted in ext (extra fields). One of the problems we are trying to solve with ReCap is \u201cHow can an ethereum account authorise actions with a system that supports ocaps?\u201d. It\u2019s clearly bad UX if an end-user is required to directly sign a capability invocation message for every action that needs to be performed. We want to use ReCap to delegate capabilities to a session key, which invokes those capabilities on behalf of the ethereum account. ReCap only defines a delegation format. How that delegation is invoked is dependent on the \u201ctype\u201d of delegee and the authorisation system that is being interacted with.     danfinlay:  Can contract accounts interact with these?   Absolutely, with a caveat. Since ReCap uses SIWE for the signature portion of verification, this is the same problem as \u201cCan contract accounts use SIWE?\u201d. We have been working with Gnosis to provide a method for a Gnosis Safe to sign in with ethereum. In this case the ethereum address in the SIWE message (i.e. the delegator) is the Gnosis Safe, the message is signed with an EOA, and as part of SIWE verification we perform an on-chain lookup to check the binding between the EOA and Gnosis Safe in a \u201cdelegation registry\u201d. [Note: I personally haven\u2019t actually worked on this so some of the terminology might be inaccurate]. How this should be done more widely is likely the concern of later work to make SIWE compatible with EIP-4337.     danfinlay:    Each capability is specified by a sort of resource identifier like my.resource.1.  This is not open ended enough to satisfy the kind of reference passing across domains that really distinguishes true [[rich sharing]] and avoids the [[Confused Deputy]] problem.      Apologies if I\u2019m wrong, but you may have missed that each capabilities are grouped into namespaces. Does that resolves these concerns? If not, what is ReCap lacking?     danfinlay:  Since there is both a human-readable and \u201cURI Scheme\u201d representation of the delegation, there needs to be some measure to ensure these are the same thing, so the user does not sign one thing that means another.   Along with SIWE signature verification, to verify a ReCap you must also verify that the human-readable statement is correct. This is done by performing the translation from resources (ReCap URIs) to recap-transformed-statement, and checking that the statement is suffixed with recap-transformed-statement. This is described in more detail in the algorithm sections.     danfinlay:  This is not possible, since a capability format may require additional signatures that are not part of this one.   I\u2019m not familiar with any such formats, but would it be enough to insert those signatures (plus any other required data) into ext (extra fields)? Or could you give an example of such a format?     danfinlay:  At the very least, this seems to be more cap than ocap, since the designation is not being conveyed as a programming language object.   Would you be able to elaborate on this? Is the \u201cdesignation\u201d the target resource in this context? And what do you mean by it \u201cis not being conveyed as a programming language object\u201d? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.376162790697673
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cobward",
                    "index": "14",
                    "likes": "1",
                    "time": "16/10/2022-07:50:09",
                    "content": "    danfinlay:  Uses the term [[delegee]] for the recipient of a [[delegation]]. New to me, appears to be a real word!   We tend to use it to avoid the confusion of using delegate, being both a verb and a noun  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.965909090909091
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/awoie",
                    "index": "15",
                    "likes": "0",
                    "time": "17/10/2022-09:42:59",
                    "content": "Thanks a lot for reviewing the article and providing feedback. @cobward commented already on most of your points. But here are some additional comments below.     danfinlay:  Includes a new [[JSON-RPC API]] method that allows requesting methods   SIWE ReCap will rely on the same JSON-RPC API as SIWE, therefore strictly speaking there is no new JSON-RCP API needed.     danfinlay:  Shows an example with [[DID]]s  So the implementation needs to be able to interpret them. Who is implementing that? Which schemes will be supported?    The delegate/delegee has to be a URI to be identifiable. DIDs are just examples since they make it easy to authenticate the delegate/delegee but any URI can be used. The documentation of the resource service API has to define what URI schemas are acceptable and that would include DID methods if they even wanted to support DIDs.     danfinlay:  Includes a new [[JSON-RPC API]] method that allows requesting methods.  Each capability is specified by a sort of resource identifier like my.resource.1.  This is not open ended enough to satisfy the kind of reference passing across domains that really distinguishes true [[rich sharing]] and avoids the [[Confused Deputy]] problem. Ideally capabilities would be represented as objects that could have been granted from other methods/sources.      SIWE ReCap capabilities can be represented as objects: SIWE message incl. ReCaps + Signature. We expected people will use CACAOs as their container format for this since CACAOs can already represent SIWE messages + Signatures. There is no strict requirement that each ReCap has to include a resource identifier. We intentionally made the spec open to cater for systems that don\u2019t have URIs identifying their resources. The proposed EIP also allows untargeted (not tied to a resource identifier) ReCaps as well. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.934469696969698
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "16",
                    "likes": "0",
                    "time": "15/11/2022-17:44:00",
                    "content": "(Wow it\u2019s been a while since I\u2019ve been in a magicians thread ) Hey @awoie  I just got off a CASA call where we\u2019re exploring make UCAN and SIWx/ReCap interop. I just wanted to quickly shared something that we learned in the UCAN process that may or may not be helpful for ReCap:       \"my.resource.1\":[          \"append\",          \"delete\"       ],       \"my.resource.2\":[          \"append\"       ],       \"my.resource.3\":[          \"append\"       ]  UCAN resources looked almost exactly like this early on. We started in languages that use parsing libraries \u2014 this is readable and the parser combinators make this stuff very easy. Once folks using JS & TS started writing libraries, we got a bunch of complaints that it was hard to parse when they\u2019re used to working directly in JSON. This is why we switched to objects: [   {     \"with\": \"my.resource.2\",     \"can\": \"append\"   },   {     \"with\": \"my.resource.3\",     \"can\": \"append\"   } ]  This is totally isomorphic, just laid out differently. It also reads nicely like an English sentence \u201cwith noun, you can verb\u201d. Anyhow, I hope that\u2019s helpful!  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 4.585
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/oed",
                    "index": "17",
                    "likes": "1",
                    "time": "16/11/2022-17:15:40",
                    "content": "I threw together a quick comparison of ReCap and UCAN. I think there are some changes we could make to ReCap to make it more compatible with UCAN.   gist.github.com   https://gist.github.com/oed/24207b2de1fb63e05867f1cf45776df8 ucan-recap.md Exploreing the differences between how capabilities are represetned between UCAN and ReCap.  ## Comparison  |                 | [UCAN](https://github.com/ucan-wg/spec)    | [ReCap](https://eips.ethereum.org/EIPS/eip-5573)   | | --------------- | ------------------------------------------ | -------------------------------------------------- | | `$RESOURSE`     | Needs to be a URL                          | Any String                                         | | `$ABILITY`      | One ability per resource ref               | Any nymber of abilities per resource ref           | | `$EXTENSION`    | Additional caveats for a specific resource | Additional information, relevant for all resources | | All resources   | Not possible                               | In `def` property                                  |     This file has been truncated. show original        ",
                    "links": [
                        "https://gist.github.com/oed/24207b2de1fb63e05867f1cf45776df8",
                        "https://gist.github.com/oed/24207b2de1fb63e05867f1cf45776df8"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.340277777777778
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "18",
                    "likes": "0",
                    "time": "16/11/2022-17:40:50",
                    "content": "Thanks @oed !     oed:   $RESOURSE     | Needs to be a URL   More specifically it needs to be some kind of URI. We started with \u201cany string\u201d, but Irakli quite rightly pointed out that it makes interop very difficult because the same string can have different meanings     oed:  All resources   | Not possible     This is possible in UCAN as {with: \"*\", can: \"*/*\"}. We use it regularly for e.g. device linking     oed:  Any nymber of abilities per resource ref   We had this at one point, but the complaint was that it\u2019s easier with one per  I guess also if you need extensible fields, they may cross unintentionally  The other big difference is that we namespace the can field too. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.200255102040816
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/oed",
                    "index": "19",
                    "likes": "1",
                    "time": "17/11/2022-08:39:05",
                    "content": " More specifically it needs to be some kind of URI. We started with \u201cany string\u201d, but Irakli quite rightly pointed out that it makes interop very difficult because the same string can have different meanings  Typo, should have said URI. Updated!  This is possible in UCAN as {with: \"*\", can: \"*/*\"}. We use it regularly for e.g. device linking  Is * really a URI? Or is this just a special case. Either way i think it would make sense for ReCap to use the same approach for the resource string.  We had this at one point, but the complaint was that it\u2019s easier with one per  I guess also if you need extensible fields, they may cross unintentionally  Easier in what way? Imo it would be better to avoid duplication here. Tooling can abstract the underlaying data structure and make it easier to use.  The other big difference is that we namespace the can field too.  Oh good point. Updating comparison doc to reflect this. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.608193277310924
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "20",
                    "likes": "0",
                    "time": "18/11/2022-21:59:11",
                    "content": "    oed:  Is * really a URI? Or is this just a special case.   Indeed, good catch: we changed this in 0.9 to be a URI and scoped to a specific DID\u2019s capabilities. This now looks like: own://did:key:zH3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV/* Some folks want to use the DID itself, but I think it\u2019s ambiguous that you\u2019re delegating the rights of things owned by a DID vs rights to update the DID doc itself. We previously used my:* for this to disambiguate especially in chains, but the own URI is more general and easier to work with.     oed:  Easier in what way? Imo it would be better to avoid duplication here   It makes the delegation logic more complex because now you have a nested array, but the same capability could still be delegated in another entry. For example, there\u2019s nothing stopping you from writing the following: \"my.resource.1\":[\"append\",\"delete\"], \"my.resource.1\":[\"read\"]  So now you have to deal with the nested array in your code and still look at the level above for others caps on the same resource. If you model this as a JSON object, you have to either merge them, or pick which one is valid, or invalidate the entire credential. There\u2019s more that an implementer can mess up, basically. // what do? {   \"my.resource.1\": [\"append\",\"delete\"],   \"my.resource.1\": [\"read\"] }  If you pick the merge case, then extensible fields get dangerous (easy to mess up what refers to what) unless you reformat them as objects: {   \"my.resource.1\": [     {can: \"append\", on: \"Tuesdays\"},  // silly nonsense example     \"delete\"   ],   \"my.resource.1\": [\"read\"] }  In UCAN, we solve for this by allowing for hierarchy (which yes, is a tradeoff). This is desirable for a bunch of reasons, including enabling rights amplification (incl. joining caps from different sources) and letting applications extend other\u2019s semantics, which gives consumers a lot of (safe) flexibility over how they consume and reuse capabilities between apps/services. Here\u2019s the diagram from the 0.9 UCAN spec:                                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                            \u2502       \u2502                                            \u2502   *   \u2502                                            \u2502       \u2502                                            \u2514\u25b2\u2500\u2500\u25b2\u2500\u2500\u25b2\u2518                                             \u2502  \u2502  \u2502                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u2502                               \u2502                               \u2502           \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510           \u2502         \u2502                     \u2502          \u2502                     \u2502       \u2502           \u2502  msg/*  \u2502                     \u2502  crud/*  \u2502                     \u2502  ...  \u2502           \u2502         \u2502                     \u2502          \u2502                     \u2502       \u2502           \u2514\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2518                     \u2514\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502     \u2502                         \u2502      \u2502             \u2502     \u2502                         \u2502      \u2502             \u2502     \u2502                         \u2502      \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2510 \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2510 \u250c\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502            \u2502 \u2502               \u2502 \u2502             \u2502 \u2502               \u2502 \u2502  msg/send  \u2502 \u2502  msg/receive  \u2502 \u2502  crud/read  \u2502 \u2502  crud/mutate  \u2502 \u2502            \u2502 \u2502               \u2502 \u2502             \u2502 \u2502               \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2518                                                    \u2502     \u2502     \u2502                                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                             \u2502            \u2502            \u2502                                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                \u2502               \u2502 \u2502               \u2502 \u2502                \u2502                                \u2502  crud/create  \u2502 \u2502  crud/update  \u2502 \u2502  crud/destroy  \u2502                                \u2502               \u2502 \u2502               \u2502 \u2502                \u2502                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  Here you can delegate crud/mutate and avoid the resource duplication. If you squint, this is the same \u201cshape\u201d as rights amplification, but where no new authority is conferred. It\u2019s also the same relationship as between * and crud/read (where read is a subset of */\u201ceverything\u201d). I will highlight that not everyone loves this, but it\u2019s the same idea as being able to attenuate a resource, but on the ability. The open extensibility (I guess really \u201cjust\u201d the open-closed principle) of this kind of system means that we can ship a standard library of capabilities and give them really good support in libraries without limiting users to specific use cases. Phew that was a lot longer than I expected to write  Looking forward to the call next week btw! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.945069745069745
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/oed",
                    "index": "21",
                    "likes": "1",
                    "time": "20/11/2022-09:19:33",
                    "content": "Crossposting Irakli\u2019s response and suggestion: Multiple \"can\" for a \"with\" \u00b7 Issue #123 \u00b7 ucan-wg/spec \u00b7 GitHub An approach like this would be interesting and it solves for the merge approach you outlined above.  I think his suggestion also makes sense for ReCap: Schema: {   $RESOURCE: {     $ABILITY: $EXTENSION,     ...   },   ...   \"prf\": [&Link] // OCAP delegations }  Example: {   \"example://example.com/public/photos/\": {       \"crud/delete\": {}   },   \"example://example.com/private/84MZ7aqwKn7sNiMGsSbaxsEa6EPnQLoKYbXByxNBrCEr\": {       \"wnfs/append\": {}   },   \"example://example.com/public/documents/\": {     \"crud/delete\": {       \"matching\": \"/(?i)(\\W|^)(baloney|darn|drat|fooey|gosh\\sdarnit|heck)(\\W|$)/\"      }   },   \"mailto:username@example.com\": {     \"msg/send\": {},     \"msg/receive\": {       \"max_count\": 5,       \"templates\": [\"newsletter\", \"marketing\"]     }   } }  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 2.0588235294117645
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "22",
                    "likes": "0",
                    "time": "21/11/2022-01:42:21",
                    "content": "    oed:  An approach like this would be interesting and it solves for the merge approach you outlined above.   Unfortunately, it actually causes the merge problem above. [UPDATE @oed was talking the OTHER merge case. Sorry, entirely my bad   The bit below is still useful I think] Repeating here for the group/discussion here: duplicate key handling is under-specified in the JSON spec, and thus different libraries handle them differently: From RFC 8259:  When the names within an object are not unique, the behavior of software that receives such an object is unpredictable. Many implementations report the last name/value pair only. Other implementations report an error or fail to parse the object, and some implementations report all of the name/value pairs, including duplicates. JSON parsing libraries have been observed to differ as to whether or not they make the ordering of object members visible to calling software. Implementations whose behavior does not depend on member ordering will be interoperable in the sense that they will not be affected by these differences.  However, we could solve this by wrapping it in an array. Adapting your example above: [   {     \"example://example.com/public/photos/\": {         \"crud/delete\": {}   },   {     \"example://example.com/private/84MZ7aqwKn7sNiMGsSbaxsEa6EPnQLoKYbXByxNBrCEr\": {       \"wnfs/append\": {}   },   {     \"example://example.com/public/documents/\": {       \"crud/delete\": {         \"matching\": \"/(?i)(\\W|^)(baloney|darn|drat|fooey|gosh\\sdarnit|heck)(\\W|$)/\"        }     }   },   {     \"mailto:username@example.com\": {       \"msg/send\": {},       \"msg/receive\": {         \"max_count\": 5,         \"templates\": [\"newsletter\", \"marketing\"]       }     }   } ]  This adds two characters (the enclosing {}s) per capability, but makes it compatible with all parsers. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 3.507392473118279
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "23",
                    "likes": "0",
                    "time": "21/11/2022-01:46:42",
                    "content": "Ah! But agreed @oed that it solves the other case, on extensional fields! Sorry, so many kinds of merge happening there   ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.739583333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/oed",
                    "index": "24",
                    "likes": "0",
                    "time": "21/11/2022-09:23:35",
                    "content": "Will mention what I said in the other thread as well. I think it would be easier to solve the merge problem by simply not allowing duplicate resource keys? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 4.6875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "25",
                    "likes": "1",
                    "time": "21/11/2022-18:14:44",
                    "content": "That\u2019s a change we could make, yeah. It does mean that there\u2019s more things that people can mess up in an implementation, and it\u2019s not a problem that we have in the existing version of UCAN. Not forcing this eliminates a Byzantine (buggy not malicious) case. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.020833333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/oed",
                    "index": "26",
                    "likes": "0",
                    "time": "25/11/2022-16:52:31",
                    "content": "Here\u2019s my suggestion for how to update ReCap with the same structure as what is currently suggested for UCAN.   gist.github.com   https://gist.github.com/oed/010c3cf57420248ae0ab4d827f016580 recap.md This document describes how ReCap can adopt the capability format that is used by UCAN. Note that the design of UCANs structure [is still in discussion](https://github.com/ucan-wg/spec/issues/123), and if it changes we would want to adopt those changes (for v1 of UCAN).  Going to demonstrate by example. Here is what the ReCap json structure should look like.  ```json {   \"att\": {     \"http://example.com/public/photos/\": {         \"crud/delete\": []     },     This file has been truncated. show original        ",
                    "links": [
                        "https://gist.github.com/oed/010c3cf57420248ae0ab4d827f016580",
                        "https://gist.github.com/oed/010c3cf57420248ae0ab4d827f016580"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 3.4375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "27",
                    "likes": "0",
                    "time": "26/11/2022-08:07:13",
                    "content": "This looks really good to me!   ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 9.375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "28",
                    "likes": "1",
                    "time": "26/11/2022-18:18:03",
                    "content": "We\u2019ve updated the UCAN 0.10 WIP PR to use the above syntax  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alanhkarp",
                    "index": "29",
                    "likes": "0",
                    "time": "02/12/2022-23:13:03",
                    "content": "I am worried about uses like the example {    \"def\":[       \"read\"    ],    \"tar\":{       \"my.resource.1\":[          \"append\",          \"delete\"       ],       \"my.resource.2\":[          \"append\"       ],       \"my.resource.3\":[          \"append\"       ]    },    \"ext\":{        \"parentCapability\": \"bafybeigk7ly3pog6uupxku3b6bubirr434ib6tfaymvox6gotaaaaaaaaa\"    } }  If this example is used to make a request, you could be subject to a confused deputy vulnerability.  That\u2019s why a capability designates a single resource. There are two options for this example.  You could return a separate capability for each resource, or you could only accept a request if the capability designates a single resource.  The former case takes up more space, and the latter requires delegating to yourself.  I don\u2019t view either of those to be much of a problem. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 3.496825396825397
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/awoie",
                    "index": "30",
                    "likes": "0",
                    "time": "07/12/2022-05:58:56",
                    "content": "    alanhkarp:  If this example is used to make a request, you could be subject to a confused deputy vulnerability. That\u2019s why a capability designates a single resource.   The example is just the delegation, the actual request (=invocation) happens on one specific capability, e.g., my.resource.1 + append, or my.resource.1 + delete, etc. Does this address your concern? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 4.3619047619047615
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chunningham",
                    "index": "31",
                    "likes": "1",
                    "time": "08/12/2022-15:47:41",
                    "content": "I like the arrangement of the JSON representation, it\u2019s great. w.r.t. the statement generation, we have been thinking about how to make namespaced actions like crud/read more obvious. We suggest factoring out the common namespace for actions into a prefix separated with a :, e.g. crud/read + crud/write becomes crud: read, write. In this way, a recap like {   att: {     https://example.com/public/photos/: {       crud/read: [],       other/action: []     },     https://somewhere.else: {       crud/read: [],       crud/delete: []         }   },   prf: [] }  would become: I further authorize https://example.com to perform the following actions on my behalf: (1) crud: \"read\" for \"http://example.com/public/photos/\". (2) other: \"action\" for \"http://example.com/public/photos/\". (3) crud: \"read\", \"delete\" for \"https://somwhere.else\".  It factors out the namespace to make each clause define the actions from one namespace for one resource. I think this helps emphasise the purpose and makes it a bit harder for a reader to skip over an action that isn\u2019t expected to be there I think that many URIs will be unparsable for regular users, but we couldn\u2019t think of a way to make them easier to read in a general case by manipulating them somehow. That\u2019s still a nice to have for us but we are fine right now with using whole URIs in the statement. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.292107583774251
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alanhkarp",
                    "index": "32",
                    "likes": "0",
                    "time": "15/12/2022-00:51:05",
                    "content": "Yes.  And sorry for the delay in answering.  For some reason your prompt response escaped my notice. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 2.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/oed",
                    "index": "33",
                    "likes": "0",
                    "time": "15/12/2022-14:27:35",
                    "content": "This approach looks quite reasonable to me. The main concern I would have is that the crud part of your example doesn\u2019t get wrapped in \"\". A developer could potentially introduce spaces and special characters there. Maybe ReCap should specify which strings are legal as actions? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.923809523809523
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chunningham",
                    "index": "34",
                    "likes": "1",
                    "time": "16/12/2022-09:35:43",
                    "content": "I think quoting the crud would be a good suggestion. when it comes to legal strings in general, some characters will naturally have to be illegal, e.g. newlines which would break the siwe statement, or slashes / which conflict with the json representation (like crud/read) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.550000000000001
                }
            ]
        }
    ],
    "group_index": "86"
}