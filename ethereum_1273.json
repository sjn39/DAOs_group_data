{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/evm-object-format-eof/5727",
            "title": "EVM Object Format (EOF) ",
            "index": 5727,
            "category": [
                "EIPs"
            ],
            "tags": [
                "evm",
                "core-eips",
                "evm-object-format",
                "shanghai-candidate"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "1",
                    "likes": "3",
                    "time": "16/03/2021-16:41:15",
                    "content": "Last week I have shared a document on the Eth R&D discord explaining some background on why some EVM changes are hard and motivation for improving the situation:   HackMD    EVM encapsulation format - HackMD # EVM encapsulation format  > Name suggestion: *EOF \u2013 EVM Object Format* > Or could go the GNU way:      It also suggests a container format for EVM, which would enable further improvements, such as removing jumpdests, moving to static jumps, etc. While the document does not aim to provide a final, implementable solution, it is a good one for discussions. ",
                    "links": [
                        "https://notes.ethereum.org/@axic/evm-object-format",
                        "https://ethereum-magicians.org/t/ethereum-account-versioning/3508/14",
                        "https://ethereum-magicians.org/t/eip-2938-account-abstraction/4630/9",
                        "https://ethereum-magicians.org/t/eip-4200-static-relative-jumps/7108"
                    ],
                    "GPT-summary": "The author of the post shared a document on the Eth R&D discord, explaining the motivation for improving the EVM encapsulation format and suggesting a container format for EVM. The document is not a final solution but aims to initiate discussions. The post includes constructive criticism, questions, and auditing of the proposal.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Interoperability and Scalability",
                        "Token economics",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None"
                    ],
                    "Sentiment": 5.648809523809524
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "2",
                    "likes": "0",
                    "time": "16/03/2021-16:42:30",
                    "content": "@chriseth published his initial opinion here:    notes.ethereum.org    Thoughts on EVM encapsulation format - HackMD      ",
                    "links": [
                        "https://notes.ethereum.org/BgA648JCQ6uVHPUVFrLzkQ"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "3",
                    "likes": "0",
                    "time": "16/03/2021-16:43:20",
                    "content": "And with @chfast and @gumb0 we have looked into some other potential changes this could bring in the long term:    notes.ethereum.org    evm object format (eof) discussion - HackMD      ",
                    "links": [
                        "https://notes.ethereum.org/t-1tLFnLSKCtLZpb-Rw0IA?view"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.708333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "4",
                    "likes": "2",
                    "time": "30/04/2021-15:17:21",
                    "content": "Can we change this EIP to just say any contract deployment that has an unused opcode as the first byte is invalid and should revert?  Rather than just have a single opcode that is considered invalid?  There is no good reason to start a contract with an unused opcode, and maybe we\u2019ll want the others later. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.785714285714286
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "5",
                    "likes": "1",
                    "time": "30/04/2021-17:30:43",
                    "content": "This is technically possible, but this would block much bigger set of \u201cdata contracts\u201d from being deployed, therefore there would be bigger chance to break some existing factory contracts. Data contracts are deployed bytecodes with no intention for execution from which you can read data with EXTCODECOPY. On the other hand, this increases our chance to have shorter EOF prefix. Some middle ground would be to reject some fixed range based on the analysis of currently deployed contracts. E.g. D0-EF. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.982142857142858
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "6",
                    "likes": "1",
                    "time": "01/05/2021-04:02:06",
                    "content": "I wonder if we should enshrine data contracts somehow?  Maybe have a contract prefix specifically for them? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jochem-brouwer",
                    "index": "7",
                    "likes": "1",
                    "time": "02/05/2021-14:00:50",
                    "content": "If we disallow contracts starting with 0xEF then I\u2019d say we should also explicitly mark 0xEF as an INVALID opcode (or alternatively if we want to use 0xEF at some point it should use  >=1 stack items), otherwise we get these weird situations that contracts want to start using this opcode but have to push a dummy item to stack first. I am assuming that this only disallows the code deposit starting with 0xEF, we could technically still try to CREATE a contract where the deploycode starts with 0xEF? (Just for clarification here) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.791666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "8",
                    "likes": "1",
                    "time": "03/05/2021-10:29:26",
                    "content": "I see a much bigger risk of this change not making into London if the range is extended. I think it has merits to reject any contract with invalid starting byte, but perhaps that can be done separately and even after London. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "9",
                    "likes": "0",
                    "time": "13/05/2021-17:47:21",
                    "content": "The first step towards this is defined under EIP-3541:  Ethereum Improvement Proposals   EIP-3541: Reject new contracts starting with the 0xEF byte Details on Ethereum Improvement Proposal 3541 (EIP-3541): Reject new contracts starting with the 0xEF byte      It is also considered for the upcoming London fork. ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-3541"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.5227272727272725
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Vie",
                    "index": "10",
                    "likes": "1",
                    "time": "21/05/2021-03:14:02",
                    "content": "So, when we try to add TokenA and TokenB to uniswap v2, we maybe got error as create2 create a pair start with 0xEF? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "11",
                    "likes": "0",
                    "time": "21/05/2021-14:04:08",
                    "content": "No working contract starts with 0xEF. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Vie",
                    "index": "12",
                    "likes": "0",
                    "time": "27/05/2021-16:35:43",
                    "content": "Ok, I\u2019ll try to fix out that. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "13",
                    "likes": "0",
                    "time": "09/06/2021-21:30:48",
                    "content": "This first step has been accepted for London. The next step was proposed for Shanghai:  Ethereum Improvement Proposals   EIP-3540: EVM Object Format (EOF) v1 Details on Ethereum Improvement Proposal 3540 (EIP-3540): EVM Object Format (EOF) v1      This introduces code - data separation as the main tangible benefit to users. ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-3540"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.694444444444445
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/poojaranjan",
                    "index": "14",
                    "likes": "1",
                    "time": "15/06/2021-01:45:53",
                    "content": "Watch an overview of EIP-3540 & EIP-3541 by @axic @chfast @gumb0.      ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "15",
                    "likes": "1",
                    "time": "16/06/2021-17:24:24",
                    "content": "There is also a new overview document here:   HackMD   Everything about the EVM Object Format (EOF) - HackMD # Everything about the EVM Object Format (EOF)  The aim of this document is to serve as an explainer      This gives an explanation of why two hard forks, gives a roadmap of different features we investigate (Shanghai, Cancun, and beyond), and links to all relevant resources. (We plan to drop the two-hard fork explainer from EIP-3540 to simplify it.) ",
                    "links": [
                        "https://notes.ethereum.org/@ipsilon/evm-object-format-overview"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.305871212121213
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "16",
                    "likes": "0",
                    "time": "20/07/2021-09:10:40",
                    "content": "As a further step, we suggest to introduce code validation with EOF: EIP-3670: EOF - Code Validation It is proposed as a separate EIP to keep concerns separated and the EIPs shorter. ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "17",
                    "likes": "1",
                    "time": "07/08/2021-13:30:30",
                    "content": "A potential way to remove the need for jumpdest analysis at execution time was published here: EIP-3690: EOF - JUMPDEST Table ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "18",
                    "likes": "1",
                    "time": "23/09/2021-13:57:44",
                    "content": "A proposal made possible by EOF is to have static jumps:    EIP-4200: Static relative jumps Core EIPs       This is the discussion topic for   This proposal started as a comment back in February and was one of the reasons which kicked off our journey with EVM Object Format (EOF). In the past few months @gumb0 has been working on experimenting and validating this in evmone (PR here), but now is the time to release an actual EIP.     ",
                    "links": [
                        "https://github.com/ethereum/pm/issues/250#issuecomment-782094832",
                        "https://ethereum-magicians.org/t/evm-object-format-eof/5727",
                        "https://github.com/ethereum/evmone/pull/351"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.34375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "19",
                    "likes": "0",
                    "time": "23/10/2021-15:47:18",
                    "content": "After the London upgrade which included EIP-3541 we were able to collect all previously deployed bytecodes starting with the 0xEF byte. The following document has information about collected data and 2 possible EOF prefix values. We recommend the use 0xEF00 2-byte prefix. EOF Prefix Selection ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "20",
                    "likes": "0",
                    "time": "24/10/2021-09:17:15",
                    "content": "Has anyone looked into figuring out what https://etherscan.io/address/0xca7bf67ab492b49806e24b6e2e4ec105183caa01 does? Given that there are only 3 contracts that start with 0xEF and two of them have (in theory) reachable owners/authors and the third doesn\u2019t actually do anything, I think we should explore the option of an irregular state change to get rid of them so we have a completely clear 0xEF space. This is especially true since all 3 of them were created after EIP-3541 was proposed, and I suspect at least two of them (the contracts that merely deployed 0xEF) were created explicitly to cause problems for us (the third possibly as well, but that one is slightly less clear). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.96969696969697
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "21",
                    "likes": "1",
                    "time": "24/10/2021-10:06:26",
                    "content": "I asked about the long contract here: https://twitter.com/alexberegszaszi/status/1452210984987369474 Writing an EIP for the irregular state change is easy enough, ACD may or may accept it, but it definitely is yet another hurdle to overcome. I\u2019d be happy if we could get rid of those three contracts, if someone champions that change. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.183333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/0age",
                    "index": "22",
                    "likes": "3",
                    "time": "25/10/2021-15:13:44",
                    "content": "Hey there \u2014 so that third contract was deployed by me, and it\u2019s just a \u201cfarewell\u201d message to 0xef before EIP-3541 took effect. Definitely did not intend to cause any problems with it and would have no qualms whatsoever with the contract being removed if it makes things easier / cleaner. f09f918b =>  f09f9fa9 =>  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "23",
                    "likes": "0",
                    "time": "25/10/2021-20:53:29",
                    "content": "    0age:  Definitely did not intend to cause any problems with it and would have no qualms whatsoever with the contract being removed if it makes things easier / cleaner.   Thanks for the response! It actually complicates matters, so removing it would be helpful. The other two contracts are annoying too, but cause less issue. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.298611111111112
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "24",
                    "likes": "0",
                    "time": "13/01/2022-12:08:23",
                    "content": "Reviving this now, after having reviewed the EIP a bit. My notes: The terminator is not particularly well specificed. The only thing it says, is that \u201cIf the terminator is encountered, section size MUST NOT follow.\u201d. The> I suggest that the \u201cValidation rules\u201d are clarified further re terminator. Example cases. Which of these are \u2018valid\u2019 and which are not? In each case, where it\u2019s not valid, there should be a corresponding rule in the \u2018Validation rules\u2019. // 1. // 0-size code section, with terminator, no code)  0xEF0001 0x01 0x0000 0x00  // 2. // 0-size code section, no terminator, no code)  0xEF0001 0x01 0x0000  // 3. // 0-size code,0-size data, with terminator  0xEF0001 0x01 0x0000 0x02 0x0000 0x00  // 4. // 0-size code,0-size data, no terminator  0xEF0001 0x01 0x0000 0x02 0x0000  // 5. // 1-size code,0-size data 0xEF0001 0x01 0x0001 0x02 0x0000 0x00 0xEF   // 6. // 1-size code,16-size data, but actual code is smaller than that. Does the 'infinite field of zeroes' apply? 0xEF0001 0x01 0x0000 0x02 0x0010 0x00 0xdada    ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 4.916666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "25",
                    "likes": "0",
                    "time": "13/01/2022-17:31:56",
                    "content": "Thanks for the comment. The intended meaning is that terminator byte is mandatory. But I can agree the specification is not clear about it nor what terminator is. By following this reasoning, all examples without terminator are invalid (2,4). It is also specified that \"section_size MUST NOT be 0\". We decided to include this rule to eliminate two encodings for the same effect - empty section. If a section is empty this forces omitting its header as well. This makes (1,3,5) invalid. Finally, we also wanted all bytes of a section to be present (no \u2018infinite field of zeroes\u2019) but looks this rule is not articulated. That would make 6 invalid. We also don\u2019t allow any bytes outside of sections specified by headers: \u201cStray bytes outside of sections MUST NOT be present. This includes trailing bytes after the last section.\u201d In summary, EOF container requires: no implicit bytes, no additional bytes, shorter encoding if two options are possible. The specification does not express this perfectly yet and we will apply fixes. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.339285714285714
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "26",
                    "likes": "1",
                    "time": "17/01/2022-08:47:11",
                    "content": "Thanks. A follow-up question/observation then.  If a code section must be present, And a section must not be empty,  Then it\u2019s not possible to deploy a data-only contract. This is IMO a side-effect which deserves mention in the EIP. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "27",
                    "likes": "0",
                    "time": "03/02/2022-12:01:09",
                    "content": "    holiman:  Then it\u2019s not possible to deploy a data-only contract. This is IMO a side-effect which deserves mention in the EIP.   This was actually desired, though it is still possible to have a contract with a single instruction in the code section (such as INVALID) to have a determined execution path. Agree we should document it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.928571428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "28",
                    "likes": "0",
                    "time": "03/02/2022-12:02:42",
                    "content": "As a further step to replace dynamic jumps, we propose EIP-4750 (EIP-4750: EOF Functions). This could be adopted together with EIP-4200 (EIP-4200: Static relative jumps) to remove the need for dynamic jumps. ",
                    "links": [
                        "https://ethereum-magicians.org/t/eip-4200-static-relative-jumps/7108"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jochem-brouwer",
                    "index": "29",
                    "likes": "0",
                    "time": "16/02/2022-16:31:22",
                    "content": "I cannot deploy an EOF where codesize is zero. What if I want to deploy an EOF where I only want the data section and no code? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jochem-brouwer",
                    "index": "30",
                    "likes": "0",
                    "time": "16/02/2022-16:35:28",
                    "content": "  If PC goes outside of the code section bounds, execution aborts with failure.   This is not entirely in-line with current semantics when PC runs out of code. On a contract where PC goes out-of-bounds the STOP instruction is executed. I am also fairly sure that with PUSH if not all data can be read (e.g. the contract 60, PUSH1 where it is not clear what data should be pushed) then also STOP is executed. Current EIP changes this behavior; if you run out-of-bounds or PUSH when it is not clear what bytes you should push now goes OOG. Is this intended? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.052083333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gumb0",
                    "index": "31",
                    "likes": "1",
                    "time": "16/02/2022-17:55:40",
                    "content": "    jochem-brouwer:  Current EIP changes this behavior; if you run out-of-bounds or PUSH when it is not clear what bytes you should push now goes OOG. Is this intended?   EIP-3670 requires that the code section ends with a terminating instruction, this makes running out-of-bounds impossible and code ending with truncated PUSH data invalid code. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 3.8055555555555554
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "32",
                    "likes": "0",
                    "time": "17/02/2022-09:35:50",
                    "content": "    jochem-brouwer:  I cannot deploy an EOF where codesize is zero. What if I want to deploy an EOF where I only want the data section and no code?   Data contracts should have INVALID as the only instruction in the code section to signal they are not executable. ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "33",
                    "likes": "0",
                    "time": "17/02/2022-15:06:54",
                    "content": "Thanks @holiman @jochem-brouwer for your comments and questions. Can you check if this spec re-wording change make it any better?  github.com/ethereum/EIPs         EIP-3540: container and validation spec clarification, new code   ethereum:master \u2190 ipsilon:eip-3540-update            opened 03:04PM - 17 Feb 22 UTC               chfast             +69 -48           ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/4822",
                        "https://github.com/chfast",
                        "https://github.com/ethereum/EIPs/pull/4822/files"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.3939393939393945
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/acolytec3",
                    "index": "34",
                    "likes": "0",
                    "time": "02/03/2022-20:10:26",
                    "content": "Can I just confirm that below from the \u201cContract Creation restrictions\u201d section of the EIP  This adds two validation steps in the contract creation, any of it failing will result in contract creation failure.  implies that when an execution client is performing the deploy validation of the EOF1 container/header as part of a contract creation transaction, if the code is invalid, the contract should just not be created (but no gas charged for this contract creation failure), not that an exceptional abort should occur and all remaining gas should be consumed.  Is that correct (per this comment on the related tests PR from @gumb0)? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.041666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "35",
                    "likes": "0",
                    "time": "15/04/2022-08:06:47",
                    "content": "The EIP wording has been updated based on the feedback. No functional changes. EIP-3540: container and validation spec clarification, new code by chfast \u00b7 Pull Request #4822 \u00b7 ethereum/EIPs \u00b7 GitHub ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.681818181818182
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "36",
                    "likes": "1",
                    "time": "22/06/2022-14:30:59",
                    "content": " Data contracts should have INVALID as the only instruction in the code section to signal they are not executable.  I think the requirement that an EOF1 container requires a code section (or any sections at all) is a bit restrictive. In light of SSTORE2-like patterns, \u201cdata-only\u201d contracts might be quite popular, and requiring a code section even with a single instruction incurs (if I am reading correctly) 4 bytes of overhead. I suggest that the spec be modified so that the code section is not required. CALL-ing an EOF1 container with no code section has the same semantics as calling a legacy contract with no code. In other words, if the code section is not explicitly included, the code of the container is implied to be empty. (I originally considered that an EOF1 container with no explicit code section should imply code with a single 0xFE (INVALID) instruction. But that has some weird consistency issues with EXTCODEHASH and EXTCODESIZE). I also suggest enabling completely empty EOF1 containers, e.g. EOF1 containers whose contents are EF0001 00. It may be desirable to deploy empty contracts for some reason (e.g. as part of some address marking scheme, especially if a GETNONCE instruction ever becomes available). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.252551020408164
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "37",
                    "likes": "0",
                    "time": "19/08/2022-21:41:11",
                    "content": "As a somewhat concluding step we propose EIP-5450: EOF - Stack Validation (building on top of all previous EOF EIPs) to reduce the number of checks to be done in the interpreter loop. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.833333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "38",
                    "likes": "0",
                    "time": "30/09/2022-17:09:33",
                    "content": "New EIP idea to remove already deployed invalid EOF code. If account is called and its code starts with EF but is not valid EOF the execution is done normally (it will result in exception) but additionally the account\u2019s code is deleted (or alternatively account is added to selfdestruct list). This is similar to touching \u201cempty\u201d accounts in order to remove them from the state. The disadvantage is that we have to validate EOF code before every execution. However, after all invalid EOF code is deleted from the state the EIP can be silently disabled. The Mainnet has only 3 such contracts but there are rumors that some L2s have more. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.6789772727272725
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "39",
                    "likes": "0",
                    "time": "01/10/2022-11:44:46",
                    "content": "I\u2019m not a client dev so my intuition on this may be off, but it feels like an irregular state change to just remove those 3 accounts would be the simpler option. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wjmelements",
                    "index": "40",
                    "likes": "1",
                    "time": "06/10/2022-00:48:22",
                    "content": " EIP-3540 [Rationale]: Finally, create transaction must be allowed to contain legacy initcode and deploy legacy code because otherwise there is no transition period allowing upgrading transaction signing tools. Deprecating such transactions may be considered in future.  I\u2019m strongly opposed to breaking legacy initcode (eg UniswapV2Factory), but deprecation, perhaps via gas discrimination, could be beneficial to encourage adoption of EOF, once there is a demonstrated performance benefit. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.541666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wjmelements",
                    "index": "41",
                    "likes": "1",
                    "time": "06/10/2022-00:55:41",
                    "content": "    chfast:  If account is called and its code starts with EF but is not valid EOF the execution is done normally (it will result in exception) but additionally the account\u2019s code is deleted (or alternatively account is added to selfdestruct list).   There are other reasons to deploy bytecode besides executing it. I once used it to store a large amount of calldata for a subsequent operation. It is also useful for multisigs, but my usage was for storing verified bids in a crowd-liquidation system. This allows the finalization step to operate without knowing the details of the operation. It\u2019s unfortunate that EOF uses bytecode for the formatting and not the high bits of the eth balance. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.1423469387755105
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "42",
                    "likes": "0",
                    "time": "05/11/2022-16:01:30",
                    "content": "I put a clarification for EIP-3540 (EOFv1): EIP-3540: Clarify contract creation failure by chfast \u00b7 Pull Request #5878 \u00b7 ethereum/EIPs \u00b7 GitHub This is also a functional change because of geth implementation differs and therefore geth stance is reflected in the  state tests. So I assume many implementations followed this. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.458333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qbzzt",
                    "index": "44",
                    "likes": "0",
                    "time": "28/12/2022-21:38:45",
                    "content": "Why do we specify the number of code sections in two places:  In the type 1 EIP-4750 section header, where we specify <code sections>*4 for the length of the that section in bytes. In the type 2 code header, where we specify the number of code sections whose length we\u2019ll specify  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/matt",
                    "index": "45",
                    "likes": "1",
                    "time": "29/12/2022-19:58:11",
                    "content": "It gives us the possibility in the future to relax the strict ordering the header sections. If in the types 2 code header we used the value from the type 1 section, there would always be a requirement that the type header must precede the code header. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "46",
                    "likes": "1",
                    "time": "05/01/2023-14:09:49",
                    "content": "Published a lengthier discussion starter about a large changeset called \u201cEOFv2\u201d:    EOFv2 aka what \"EVM 2.0\" could look like Core EIPs       We have been thinking about the a number of proposals which have been made for EOF (most notable around account introspection) and summarised our thoughts in this document:   This gives our view on the roadmap of EOF (v1, and v2 \u2013 the final boss ).     ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.517857142857143
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/purplehat",
                    "index": "47",
                    "likes": "0",
                    "time": "06/01/2023-01:23:57",
                    "content": "Adding a comment here as an acknowledgement that we\u2019re following along with this EIP at Art Blocks as it relates to how we now do on-chain storage of artists\u2019 generative art scripts using our BytecodeStorage library. We have this issue on our end tracking this and have filed issues on the two common \u201cSSTORE2\u201d library implementations that we are aware of flagging this as well:  Update BytecodeStorage Library to be EOF-compliant, while also considering Shard Blob Storage \u00b7 Issue #422 \u00b7 ArtBlocks/artblocks-contracts \u00b7 GitHub Update SSTORE2 Library to be EOF-compliant (see EIP 3540) \u00b7 Issue #9 \u00b7 0xsequence/sstore2 \u00b7 GitHub Update SSTORE2 Library to be EOF-compliant (see EIP 3540) \u00b7 Issue #354 \u00b7 transmissions11/solmate \u00b7 GitHub  No response to this comment is expected, just flagging here for visibility. ",
                    "links": [
                        "https://github.com/ArtBlocks/artblocks-contracts/issues/422",
                        "https://github.com/0xsequence/sstore2/issues/9",
                        "https://github.com/transmissions11/solmate/issues/354"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.8125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/hritzdorf",
                    "index": "48",
                    "likes": "2",
                    "time": "10/01/2023-17:16:57",
                    "content": "Hi everyone, I would like to submit an EOF-related proposal. (Previously posted on the R&D Discord, but now here upon recommendation.) I have read the EIPs and have hopefully not missed anything. EOF1 contracts can only DELEGATECALL EOF1 contracts Motivation: Currently contracts can selfdestruct in three different ways (directly through SELFDESTRUCT, indirectly through CALLCODE and indirectly through DELEGATECALL). EIP 3670 disables the first two possibilities, however the third possibility remains. Allowing EOF1 contracts to only DELEGATECALL other EOF1 contracts allows the following strong statement: EOF1 contract can never be destructed. Specification: When an EOF1 contract performs a DELEGATECALL the target contract has to be EOF1. If it is not EOF1 (e.g. it is EOF0 or EOF2), the DELEGATECALL exceptionally halts. Hence, (among other things) all the gas passed along is consumed and 0 is pushed onto the stack. DELEGATECALL to an empty code also fails. Security Implications: Attacks based on SELFDESTRUCT simply disappear for EOF1 contracts. These include:  Lost library contract, e.g. Parity Multisig (https://www.parity.io/blog/a-postmortem-on-the-parity-multi-sig-library-self-destruct/) and more recently Aave v2 with multiple audits (Breaking Aave Upgradeability | Trail of Bits Blog) Other unprotected selfdestructs (SWC-106) Replacing code with new code using CREATE2 , SELFDESTRUCT and CREATE2  (legitimate use cases exist, but are rare)  Backwards Compatibility: No backwards compatibility is broken as EOF is newly introduced. In theory EOF1 contracts could use EOF0 libraries using DELEGATECALL but that seems relatively far fetched. Complexity: The check is relatively simple. Hence, no changes to the gas cost of DELEGATECALL would be needed and the implementation overhead should not be prohibitive. Please let me know if I should provide more clarifications, expand, write a PR or move this elsewhere. ",
                    "links": [
                        "https://blog.trailofbits.com/2020/12/16/breaking-aave-upgradeability/"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.292789001122334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shemnon",
                    "index": "49",
                    "likes": "0",
                    "time": "10/01/2023-17:32:28",
                    "content": "I think the biggest takeaway from this is if we don\u2019t restrict DELEGATECALL then it becomes an escape hatch to do any features we banned in EOFv1.  SELFDESTRUCT and CALLCODE are the only ones it really impacts right now, but it establishes a pattern. PC, JUMP, and JUMPI are not escapable because their scope is only on the EVM code. Note that if the calling contract doesn\u2019t matter then a regular CALL could be used to access the features at extra cost.  If we banned ECRECOVER from EOFv1 all we would be doing is just increasing the cost of that precompile to include a cold account load for the host contract.  Currently none of the precompiles depend on the caller so this is actually the current state for all precompiles.  We couldn\u2019t ban a precompile in EOF and expect contracts not to find a way to use it. So I\u2019m personally in favor of this. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.948051948051948
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "50",
                    "likes": "0",
                    "time": "09/02/2023-00:37:29",
                    "content": "During the Edelweiss interop there have been numerous discussions around EOF. We explored the idea how to properly reduce introspection, and discussed potential roadmaps. This document tries to give a glimpse into that process:    HackMD   EOFv1.1 aka EOF rollout Cancun+Prague - HackMD # EOFv1.1 aka *EOF rollout Cancun+Prague*  During the Edelweiss interop we discussed how to avoid co      ",
                    "links": [
                        "https://notes.ethereum.org/@ipsilon/BJujV7-Tj"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jtriley-eth",
                    "index": "51",
                    "likes": "0",
                    "time": "18/03/2023-04:28:48",
                    "content": "Would it make sense to have the code section sizes in the type section rather than in the header? At the time of writing, the header is dynamically sized based on the number of code sections, this complicates header validation. In addition, this splits up function metadata a bit. We need to check the header to get the function\u2019s size, then the type section to get the functions\u2019 inputs, outputs, and max stack depth, then finally the code section to get the function\u2019s instructions. If the code size (u16) is stored in the type section, then we could have all of the function metadata in the same place.  Current container: container  := header, body header := magic, version, kind_type, type_size, kind_code, num_code_sections, code_size+, kind_data, data_size, terminator body := type_section, code_section+, data_section type_section := (inputs, outputs, max_stack_height)+  Proposed container: container  := header, body header := magic, version, kind_type, type_size, kind_code, num_code_sections, kind_data, data_size, terminator body := type_section, code_section+, data_section type_section := (inputs, outputs, max_stack_height, size)+   With the proposed schema, the header will always be 13 bytes, simplifying header parsing and allowing functions to be validated as the type section is parsed without having to refer back to the header. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.6875
                }
            ]
        }
    ],
    "group_index": "1273"
}