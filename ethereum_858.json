{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-663-unlimited-swap-and-dup-instructions/3346",
            "title": "EIP-663: Unlimited SWAP and DUP instructions ",
            "index": 3346,
            "category": [
                "EIPs",
                "Core EIPs"
            ],
            "tags": [
                "evm",
                "opcodes",
                "shanghai-candidate",
                "cancun-candidate"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "1",
                    "likes": "0",
                    "time": "02/06/2019-22:58:13",
                    "content": "Discussion topic for  Ethereum Improvement Proposals   EIP-663: Unlimited SWAP and DUP instructions Introduce SWAPN and DUPN which take an immediate value for the depth      ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-663",
                        "https://ethereum-magicians.org/t/shanghai-core-eip-consideration/10777/41",
                        "https://ethereum-magicians.org/t/cancun-eip-consideration/12060/3",
                        "https://ethereum-magicians.org/t/cancun-network-upgrade-meta-thread/12060"
                    ],
                    "GPT-summary": "The post is discussing a proposal for Ethereum Improvement Proposal EIP-663, which introduces new instructions for SWAP and DUP. The author is explaining the proposal, while a third party is giving constructive criticism and asking questions about it.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Interoperability and Scalability",
                        "None",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "2",
                    "likes": "0",
                    "time": "20/06/2019-15:08:12",
                    "content": "@axic Where does the 1024 item limit come from? This seems out of line with the semantics of the current DUP* instructions. Also, is there currently any consensus on which of the three options to go with? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "3",
                    "likes": "0",
                    "time": "21/06/2019-16:34:57",
                    "content": "It is the core design of EVM, see the Yellow Paper page 11:  The EVM is a simple stack-based architec-ture.  The word size of the machine (and thus size of stackitems) is 256-bit.  This was chosen to facilitate the Keccak-256  hash  scheme  and  elliptic-curve  computations.   Thememory model is a simple word-addressed byte array.  Thestack has a maximum size of 1024.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "4",
                    "likes": "0",
                    "time": "21/06/2019-16:52:39",
                    "content": "Thanks, I see it now in the exceptional halting conditions too:  This states that the execution is in an exceptional halt-ing state if there is insufficient gas, if the instruction is invalid (and therefore its \u03b4 subscript is undefined), if there are insufficient stack items, if a destination is invalid, the new stack size would be larger than 1024 or state modification is attempted during a static call.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.808080808080808
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "5",
                    "likes": "0",
                    "time": "10/07/2019-19:57:26",
                    "content": " If the current stack depth is at the limit, a stack overflow exception is issued.  SWAP instructions do not increase the stack height so this sentence do not apply. It is not true for Option A where an additional argument is popped from the stack (so SWAP decreases stack and DUP keeps it the same height). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 4.708333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "6",
                    "likes": "0",
                    "time": "11/07/2019-06:04:15",
                    "content": "I prefer the immediate argument form, as I think in most all cases the swap or dup offset will be constant.  Variable offsets might help if you want to treat the stack more like an array in memory, but we have memory for that. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.666666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "7",
                    "likes": "0",
                    "time": "15/07/2019-13:16:12",
                    "content": "It must be specified if we count stack items from 0 or 1. I.e. is the top stack item an item at depth 0 or 1? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "8",
                    "likes": "0",
                    "time": "15/07/2019-13:18:47",
                    "content": "Currently, the spec for SWAPn is incorrect.  the top stack item is swapped with the item at depth n  For n referring the stack top item the instruction will swap the top item with itself. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "9",
                    "likes": "0",
                    "time": "15/07/2019-13:20:06",
                    "content": "Following the current convention, instructions should be named all uppercase. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chriseth",
                    "index": "10",
                    "likes": "0",
                    "time": "01/08/2019-10:10:19",
                    "content": "Not sure if this has been discussed, but I wanted to make the general remark about backwards-compatibility of introducing multi-byte opcodes. Introducing new multi-byte opcodes will influence jumpdest analysis and thus can have effects on all code following the point where the new multi-byte opcode is used in old code, not only the point itself: If the argument to a newly-introduced multi-byte opcode is the byte value of JUMPDEST, then this was a valid jump destination before the hard fork, but it is no longer a valid jump destination after the hard fork. Even worse, if the argument is a push opcode, the push data will be interpreted as code, while it was push data before. In the worst case, this might cascade all the way to the end of the code if some push data is the byte-value of jumpdest or of the newly introduced multi-byte opcode. Because of that, I would advise to use account versioning for any change that introduces new multi-byte opcodes. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.408508158508159
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gumb0",
                    "index": "11",
                    "likes": "1",
                    "time": "01/08/2019-11:20:05",
                    "content": "^ Here\u2019s simple test demonstating this problem   github.com/ethereum/evmone       Test demonstrating unlimited SWAP/DUP problem with jumpdests     by gumb0   on 11:15AM - 01 Aug 19 UTC     changed 1 files   with 13 additions   and 0 deletions.        Bytecode there is 600456b35b600060005260206000f3 ",
                    "links": [
                        "https://github.com/gumb0",
                        "https://github.com/ethereum/evmone/commit/5e94400b6076e6c4fe701d5a6695731c2bfeab11",
                        "https://github.com/gumb0",
                        "https://github.com/ethereum/evmone/commit/5e94400b6076e6c4fe701d5a6695731c2bfeab11",
                        "https://ethereum-magicians.org/t/eip-2315-simple-subroutines-for-the-evm/3941/121"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "12",
                    "likes": "0",
                    "time": "01/08/2019-16:32:25",
                    "content": "Using account versioning to introduce it would be overkill unless versioning is used anyway (required by any other EVM change). For me, using variant A is no-go. Requiring \u201cstatic\u201d push before DUPN/SWAPN introduces new kind of error - invalid code. Dynamic argument on the stack for an instruction manipulating the stack looks pretty weird. Not mentioning double the cost. I believe, the only option to proceed is to scan all deployed contracts for the opcodes pattern that would cause troubles. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.2258522727272725
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/karalabe",
                    "index": "13",
                    "likes": "0",
                    "time": "07/08/2019-10:24:26",
                    "content": "Multi-byte opcodes will node make it into Istanbul. Those would break one of the most basic invariants of EVM implementations, so that\u2019s not something we can ship in the 12th hour. I generally don\u2019t like the idea of account versioning, because it explodes the possible issues, so unless there\u2019s an extremely good reason to do it, I don\u2019t see that going in. This EIP is most definitely not worth versioned accounts (IMHO). @chfast Why does a static push introduce a possibility for invalid code? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the other topics listed match."
                    ],
                    "Sentiment": 6.3125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "14",
                    "likes": "0",
                    "time": "08/08/2019-08:32:44",
                    "content": "    karalabe:  Multi-byte opcodes will node make it into Istanbul. Those would break one of the most basic invariants of EVM implementations, so that\u2019s not something we can ship in the 12th hour.   I don\u2019t want to rush this EIP. Personally, I\u2019m not even interested in shipping this at all, but because solidity team expressed that this might be helpful to solidity and other languages and I touched it at some point I want to agree on the spec. Only if we have a spec (single variant) we can discuss when to ship it.     karalabe:  @chfast Why does a static push introduce a possibility for invalid code?   Option A requires a PUSH directly preceding SWAPN/DUPN instructions. In case there is no PUSH before we have to report a new kind of exception like \u201cmalformed instruction\u201d (but still unrecognizable from OOG by contracts) . I expect, following current EVM behavior in other places, the exception should happen when the instruction is reached, not when to code is analyzed  before execution. After writing the explanation, it might not be so bad as I thought previously and very different what we currently have in EVM. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.249518999518999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gumb0",
                    "index": "15",
                    "likes": "0",
                    "time": "08/08/2019-08:44:45",
                    "content": " Option A  requires a PUSH directly preceding SWAPN/DUPN instructions.  It doesn\u2019t strictly require it, it just gets the top item from the stack (with the possibility of regular stack underflow error) I guess what you mean is that this option makes it impossible to figure out during the pre-execution analysis the stack depth required for the opcode? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 4.620833333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "16",
                    "likes": "0",
                    "time": "08/08/2019-08:49:06",
                    "content": "    gumb0:  It doesn\u2019t strictly require it, it just gets the top item from the stack (with the possibility of regular stack underflow error)   This is exactly an option within Option A I\u2019d like to avoid. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "17",
                    "likes": "0",
                    "time": "08/08/2019-08:59:18",
                    "content": "I mean the JUMPDEST problem could be avoided by defining the new opcodes specially, s.t. they are only valid, if they are directly preceded by a PUSH2, so the new opcodes would in fact be the compounds 0x61 [two bytes of static stack depth] 0xb0 and 0x61 [two bytes of static stack depth] 0xb1 - that shouldn\u2019t cause any issues, right? But that\u2019s quite hacky and that\u2019s how I understood @chfast\u2019s comments. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.946158008658009
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "18",
                    "likes": "0",
                    "time": "08/08/2019-09:04:52",
                    "content": "Yes, that\u2019s good understanding. As far as Option A is concerned, I\u2019d like to require the PUSH1 or PUSH2 to directly proceed the DUPN/SWAPN instruction. In other words, the operand value of DUPN/SWAPN should be known during EVM program loading / bytecode analysis (whatever we call this phase of execution). Why this is important? The most effective EVM optimization is calculating gas (for most of the instructions) and checking stack requirements once per block of instructions. If the operand is \u201cdynamic\u201d the stack requirements are also \u201cdynamic\u201d and this optimization cannot be applied to DUPN/SWAPN making them much more expensive to execute. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.387499999999999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "19",
                    "likes": "0",
                    "time": "08/08/2019-11:05:07",
                    "content": "Just to confirm that: for the use in solidity (i.e. alleviating the limit on the number of \u201clive\u201d local variables), dynamic access to the stack is not required, so @chfast\u2019s variant of \u201cOption A made static\u201d would be sufficient for that. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "20",
                    "likes": "0",
                    "time": "11/08/2019-13:20:14",
                    "content": "One version of the EIP proposed this version: https://github.com/ethereum/EIPs/pull/663#issuecomment-312950394 I\u2019m not even sure why \u201cOption A\u201d ended up with this terrible wording, but it was supposed to be what you guys interpreted. It must be preceded by the PUSH opcode. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 3.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "21",
                    "likes": "0",
                    "time": "11/08/2019-13:27:13",
                    "content": "    axic:  I\u2019m not even sure why \u201cOption A\u201d ended up with this terrible wording, but it was supposed to be what you guys interpreted. It must be preceded by the PUSH opcode.   Pushed this as \u201cOption A+\u201d to the EIP to make discussion clearer: https://github.com/ethereum/EIPs/pull/2235 I think we can agree that \u201cOption A\u201d should not be accepted. Question about \u201cOption A+\u201d: if this option is considered, do we want to introduce a validation stage? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 3.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "22",
                    "likes": "0",
                    "time": "12/08/2019-22:59:20",
                    "content": "    chfast:  Dynamic argument on the stack for an instruction manipulating the stack looks pretty weird. Not mentioning double the cost.   Also because it ruins one of the good things about stack machines: http://troubles.md/posts/wasm-is-not-a-stack-machine/ ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "23",
                    "likes": "0",
                    "time": "06/09/2019-13:28:09",
                    "content": "There were some earlier discussions on the same topic here: https://github.com/ethereum/EIPs/issues/174 Probably nothing was mentioned there what didn\u2019t came up on this thread, but still good to have a reference. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.166666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "24",
                    "likes": "0",
                    "time": "10/05/2020-20:05:38",
                    "content": "Thing have been quiet here for too long.  With EIP-615 on indefinite hold I\u2019d like to see this one get into the clients fairly soon, @axic. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.083333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "25",
                    "likes": "0",
                    "time": "11/05/2020-20:29:17",
                    "content": "There was no progress made here beyond me updating the draft to reflect all the discussions. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "26",
                    "likes": "0",
                    "time": "11/05/2020-20:33:18",
                    "content": "Any reason not to put it on the core dev\u2019s agenda? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "27",
                    "likes": "0",
                    "time": "12/05/2020-09:07:09",
                    "content": "What is the point putting it on agenda if no progress has been made? There are some open questions. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "28",
                    "likes": "0",
                    "time": "12/05/2020-15:26:14",
                    "content": "OK. Guess we need to close the questions.  With the EIP-2315 subroutine proposal (rather than EIP-615) they look a lot more useful. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.166666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "29",
                    "likes": "2",
                    "time": "03/02/2022-14:19:56",
                    "content": "Updated this EIP to be dependent on EIP-3540 and thus able to use immediates. This simplified the proposal significantly. The current version is set to use an 8-bit immediate, allowing access to the top 256 items out of the total 1024 depth.  Since some old historical sections (i.e. References) have been removed according to current guidelines, here\u2019s a copy of it:  A similar proposal was made with EIP-174. Read the thread for some detailed discussion. Rootstock RSKIP26 also introduced SWAPN and DUPN with Option A described above.  ",
                    "links": [
                        "https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP26.md"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.852272727272727
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "30",
                    "likes": "0",
                    "time": "18/05/2022-08:20:47",
                    "content": "One question in the proposal:  We introduce the variable n which equals to imm + 1 .  Should n equals to imm + 17?  Since n = 1\u202616 cases are already covered by existing opcodes. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/qizhou",
                    "index": "31",
                    "likes": "0",
                    "time": "18/05/2022-08:54:00",
                    "content": "One way to ease the verification issue is to introduce a stack counter variable (sc), and the following opcodes: ADD_SC16 ADD_SC32 ADD_SC64 ADD_SC128 which will accumulate sc variable with the corresponding value. When calling the existing DUPx/SWAPx , x in 1\u202616, opcodes, it will actually do DUPx/SWAPx with the stack variable at position x + sc.  After calling DUPx/SWAPx, sc will be reset to 0.  Examples:  Two opcodes ADD_SC16 DUP1 = DUP17 \u2026 ADD_SC16 DUP16 = DUP32 ADD_SC32 DUP1 = DUP33 \u2026 ADD_SC32 DUP16 = DUP48  Three opcodes ADD_SC32 ADD_SC16 DUP1 = DUP49 \u2026 ADD_SC32 ADD_SC16 DUP16 = DUP64 ADD_SC64 DUP1 = DUP65 \u2026 ADD_SC64 ADD_SC32 DUP16 = DUP112  Four opcodes ADD_SC64 ADD_SC32 ADD_SC16 DUP1 = DUP113 \u2026 ADD_SC128 ADD_SC64 ADD_SC32 DUP16 = DUP240 where  using 2 opcodes (the same amount as DUPn + 1 byte of n), we could address up to 48th stack variables using 3 opcodes (the same amount as PUSH1 + 1 byte of n + DUPn), we could address up to 112th stack variables using four opcodes, we could address up to 240th stack variables.  In most cases, I think even addressing up to 48th stack variables should solve most of stack too deep issues as developers frequently experience. Note that we may impose the restriction that an ADD_SCx opcode must follow with another AD_SCx or DUP/SWAP opcode for better static analysis. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.05
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "32",
                    "likes": "1",
                    "time": "09/11/2022-12:01:51",
                    "content": "For the record, I\u2019d love to see this picked up again and be considered for inclusion for the initial EOF version :-). For us in Solidity, resp. actually for Yul, this would simplify things a lot and make it much easier to generate simpler and more optimal code. If there\u2019s interest and it helps, I could look into producing some stats about this, let me know. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.416666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "33",
                    "likes": "2",
                    "time": "12/11/2022-23:00:29",
                    "content": "    qizhou:  One question in the proposal:  We introduce the variable n which equals to imm + 1 .  Should n equals to imm + 17? Since n = 1\u202616 cases are already covered by existing opcodes.   That\u2019s actually a pretty nice proposal. Originally the idea was that one could just keep using SWAPN/DUPN` only, but since it has immediates, they are fixed just like the existing ones. I think it would make sense following your suggestion. @ekpyron @chfast wdyt? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.104166666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "34",
                    "likes": "0",
                    "time": "23/11/2022-20:39:18",
                    "content": "For the record (we also discussed this offline): We could work with it either way, but starting from 17 for the immediate argument opcodes and thus avoiding to have multiple opcodes with the same behaviour, also seems reasonable to me. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "35",
                    "likes": "2",
                    "time": "28/11/2022-20:40:40",
                    "content": "Probably more useful than SWAP_N would be SWAP_N_M, which takes two immediates and swaps the n\u2019th and m\u2019th stack items. This is important for stack scheduling as right now swapping the nth and mth items takes three instructions. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.857142857142858
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "36",
                    "likes": "1",
                    "time": "28/11/2022-20:45:29",
                    "content": "IMO there is no problem with having redundant instructions. Starting from 17 (i.e., SWAP_N 1 actually meaning SWAP17) would be a source of confusion and footguns, forever. The fact that the SWAP and DUP instructions were originally designed without immediates should not lead to a confusing design for the new instructions. Having the redundant instructions also provides a forward path for phasing out the old instructions, if that becomes attractive in the future. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.355681818181818
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "37",
                    "likes": "0",
                    "time": "28/11/2022-20:46:33",
                    "content": "    ekpyron:  starting from 17 for the immediate argument opcodes and thus avoiding to have multiple opcodes with the same behaviour, also seems reasonable to me.   The EIP was updated to reflect this and the wording was improved to be overall more clear: Clarifications to EIP-663 by axic \u00b7 Pull Request #6055 \u00b7 ethereum/EIPs \u00b7 GitHub     charles-cooper:  Probably more useful than SWAP_N would be SWAP_N_M, which takes two immediates and swaps the n\u2019th and m\u2019th stack items.   I think this would be a worthy idea to explore. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.966666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "38",
                    "likes": "0",
                    "time": "28/11/2022-20:52:05",
                    "content": "Since most of us weren\u2019t too decided (mostly just slightly in favour) about this and there was already a more concerned voice before yours, I think we are leaning towards not taking the +17 offset. The rationale read like:  The offset 17 was chosen to avoid these new instructions overlapping with the existing DUP? and SWAP? instructions, which are cheaper to deploy because they take a single byte. Having the overlap provides little benefit, and likely would see very little use.  We did consider \u201cdeprecating\u201d the old opcodes, but that could realistically only happen within EOF, and it felt like a harsh change due to the increased code size limit it would cause. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.285391691641692
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "39",
                    "likes": "0",
                    "time": "28/11/2022-21:03:54",
                    "content": "Well, I did not really mean that the old opcodes should be deprecated immediately. But at some point code size constraints may be less important. In any case, in the meantime, I don\u2019t see the conceptual complexity that will stem from N starting from 17 to justify having an extra 16 possible addressable items. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.349702380952381
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "40",
                    "likes": "0",
                    "time": "28/11/2022-21:04:33",
                    "content": "Maybe more fun than taking two immediate bytes would be taking 1 byte immediate. The high nibble represents N and the low nibble represents M. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.2
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "41",
                    "likes": "0",
                    "time": "29/11/2022-12:32:10",
                    "content": "That would be fully contrary to the intention of this EIP of making more of the stack space addressable, though. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "42",
                    "likes": "0",
                    "time": "29/11/2022-12:35:17",
                    "content": "What conceptual complexity, resp. what confusion and footguns, do you mean exactly? Generally, I\u2019d not expect people to decipher opcodes by hand - and disassembled, you\u2019d just print SWAP_N 0 as SWAP17. But in any case, either way is completely fine - the additional 16 items are indeed of no real concern. So if there is any strong preference to starting from zero, as far as I\u2019m concerned we can just go with that as well. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.419642857142857
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "43",
                    "likes": "1",
                    "time": "30/11/2022-02:23:50",
                    "content": "It\u2019s a conceptual hurdle for anybody learning the EVM, or writing a low level tool/assembler/disassembler to understand, maintain and debug. I don\u2019t think it\u2019s necessarily a huge hurdle, but it is a nonzero one which IMO is not outweighed by the additional space addressability (I don\u2019t think the extra 16 items will be useful in practice, although if I see a compelling example I could have my mind changed). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wjmelements",
                    "index": "44",
                    "likes": "0",
                    "time": "30/11/2022-03:57:14",
                    "content": "I like that the spec reads the stack index inline, as PUSH opcodes do.  If the code is legacy bytecode, both of these instructions result in an exceptional halt  I don\u2019t want to prevent non-EOF code from using this, because I don\u2019t plan to adopt EOF. Contracts shouldn\u2019t be using invalid opcodes to revert, so it shouldn\u2019t matter if we break such behavior for legacy contracts. We haven\u2019t done the same for other opcodes introduced in the past. Why is it being done here? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.291666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "45",
                    "likes": "1",
                    "time": "30/11/2022-03:59:17",
                    "content": "    wjmelements:   If the code is legacy bytecode, both of these instructions result in an exceptional halt  I don\u2019t want to prevent non-EOF code from using this, because I don\u2019t plan to adopt EOF. Contracts shouldn\u2019t be using invalid opcodes to revert, so it shouldn\u2019t matter if we break such behavior for legacy contracts. We haven\u2019t done the same for other opcodes introduced in the past. Why is it being done here?   Exactly because of the property you like:     wjmelements:  I like that the spec reads the stack index inline, as PUSH opcodes do.   This cannot be achieved on legacy code, due to jumpdest-analysis and that existing code on chain can contain this instruction already (here\u2019s one explainer on the current thread). The use of immediate (in-line) arguments is made possible by EOF. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.231481481481481
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "46",
                    "likes": "0",
                    "time": "30/11/2022-09:49:37",
                    "content": "Yeah, fair enough. And yeah, as I said, you\u2019re right, reaching the additional 16 items is definitely not overly relevant in practice. The (weak) argument for starting at 17 was rather to avoid having duplicated, resp. \u201cuseless\u201d opcodes (i.e. SWAP_N 0...SWAP_N 16 would never be used, as long as we still have SWAP1...SWAP16). But yeah, if we want to keep the option to deprecate or remove the old swaps eventually (even though I\u2019m not sure that\u2019ll ever actually happen), resp. since there\u2019s concern about starting at 17 making it harder to maintain tools (even though I also don\u2019t think that\u2019s that significant), I see no problem with starting from 0 instead. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.361904761904762
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "47",
                    "likes": "3",
                    "time": "30/11/2022-15:18:38",
                    "content": "    axic:      ekpyron:  starting from 17 for the immediate argument opcodes and thus avoiding to have multiple opcodes with the same behaviour, also seems reasonable to me.   The EIP was updated to reflect this and the wording was improved to be overall more clear: Clarifications to EIP-663 by axic \u00b7 Pull Request #6055 \u00b7 ethereum/EIPs \u00b7 GitHub   This clarification to the spec was merged, but the +17 idea was not included. That is tracked in this branch now, pending decision: GitHub - ipsilon/EIPs at eip-663-plus17 ",
                    "links": [
                        "https://github.com/ipsilon/EIPs/tree/eip-663-plus17"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.571428571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "48",
                    "likes": "1",
                    "time": "05/12/2022-23:14:53",
                    "content": "For what it\u2019s worth, there was some feedback from Twitter people wanting SWAPMN: https://twitter.com/alexberegszaszi/status/1598124647723433984 If it were to happen, XCHG may sound like an alternative name. However some questioned how frequent the use case for SWAPMN may be: https://twitter.com/recmo/status/1598215821125304321 ",
                    "links": [
                        "https://twitter.com/recmo/status/1598215821125304321"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "49",
                    "likes": "0",
                    "time": "06/12/2022-17:36:46",
                    "content": "A couple thoughts: 3-4 SWAP_N instructions will cover the entire addressable space of 1024 stack items. We could have potentially 1-3 SWAP_N_M instructions which take different numbers of immediates to address codesize concerns. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/green",
                    "index": "50",
                    "likes": "0",
                    "time": "31/01/2023-10:44:40",
                    "content": "What would the tradeoffs be for, instead of using immediate opcodes, using the first element(s) of the stack for the DUP / SWAP as suggested here? EIP-? : Introduce Opcodes B0 DUPN and B1 SWAPN - #2 by gumb0 The immediate argument idea seems simpler to implement, so I assume it\u2019s the best choice. SWAP_N_M as suggested by @charles-cooper would allow optimizing and cleaning a lot of EVM compiler code. Would it be in scope to add these three? DUP_N SWAP_N SWAP_N_M ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 8.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Philogy",
                    "index": "51",
                    "likes": "0",
                    "time": "03/02/2023-13:18:38",
                    "content": "The big tradeoff with using stack values as parameters vs immediate values is that there\u2019s more overhead, will probably cost more gas, and allows less upfront validation and analysis. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.041666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shemnon",
                    "index": "52",
                    "likes": "1",
                    "time": "03/02/2023-21:25:38",
                    "content": "What we lose with stack reading is provably static dups and swaps.  With some code flow analysis you can prove some stack based loads are static, but it opens the door to dynamic swaps and dups (which may be useful for on-stack arrays).  Dynamic swaps and dups, however, nerf almost all useful register mapping schemes.  It also complicates the stack proving requirements in EOF. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None"
                    ],
                    "Sentiment": 6.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "53",
                    "likes": "0",
                    "time": "14/02/2023-02:48:46",
                    "content": "My understanding is that static stack machine code is essentially already in SSA form. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/k06a",
                    "index": "54",
                    "likes": "1",
                    "time": "10/03/2023-09:01:16",
                    "content": "I would prefer to have this EIP accepted instead of having stack allocation in memory which is happeing in the Solidity compiler with \u201cviaIR\u201d option ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                }
            ]
        }
    ],
    "group_index": "858"
}