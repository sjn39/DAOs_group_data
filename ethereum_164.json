{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-1344-add-chain-id-opcode/1131",
            "title": "EIP-1344: Add chain id opcode ",
            "index": 1131,
            "category": [
                "EIPs"
            ],
            "tags": [
                "opcodes",
                "chain-id"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "1",
                    "likes": "10",
                    "time": "22/08/2018-10:09:57",
                    "content": "https://github.com/ethereum/EIPs/pull/1344 proposes to add an opcode to retrieve the chain id of the chain that the block has been mined on. This would allow smart contract to validate signatures that use replay protection (as proposed in EIP-155). Currently the only way is to hardcode the chain id into the smart contract. This poses a problem in case of a hardfork. This opcode would allow multi signature contracts that use signatures to implement better replay protection and increase security. ",
                    "links": [
                        "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md",
                        "https://ethereum-magicians.org/t/eip-1959-valid-chainid-opcode/3170",
                        "https://ethereum-magicians.org/t/ecrecover-should-handle-chainid/3634",
                        "https://ethereum-magicians.org/t/eip-695-create-eth-chainid-method-for-json-rpc/1845/9",
                        "https://ethereum-magicians.org/t/definitions-of-governance-layers/3054/6",
                        "https://ethereum-magicians.org/t/eip-712-eth-signtypeddata-as-a-standard-for-machine-verifiable-and-human-readable-typed-data-signing/397/12",
                        "https://ethereum-magicians.org/t/eip-2294-explicit-bound-to-chain-id/11090",
                        "https://ethereum-magicians.org/t/should-the-chainid-change-with-every-hardfork/10347"
                    ],
                    "GPT-summary": "The post proposes the addition of an opcode to retrieve the chain id of the chain that the block has been mined on. This would allow smart contracts to validate signatures that use replay protection. The post explains the problem with hardcoding the chain id into the smart contract and how the proposed opcode would increase security. The post also invites feedback and questions about the proposal.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Interoperability and Scalability",
                        "Privacy, Security and risk management",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.928571428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "2",
                    "likes": "7",
                    "time": "01/04/2019-22:22:35",
                    "content": "This is an excellent proposal, and would be very valuable in EIP-712 applications. EIP-712 Domain Separator suggests the use of the EIP-155 Chain ID to ensure the user-agent refuses signing if it does not match the currently active chain. This is also valuable in the smart contract use case where full message validation must be done in order to ensure the off-chain message was signed appropriately. I would suggest that this EIP get a second look for inclusion in Istanbul, as a useful pre-requisite for Layer 2 scaling technologies that may use EIP-712 signing. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving entirely positive feedback on proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.519345238095237
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shemnon",
                    "index": "3",
                    "likes": "0",
                    "time": "02/04/2019-00:34:26",
                    "content": "Would this be better served by a precompiled contract instead of an Opcode? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "4",
                    "likes": "1",
                    "time": "02/04/2019-01:29:19",
                    "content": "I\u2019m not sure what you mean? Chain ID is currently available through RPC, and it\u2019s important as a domain separator to differentiate between off-chain messages meant to be signed for mainnet vs. some testnet with a different ID. Should be no different than looking up other environment variables such as msg.sender or block.timestamp ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0703125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "5",
                    "likes": "2",
                    "time": "02/04/2019-07:38:51",
                    "content": "I would not do that, this would unnecessarily increase the gas costs from 3 to a couple hundreds. Also precompiles are used for expensive operations that are not often used. Not sure that this would match in this case ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 3.0833333333333335
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ligi",
                    "index": "6",
                    "likes": "3",
                    "time": "02/04/2019-09:04:22",
                    "content": "added a issue for this EIP in the geth repo: https://github.com/ethereum/go-ethereum/issues/19368 should be looked at on issue-triage next tuesday ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pedrouid",
                    "index": "7",
                    "likes": "1",
                    "time": "02/04/2019-09:39:17",
                    "content": "I second everything that @fubuloubu and @rmeissner said  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shemnon",
                    "index": "8",
                    "likes": "2",
                    "time": "02/04/2019-13:58:28",
                    "content": "SHA3 is a relatively expensive operation and has an opcode. The reason I think we should always as the \u201cwould a precompiled contact be more appropriate\u201d question is that if we try and keep opcodes to a single byte it is a limited resource that will be exhausted whereas precompiled contracts have a much, much higher limit (theoretically). So this is fine as an opcode, we just need to be sure other options were not better. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.113095238095237
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "9",
                    "likes": "0",
                    "time": "02/04/2019-14:07:03",
                    "content": "I think chainId is a uint32 parameter, can someone confirm that? What is max chainId? EDIT: It looks like EIP-712 defines it as a uint256 (one machine word), so that would probably be fine. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 7.083333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shemnon",
                    "index": "10",
                    "likes": "4",
                    "time": "02/04/2019-14:42:40",
                    "content": "I view this as an opportunity to nail down what the value of CHAIN_ID can be.  It\u2019s not well defined. The yellow paper defines v as 1 byte (Appendix F, v is a member of open bar B sub 1), and per the spurious dragon fork chain_id is encoded into v (0x35+CHAIN_ID) which leaves room for only 101 networks.  However EIP-155 where this scheme was introduced defines 1337 as a Geth devnet, which breaks this. When RLP encoded technically the size is unlimited, so Geth uses a big.Int (go library for arbitrary precision).  But Parity uses a u64 (unsigned 64 int byte) and pantheon uses an int (32 bit signed) since none of the known networks have CHAIN_IDs > 4 million\u2026 yet. EIP-712 is still draft so it shouldn\u2019t be authoritative, and can still be updated as well. Any of the fixed length values sounds fine to me (256, 64, 32), but there should be test cases testing some common known values, values up to the limit, and values over the limit of the chain_id.  We also should look into updating Appendix F of the Yellow Paper with the correct values to give some specification weight to the limit. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.118686868686869
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "11",
                    "likes": "1",
                    "time": "02/04/2019-14:51:24",
                    "content": "https://chainid.network/ has several over 4 million, but I think you meant 4 billion (2**32) which indeed, no one is over that number (according to the website) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shemnon",
                    "index": "12",
                    "likes": "1",
                    "time": "02/04/2019-15:05:46",
                    "content": "So signed int, actually 2 billion :(.  But still a large number but not as large as it feels compared to longs and uInt256 numbers. I think the best choices are uint64 because almost all languages have native support for that, or uint256 which has the added ability to have a chain_id that is a hash output of the hash functions typically used in ethereum. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.426587301587301
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "13",
                    "likes": "0",
                    "time": "02/04/2019-15:30:57",
                    "content": "    shemnon:  have a chain_id that is a hash output of the hash functions typically used in ethereum   Yeah, I was thinking about this too. Having a hashed DID that referred to the network configuration would be very valuable for replay protection of txn signing ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.083333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "14",
                    "likes": "2",
                    "time": "02/04/2019-15:47:35",
                    "content": "I am a fan of this proposal and an opponent of certain details EIP-155. PROPOSAL: The correct chain ID should be sha3(tar_gz(reference_implementation) || genesis_block). If the reference implementation changes to an incompatible version (i.e. a hard fork) then the chain ID is changed. EIP-155 was created because Ethereum\u00ae was originally designed as a single network. Nobody expected that there would be a fork. The community reacted by taking the unfavored fork (Ethereum Classic) and assigning it a separate chain ID. Then mainnet=1 was reserved for Ethereum\u00ae. The problem is that our current process is yet again unprepared for the possibility that another fork comes. Specifically, if a proposed upgrade happens to Ethereum\u00ae and the community rejects this upgrade then we will yet again have the situation where chain=1 transactions are being processed on the community-supported \u201cEthereum\u201d as well as the the Stiftung Ethereum, Zug / Ethereum\u00ae networks. The proposal above solves the problem. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.183035714285714
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "15",
                    "likes": "1",
                    "time": "02/04/2019-16:20:09",
                    "content": "    fulldecent:  PROPOSAL: The correct chain ID should be sha3(tar_gz(reference_implementation) || genesis_block) . If the reference implementation changes to an incompatible version (i.e. a hard fork) then the chain ID is changed.   What\u2019s the reference implementation? I was thinking about configurations of core components, such as the EVM, mining algorithm, and state system. That probably has a lot of issues (every wallet would have to change their signing algo on a new release). Maybe I\u2019m mixing in too many things with that idea (I believe Ethereum\u2019s configuration management is poor) Hash of the Genesis block would be interesting! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.474747474747474
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "16",
                    "likes": "7",
                    "time": "02/04/2019-16:28:22",
                    "content": "Alright, I think we can all agree that any discussions of what chainId should be is out of scope for this proposal, but we do need to capture what data type and limits are applicable to the use of chainId so we make sure this opcode captures potential nuance. EDIT: I also think networkId is out of scope for an EVM opcode because it describes network interfaces not transaction signing ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shemnon",
                    "index": "17",
                    "likes": "2",
                    "time": "02/04/2019-21:08:09",
                    "content": "I vote uint256.  It will be more code changes in Pantheon but it opens up the meaning of chain_id to more interesting possibilities. Note that unless you use a chainID > 64 bits parity won\u2019t notice.  But I think that should be thrown in test cases and noted as such. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ajsutton",
                    "index": "18",
                    "likes": "1",
                    "time": "02/04/2019-22:52:20",
                    "content": "    shemnon:  I vote uint256. It will be more code changes in Pantheon but it opens up the meaning of chain_id to more interesting possibilities.   I\u2019d keep it small - 2 billion chains should be enough for anyone.  I haven\u2019t seen any proposals where a hash would be used that make any real sense.  You can\u2019t hash the genesis block because it\u2019s the same for both sides of a fork, hashing the reference implementation has all kinds of issues around centralisation but also breaking the entire chain every time a new release comes out.  Eventually you wind up picking an arbitrary thing to hash and all agreeing on it so why not just pick a number? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.743181818181818
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "19",
                    "likes": "0",
                    "time": "03/04/2019-00:58:00",
                    "content": "100% and if you REALLY wanted to do a hash, just slice the first or last (or middle???) 8 bytes. Probably enough entropy there to be used as an ID. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.45
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/drinkcoffee",
                    "index": "20",
                    "likes": "1",
                    "time": "03/04/2019-01:36:57",
                    "content": "I agree with @shemnon - it should be a 256 bit value. We are looking to use the Chain ID as our Sidechain ID for our ephemeral on-demand permissioned private sidechains technology. Having a 256 bit value means that we can use the id, a public value, in conjunction with private values to derive cryptographic keys, salts and other cryptographic values.  Using a value smaller than 256 bits could open the system up to security issues. If the value is 256 bits, then if we randomly generate it, it is unlikely to have a collision with an existing sidechain id. If we did have a clash, chances are it is an attack, and we can deal with it assuming it is an attack. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.296875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "21",
                    "likes": "0",
                    "time": "03/04/2019-08:39:26",
                    "content": "I agree, it is not as simple as \u201cIs it expensive or not\u201d For me it is a combination of, how much gas would be appropriate for such a call and how often would such a call be used. Probably an argumentation for this should be added to the EIP. Something like: Signatures are widely used (e.g. state channels, multi signature wallets and relays) currently all these signatures can not be properly protected against cross-chain replay attacks. As we assume that all these signatures will use this opcode it would be preferred to use an opcode, to be gas efficient. This might be something else if EIP-1109: Remove call costs for precompiled contracts would be part of the next hardfork too ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.05
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "22",
                    "likes": "0",
                    "time": "03/04/2019-13:45:58",
                    "content": "    rmeissner:  how much gas would be appropriate for such a call and how often would such a call be used       rmeissner:  [W]e assume that all these signatures will use this opcode it would be preferred to use an opcode, to be gas efficient.   I think you got the likelihood of use down, the alternative to the current design is that everyone either manually configures a constant in their deployed bytecode, or adds a deployment parameter which requires deeper state variable access to read. In aggregate, especially as these solutions get deployed more, it is probably causing a worse impact to the state growth of Ethereum than it would to query CHAINID through a new opcode. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.012836700336701
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pedrouid",
                    "index": "23",
                    "likes": "1",
                    "time": "07/04/2019-09:32:57",
                    "content": "I think it\u2019s more reasonable to have a smaller chainId integer but since EIP155 did not specify it we now have a few chainId\u2019s with over 64 bits so I think we should just use uint256. Also it would match the current EIP712 spec. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "24",
                    "likes": "2",
                    "time": "09/04/2019-01:47:21",
                    "content": "I suggested this proposal be added to the All Core Devs call #59 for further discussion of implementation and bringing it to Last Call for inclusion into the Istanbul roadmap. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "25",
                    "likes": "3",
                    "time": "09/04/2019-09:32:42",
                    "content": "I should be able to participate in the call  Just as a reminder to myself, the open questions are:  OpCode vs Precompile Size of chainId value (uint256 or uint8)  Did I miss something? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "26",
                    "likes": "1",
                    "time": "09/04/2019-10:55:57",
                    "content": "I think it\u2019s largely decided to be an opcode, a pre-compile would not make sense for this functionality I do not think. The data type is an interesting question, I think it needs to be at least uint32, but uint256 (one machine word) would match the EIP-712 specification. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.69047619047619
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "27",
                    "likes": "0",
                    "time": "11/04/2019-16:59:21",
                    "content": "Added this EIP to the Istanbul hardfork EIP through https://github.com/ethereum/EIPs/issues/1935  Edit: Updated from PR to Issue per https://github.com/ethereum/EIPs/pull/1929 ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/1929"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "28",
                    "likes": "1",
                    "time": "12/04/2019-01:44:23",
                    "content": "@rmeissner, a few housekeeping updates were requested here:  https://github.com/ethereum/EIPs/issues/1935#issuecomment-482399373 P.S. started an implementation here:    GitHub    fubuloubu/py-evm A Python implementation of the Ethereum Virtual Machine - fubuloubu/py-evm        Edit: Taken care of here: https://github.com/ethereum/EIPs/pull/1936#issuecomment-482434400 @rmeissner Please approve! ",
                    "links": [
                        "https://github.com/fubuloubu/py-evm/tree/eip1344-chain-id",
                        "https://github.com/fubuloubu/py-evm/tree/eip1344-chain-id",
                        "https://github.com/ethereum/EIPs/pull/1936#issuecomment-482434400"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 3.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/veox",
                    "index": "29",
                    "likes": "1",
                    "time": "12/04/2019-16:28:03",
                    "content": "    fulldecent:  The problem is that our current process is yet again unprepared for the possibility that another fork comes. Specifically, if a proposed upgrade happens to Ethereum\u00ae and the community rejects this upgrade then we will yet again have the situation where chain=1 transactions are being processed on the community-supported \u201cEthereum\u201d as well as the the Stiftung Ethereum, Zug / Ethereum\u00ae networks.   I\u2019d like to re-iterate this after today\u2019s dev call, around 41:59. Snippets:  @fubuloubu: If a hard-fork does occur, then code on one chain won\u2019t be replayed on another chain. @holiman: No\u2026 (\u2026) We never change the chainids\u2026 are we? @fubuloubu: Like an actual contentious hard-fork, where there\u2019s two communities. @holiman: Ri-i-ight\u2026 But\u2026 @fubuloubu: So, they would change their chainid.  This is the core of the misunderstanding. In an actual contentious hard-fork, both sides place claim on being \u201cthe one True chain\u201d (refuse to let go of memetic artifacts: these are valuable); conceding and changing chainid is a move that weakens the claim, so it\u2019s unlikely to happen. As @fulldecent highlights, the issue has been side-stepped in the case of TheDAO split, because chainid was introduced after the fork1; no magic number was already more \u201cvaluable\u201d than another, so any could be picked.  The proposal, as it stands, does not guarantee replay protection in case of a contentious hard fork. For that to be true (procedurally), a chainid must change; but, as Martin said, we have no procedure ATM to change chainid - neither who does it, or when. It has also never previously happened. What it can be useful for is same-code same-address deployments across multiple chains.2 For example, ones that want to use ENS on both main-net and Ropsten.3 Or something like a cross-chain bridge\u2026  On a more abstract level, there is no way to future-proof against \u201cundesirable splits\u201d without specifying exactly what to consider \u201cundesirable\u201d. Essentially, writing a fork oracle once the point of contention is known.4 A blanket condition like \"chainid changes\" won\u2019t cut it, and - I\u2019d argue - is counter-productive: both sides of the split will want to maintain contracts\u2019 behaviour as it was before the split. This is no longer just a struggle for mind share, but now also a question of \u201chow much of the ecosystem will act up?\u201d  1 This was the first time that importance of cross-chain transaction replay protection on value-bearing networks was demonstrated. 2 This is a niche use pattern, and I haven\u2019t seen many people do it; certainly not brand-name projects. 3 The ENS Registry contract is at different addresses; the TLDs are respectively .eth and .test for main-net and Ropsten; etc\u2026 4 It\u2019s a lot of fun! ",
                    "links": [
                        "https://wemakethings.net/2016/07/18/thedaohardforkoracle/"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.57034632034632
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "30",
                    "likes": "1",
                    "time": "12/04/2019-17:58:23",
                    "content": "Thanks for the ping. Regarding bits 32 bits is insufficient for a chainId, for sure. Even without trying we would seeing unintentional collisions soon. Right now we are considering intentional choices of chainId (\u201ctoday is nice weather, I think I will choose chainId 42 for my network and nobody else should.\u201d). But in the future there will be many more chains and they will be created programmatically. So we need to be concerned with unintentional chains. The birthday problem says we only need 65k networks for that to happen. This will happen in the foreseeable future. Regarding same code deployed at the same address on multiple chains This is specified in ERC-1820 and is currently deployed. Regarding what is a reference implementation A reference implementation is some code in any language that is compatible with every other client on the network. Most importantly it is an identifier (a URN) that will not be confused with any other identifier. The easiest, decentralized way to do this is to publish reference implementation code and hash it. Ideally this implementation will isolate only the consensus part (validating blocks) and the hashing for-loop/P2P/storage will be a separate program/process/module. Regarding contentious fork     veox:  So, they would change their chainid .   This is the tongue-in-cheek explanation that best illustrates the problem with a contentious fork. Here is more detail on how an upgrade would work when a chainID = hash(code | genesis). All use cases assuming current block is 1,000,000. The current chainId is 11af1af2989... Use case 1: normal upgrade that everybody wants Case study: Tangerine Whistle, block 2,463,000  Hudson publishes on Ethereum.org (could actually be anybody publishes anywhere) to upgrade your client for Pimpled Frog upgrade on block 2,000,000. New chainId uses same genesis and hashed with the new software is 22af2af3562...  All miners upgrade to run the new software From 1,000,000 to 1,999,999 the CHAINID opcode returns 11af1af2989 ...  Truffle, MetaMask, Opera and more update to know about 22af2af3562...  End users sign transactions using 11af1af2989... AND optionally 22af2af3562... Some transactions get included in blocks up to 1,999,999. After 1,999,999 all the pool transactions that were signed with 11af1af2989... are discarded by new miners. The old network continues to exist and process 11af1af2989... transactions. But nobody cares about it.  Use case 2: Contentious fund recovery starts a new viable network Case study: DAO Fork, block 1,920,000  Same  Some miners upgrade Same  Some end-user software upgrades  Some end-users DO NOT sign transactions using the new chainId Same Same  Some people continue to care about the old network  Use case 3: Aborted upgrade Case study: Constantinople upgrade, block 2,675,000  Same Same Same Same Same Same  Most miners downgrade to previous software before block 2,000,000 The new network is created but nobody cares about it.  Use case 4: Failed contentious upgrade Case study: This could conceivably happen if Stiftung Ethereum, Zug (ethereum.org) publishes a recommendation to retrieve funds from the Parity wallet.  Same  Some miners upgrade Same Same Same Same Same The new network is created and some people care about the old one and some people care about the new one.  ",
                    "links": [
                        "http://ethereum.org"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.618550848059045
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "31",
                    "likes": "1",
                    "time": "12/04/2019-22:03:27",
                    "content": "    veox:  What it can be useful for is same-code same-address deployments across multiple chains.2 For example, ones that want to use ENS on both main-net and Ropsten.3 Or something like a cross-chain bridge\u2026   Yeah, this was primarily what I was thinking would be valuable.     veox:  A blanket condition like \" chainid changes\" won\u2019t cut it, and - I\u2019d argue - is counter-productive: both sides of the split will want to maintain contracts\u2019 behaviour as it was before the split. This is no longer just a struggle for mind share, but now also a question of \u201chow much of the ecosystem will act up?\u201d   I definitely see your point here, but this does leave a path for upgrade to systems that make use of this additional opcode. Since the opcode check (in the example EIP-712 use case) is for the present value of chainid that means any off-chain transactions from the point of update could re-target the new chainid, and all old messages would be unusable. You are definitely right that this does not motivate a sustained fork to change their chainid, but the use of this opcode would allow for an \u201cautomatic upgrade\u201d of that off-chain signing functionality versus an immutable value sent on deployment (or worse: a maintained value by the original developer). This may actually create a motivation by users of the opposing fork to convince operators of the new fork to upgrade, so that their application activities can be separated from their application activities. It\u2019s a big game of chicken of course, but that added friction must get resolved one way or another. This is all highly hypothetical of course, but interesting to think about. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.331511544011543
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "32",
                    "likes": "0",
                    "time": "12/04/2019-22:07:50",
                    "content": "So I think this line of reasoning is very sound for Ethereum transactions signed with chain id meant for the Ethereum network directly. I think the conversation changes a bit when you consider off-chain signed transactions meant for Layer 2 and/or meta-transaction use cases   This is specified in ERC-1820 and is currently deployed.  This requires you actively registering your interfaces with a registry, and doesn\u2019t really solve the chain-specific domain separation issue. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.6866666666666665
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "33",
                    "likes": "1",
                    "time": "13/04/2019-15:25:46",
                    "content": "I feel like this conversation may have again gotten a little off track. This EIP is a net benefit because it aligns the domain separator protection of base layer transactions (e.g. an Ethereum transaction) with those of Layer 2 and metatxn signed messages. It avoids the human error of current solutions and is a directly applicable to a widely accepted and imminently useful standard (EIP-712) that is being implemented in multiple libraries and clients. There doesn\u2019t seem to be any technical concerns with this approach, we\u2019ve fully specified the implementation, the topic has been discussed on ACD and recommended for inclusion into Istanbul. Are there any issues with moving the status to Last Call with the proposal in it\u2019s current form? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.735576923076923
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "34",
                    "likes": "1",
                    "time": "14/04/2019-19:20:10",
                    "content": "The specification is technically complete and is eligible to proceed to Last Call. We don\u2019t yet know which implementations will use this. But I suspect that all of them will introduce problems compounding on the issues detailed above. Especially off-chain and layer-2 transaction applications. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "35",
                    "likes": "0",
                    "time": "14/04/2019-19:38:13",
                    "content": "    fulldecent:  We don\u2019t yet know which implementations will use this. But I suspect that all of them will introduce problems compounding on the issues detailed above. Especially off-chain and layer-2 transaction applications.   I\u2019m still not sure I understand this sentiment. Taking EIP-712 as an example, if chainId is used in the domain separator, then it currently has to be either a deploy time constant, or a parameter controlled by some trusted third party with higher access control to be upgraded. A contract\u2019s code or deployment procedure also has to account for this nuance when deploying to different test networks and the main network, so it very obviously introduces human error into the process. This proposal simply aligns extra-protocol message signing using chainId as a domain separator to in-protocol transaction signing that also uses it for the same purpose. I agree with you that it is difficult to ensure chainId is updated on one fork in a contentious fork event, but that\u2019s outside the scope of this proposal, and it also affects in-protocol signing in the same fashion. I would largely argue it has to be resolved one way or the other in this kind of event if the two forks are to co-exist peacefully as it\u2019s the primary method for replay protection between chains. By aligning off-chain and on-chain signing, there is more friction ensuring this eventually gets resolved. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.414337474120083
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "36",
                    "likes": "0",
                    "time": "15/04/2019-00:15:24",
                    "content": "First, everything we are saying is hypothetical because there are no deployed off-chain or layer-2 applications to study. When they are available some will surely make the mistake of assuming that a chainID will not change ever. Similarly they will probably make the mistake of assuming that the consensus client will never change. These are unrelated but both demonstrate sloppiness. My sentiment is simply that chainID currently has a known weakness. And this proposal is to weld the chainID onto the EVM. At the same time, of course it is quite simple to deploy an oracle (using the same account on each network) to return the chainID. I would prefer this approach until applications are better understood. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.825
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "37",
                    "likes": "1",
                    "time": "15/04/2019-03:26:41",
                    "content": "    fulldecent:  First, everything we are saying is hypothetical because there are no deployed off-chain or layer-2 applications to study.   Working on it!      fulldecent:  When they are available some will surely make the mistake of assuming that a chainID will not change ever. Similarly they will probably make the mistake of assuming that the consensus client will never change. These are unrelated but both demonstrate sloppiness.   How is it our job to babysit developers on how to use an opcode? The EVM is not a safe environment, everything is \u201cuse at your own risk\u201d. You also don\u2019t have to use the opcode if you don\u2019t want to.     fulldecent:  At the same time, of course it is quite simple to deploy an oracle (using the same account on each network) to return the chainID. I would prefer this approach until applications are better understood.   This seems like a poor solution to me. It relies on a trusted third party and uses an excessive amount of gas for a simple operation that is easily accessible contextual information already available in a transaction.     fulldecent:  My sentiment is simply that chainID currently has a known weakness. And this proposal is to weld the chainID onto the EVM.   I don\u2019t think this is good reasoning to block implementation of this opcode in the Istanbul fork. If the method of chosing chainId has a problem, that is out of scope of this EIP and we should not be making value judgements for what is ultimately an established part of existing standards just because it has \u201cpotential\u201d complications in a few corner cases that don\u2019t even affect any existing applications (as you already noted!). This proposal doesn\u2019t make it worse than what it already is. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.5085227272727275
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "38",
                    "likes": "0",
                    "time": "15/04/2019-04:08:37",
                    "content": "Imagine a scenario where this proposal wasn\u2019t implemented, and an alternative like an on-chain oracle were in use. If the value produced by the oracle mismatched what the protocol says, this would be a potential griefing attack. EIP-712 messages signed with a chainId domain separator would use the RPC provides value to sign with, which now mismatches the chain. This means all messages that are signed would get rejected, and the oracle becomes a critical piece of infrastructure that limits the amount of value placed on any Layer 2 solution. This griefing mechanism exists even outside of a change to the value of chainId. Conversely, this proposal implements it in the EVM as a feature, directly matching the protocol\u2019s value with no additional trust required. Sounds like a safer option to me! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.15625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "39",
                    "likes": "1",
                    "time": "15/04/2019-10:38:36",
                    "content": "I propose an alternative Instead of having an opcode that return the latest chainId, we should have an opcode that given a chainId as input return true if the chainId is part of the history of chainIds of that chain, false otherwise. This is compatible with an hashing system like @fulldecent propose and it ensures offchain messages signed in the past still work in the future across future forks. When there is a chainId updates wallet would still protect users by ensuring they sign with the latest chainId. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pedrouid",
                    "index": "40",
                    "likes": "1",
                    "time": "15/04/2019-13:27:32",
                    "content": "I think a lot of these discussions revolve around the fact that currently Dapps are not designed to take chainId into account. Mostly because they have adopted the pattern recommend by Metamask to check for the net_version instead plus they rely on Metamask to refresh the webpage whenever there is a network change. Hence there are a lot of assumptions on how Dapps are developed nowadays. Regardless we should build standards to allow these patterns to change and provide best practices about how to handle the state of a Dapp. For example, a good start is how EIP-1193 includes an event subscription for network changed. Additionally Dapps should always check with the node the current chainId, using the eth_chainId method first introduced with EIP-695. Given these progressive changes we will see the need for EIP-1344 become more apparent as we will design Dapps to track the chainId more closely. Especially for meta-transactions and layer 2 solutions. As already stated above, it\u2019s actually very important for using EIP-712 messages. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.584615384615384
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "41",
                    "likes": "0",
                    "time": "15/04/2019-13:37:44",
                    "content": "This is an interesting proposal, thank you.     wighawag:  \u2026ensures offchain messages signed in the past still work in the future across future forks.   So, I\u2019m not sure about this as a requirement, but let\u2019s explore. Assume a truly contentious fork occurs, and chainId is eventually resolved such that the fork of lesser community size is socially coerced to adopt a different value (if they refuse, this proposal does not add value). Also assume that a subset of applications that rely on the value of chainId either prefer the minority chain, or wish to continue supporting both chains in the fork. Therefore, messages signed on the majority chain only require the domain separator for the old chainId, which has the hash 0x1234. The minority chain must accept the old hash 0x1234, or the domain separator includes the new value for chainId, which has the hash 0xABCD. On the minority chain, both should be accepted, although to be strictly accurate we should ensure that only those messages signed after the fork date use the domain separator hash 0xABCD or else we can replay a user\u2019s signed messages from after the change on the majority fork. So, we need to delegate to an oracle to ensure that we have proper ordering of time for these signed messages, or we risk the above happening (another opcode would be too complex to specify).  I think all in all, this is too improbable a scenario to try and design some explicit mechanism to handle. I think the added friction of this scenario occuring would ensure that the minority chain has little support from the builders of these applications, because users will have to jump through some hoops to get their old signed messages processed in the case of a contentious split like that described above. The only alternative I can think of where this is not true is the one where the Ethereum Foundation, who has registered the trademark, is the supporter of the minority chain, meaning they forced a split that community does not find to be legitimate. However, the trademark has nothing to do with the value of chainId and I would think the majority fork community would not prefer to modify their value if a hostile fork occurs, and instead try to socially coerce the minority chain (in this scenario, run by the EF and very few other parties) to change theirs because the community does not recognize the minority chain as legitimate.  This is way down in the weeds, I hope you\u2019ll agree. 99% of the use case for this opcode is for replay protection of testnet transactions. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.939650818530129
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "42",
                    "likes": "0",
                    "time": "15/04/2019-14:05:29",
                    "content": "This is not so complex situation that you seem to make it (unless I misunderstood something  ) The idea was that on every fork a new chainId is generated (hence me pointing to @fulldecent proposal)  so if part of the chain community disagree with the changes being made as part of a fork, they simply need to create their own fork to keep the old behaviour except for a new chainId. After that, all off-chain message signed before the fork will still work in both forked chain. A desirable property in my opinion since it allow users to choose which fork they use without having their current use affected. But note that updated wallet will make sure new message are not signed with old chainId since these message could be replayed. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.704545454545454
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "43",
                    "likes": "0",
                    "time": "15/04/2019-14:16:08",
                    "content": "    wighawag:  This is not so complex situation that you seem to make it   Sorry, I edited my response to say \u201cimprobable\u201d versus \u201ccomplex\u201d. I believe this to be a fairly unlikely event, but certainly possible.     wighawag:  all off-chain message signed before the fork will still work in both forked chain   It is possible for replays to occur after the forking event on the updated chain since both chainIds are valid there. You need a time oracle to prevent this. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 3.7
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "44",
                    "likes": "0",
                    "time": "15/04/2019-14:46:10",
                    "content": " Sorry, I edited my response to say \u201cimprobable\u201d versus \u201ccomplex\u201d. I believe this to be a fairly unlikely event, but certainly possible.  I am actually not sure what you were trying to say with your scenario. From what I understood it is solved if both fork get a new chainId.  It is possible for replays to occur after the forking event on the updated chain since both  chainId s are valid there. You need a time oracle to prevent this.  I don\u2019t think we need time oracle. We simply assume that every message that was signed with an old chainId are considered valid for both chain. In other words such message should be replayable on all chain that have that chainId in its chainId history. That is how we define it. This is similar how old transactions are included in both chain except that for offchain messages, it is the responsibilities of the wallet to use the latest chainId And wallet supporting the \u201cchain that forked in the first place\u201d will be aware in advance of the fork and could deal with the update itself. Similarly wallet supporting the \u201cchain who forked simply to get a new chainId\u201d, can do the same. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.142316017316018
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "45",
                    "likes": "0",
                    "time": "15/04/2019-15:14:32",
                    "content": "Regarding gas. The gas savings of implementing CHAINID opcode is zero. Currently, chain ID be gotten for ~800 gas (G_sload) from a naive oracle implementation, or it can be hardcoded in a contract for 3 gas (G_verylow). This new approach would reduce that to 2 gas (G_base). The gas savings calculation for adding an opcode is:  savings = \u0394gas \u00d7 number_of_uses  Here, the calculation is:  0 = 798 \u00d7 0  Compare to EIP-145. Their equation is approximately:  a very lot = some \u00d7 a lot  In summary, from the perspective of gas, CHAINID opcode is a premature optimization. The argument in favor of CHAINID opcode on the basis of gas savings would be much stronger if people were added to this discussion who are currently using the ~800 gas oracle approach or the 3 gas hardcoded approach and see other merits of this addition. Regarding safety. It is not our job to babysit developers. By explaining the potential problems with CHAINID opcode I illustrated that the use cases are not yet well known enough to say if it provides any value whatsoever. Regarding trusted third party. It is simple to create an oracle that works on all existing networks that returns the correct chain ID for ~800 gas. After that is done, no further trust is required. If additional networks are created they are welcome to also implement the oracle. This is implementable TODAY. We can open a separate thread if anybody is interested in this. If nobody is interested in this then clearly CHAINID opcode is not needed. Regarding \u201cwhy not?\u201d There are many things which can be implemented. For example, an opcode which concatenates strings or rotates the top three stack items would be very useful. The threshold for adding new features should not be \u201cthis proposal doesn\u2019t make it worse than what it already is\u201d. The threshold should be \u201cthis feature is badly needed, workarounds are already in widespread use\u201d. Regarding what if the oracle is set up incorrectly. Then it would work incorrectly. Regarding an alternative to find chain ID histories.     wighawag:  an opcode that given a chainId as input return true if the chainId is part of the history of chainIds of that chain, false otherwise   Thank you for the proposal. I believe the best solution is to have two new opcodes: GENESIS returns the hash of the genesis block and CONSENSUSCLIENT returns the hash of the consensus client used to validate the last block. This approach with a simple trustless tool allows finding the lineage of any block and maintains usefulness on both sides of a contentious or non-contentious fork. Regarding building for the future.     pedrouid:  we should build standards to allow these patterns to change   ^ Yes, we should build standards based on the future and a good understanding of the use cases. Regarding Ethereum Foundation.     fubuloubu:  trademark has nothing to do with the value of chainId   I disagree, in the event of a contentious fork, both networks would call themselves \u201cEthereum\u201d. If the Ethereum Foundation supported version is the less used fork then they may assert trademark rights against people using the other network. It is undocumented whether they would do this. A request to document this is here https://github.com/ethereum/ethereum-org/issues/841 This is a fundamental issue preventing enterprises from using Ethereum mainnet. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.5047682709447425
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "46",
                    "likes": "0",
                    "time": "15/04/2019-15:23:58",
                    "content": "    fulldecent:  may assert trademark rights against people using the other network   Does the trademark include chainId? No. Can you trademark a number? I\u2019m pretty sure the answer is no, but lawyers are creative. I don\u2019t think this line of argument holds any value to this discussion. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.40625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "47",
                    "likes": "0",
                    "time": "15/04/2019-15:34:13",
                    "content": "    fulldecent:  The gas savings calculation for adding an opcode is:  savings = \u0394gas \u00d7 number_of_uses  Here, the calculation is:  0 = 798 \u00d7 0    There are currently 3 production Plasma implementations, with more coming. There are 2 production state/payment channel implementations, with more coming. All of these implementations are exploring upgrades to incorporate EIP-712 when client libraries add support, so while your calculation is currently correct, it will not be for very long. The only safe way to implement this in contract code is through a state variable, which reduces the cost estimate to 198 from your oracle solution (which I do not believe to be safe). Since L2 will see increasing prominence as more solutions come online, I believe this equation is therefore:  198 x a very lot = a very, very lot  So, I contend you are drastically underestimating the potential impact, but that\u2019s fine we can use a state variable to store this value in the mean time while we consider the potential defects in this approach. I do not believe an oracle to be a sound solution here. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.062239583333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "48",
                    "likes": "0",
                    "time": "15/04/2019-15:35:41",
                    "content": "I am not sure, but it feels that the original purpose of the EIP is left out in a lot of these discussion. We have EIP-155 to protect regular transactions agains replay attacks. And the (simplified) purpose of this EIP is to enable something similar for signatures. It would probably also be possible to change \u201cecrecover\u201d to somehow handle this, but that would be way more complex. Concerning the validity of a signature after a hardfork: my expectation would be that my signature is only valid on 1 of the chains. Concerning the change of a chainID after a hardfork: while it is true that there is no process, the case of ETC shows that a community will choose a new chain id to separate themselves from the other chains. Why did ETC choose a different chain id? I am pretty sure, not just because the ETH community said so. For me the implementation via an opcode is the simplest way, but having it as a precompile would also be a big improvement (over having nothing). Any oracle deployed by a third party needs somebody who updates it, therefore I don\u2019t think this is a viable solution. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.422459893048128
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "49",
                    "likes": "1",
                    "time": "15/04/2019-15:42:50",
                    "content": "    fulldecent:  The use cases are not yet well known enough to say if it provides any value whatsoever   I think this is your principle argument. There are lots of examples of how this will be used in practice, and shortly, because EIP-712 supports these use cases being safe. If you have an issue with using chainId as a domain separator, I think you should have brought it up during the standardization process of EIP-712. This proposal is very simple. It does not have to be used. It enables clear support for an existing use case that is seeing more support recently, it reduces human error, and it saves a small but not insignificant amount of gas. It aligns directly with the protocol, instead of leveraging trusted third party solutions like oracles. Yes, in some ways I am trying to build in support for use cases that are not widely demonstrated yet, but many see the utility in having this available, and I think it would be better to have this available than to design for potential scenarios that have only occurred 1 time in the past 5 years of the project, and also have a few potential mitigations. How we set chainId could be changed in a future discussion, leveraging some hash-based mechanism for modifying it, but that is out of scope of this proposal, which aligns L2 use cases with the protocol domain separator that clients will directly use to sign L2 messages. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.532608695652174
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "50",
                    "likes": "0",
                    "time": "15/04/2019-16:29:52",
                    "content": "    wighawag:  Instead of having an opcode that return the latest chainId, we should have an opcode that given a chainId as input return true if the chainId is part of the history of chainIds of that chain, false otherwise.   I think actually there may be a good strategy to this that we can incorporate as a mitigation if those building with this opcode choose to protect against. They would cache the value of chainId in contract storage and compare every transaction against it (200 gas), and update the value if necessary, also logging the time. This would protect against an upgrade of the value this opcode provides, without relying on a oracle or pre-compile contract. Newer contracts wouldn\u2019t cache the older values if they\u2019re deployed post-fork, protecting later deployments from replay attacks against earlier fork values that your proposal may expose them to. I do think your concern is legitimate in that we should ensure a trustless and seamless upgrade for this value in the case of contentious hard fork, but I don\u2019t believe an oracle provides this, and your proposal leaves a bit of hole after the value upgrade occurs in that presently signed transactions can be replaced after the fork (without a more complicated, time-based mechanism to ensure transaction ordering prior to the fork) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/schemar",
                    "index": "51",
                    "likes": "3",
                    "time": "15/04/2019-16:38:50",
                    "content": "I just want to chime in and say that:  we use EIP-712 to sign meta transactions from our mobile SDK we use side chains (potentially many) and want to prevent replay attacks  It seems to me that the original proposal would be very beneficial. At the same time I don\u2019t see any downside. I also don\u2019t see a viable alternative proposed so far. Maybe @benjaminbollen or @pro want to add something as they are more involved with the meta transactions than I am. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving entirely positive feedback on proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal"
                    ],
                    "Sentiment": 6.395833333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "52",
                    "likes": "1",
                    "time": "15/04/2019-17:26:47",
                    "content": " your proposal leaves a bit of hole after the value upgrade occurs in that presently signed transactions can be replaced after the fork  What do you mean by \u201creplaced\u201d ? If you mean replayed, that is for me completely fine. I consider a message signed in the past belonging to the pre-fork era. It should thus be valid in all future fork. Like a transaction included in a chain is present in all future fork. This is actually a very important feature. Imagine you play a state channel based game and you hold your opponent losing move\u2019s message. If this message get invalid because of a chainId update, you would lose your opportunity to grab the price. This is not what we want. We actually want such message to be redeemable in all forks. Think of these set of messages as part of the state of pre-fork era. I might not understand a crucial component of your concerns though. Any way to give a concrete example? As for newly created message, as mentioned this will be the responsibility of wallet to ensure such messages use latest chainId (to avoid replayability of the message in other forks) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.089730639730639
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "53",
                    "likes": "0",
                    "time": "15/04/2019-17:36:52",
                    "content": "Ah yes, I think I see the disconnect. So, imagine a split has already occurred, and the minority chain accepts both the old and new chainId. If time is not taken into account (and specifically the time of the fork/chainId upgrade) then it would be possible to replay messages signed for the majority chain after the fork date on the minority chain. You would need some mechanism for ensuring the time the message was signed was prior to the fork date, whether through timestamps or an ordering mechanism (such as Plasma transactions referencing the prior block) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.196969696969696
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "54",
                    "likes": "0",
                    "time": "15/04/2019-18:24:13",
                    "content": "This assumes the other chain (non-minority chain) did not fork with a different chainID. The solution as mentioned above is for that chain to fork with a new chainId. So both have different latest chainId preventing replays. It is not like contentious fork happen without any notice. In any case the non-forked chain would benefit in forking since without it all its newly signed message would be replayable on the forked chain. As such this situation should not be a concern as  chain can always fork to a new chainId to avoid the problem. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.4356060606060606
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "55",
                    "likes": "0",
                    "time": "15/04/2019-18:41:30",
                    "content": "    wighawag:  This assumes the other chain (non-minority chain) did not fork with a different chainID.   It would be better in that scenario, but I would claim this is unlikely to occur unless some mechanism is enforced such as what @fulldecent is describing with hash-based ID. But what the number is set to is strictly outside this proposal. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.895833333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "56",
                    "likes": "0",
                    "time": "15/04/2019-20:45:09",
                    "content": "To me that\u2019s the most likely scenario. Fork that can be contentious do not happen by surprise. And yes the idea as I mentioned earlier was to use @fulldecent proposal but it work without it being hash based. The only thing necessary is to update the chainId on every upgrades so that it does not conflict with a previous or existing chainId. Actually we can make it a process so that a new chainId is attributed to each side of the fork at every proposed changes. At every upgrade, client software implement 2 paths (activated on command line for example), one with the changes proposed and one without any changes (except for the chainId) and each with a different updated chainId. Then if the fork is contentious part of the community will run the chain with no change (except for the new chainId), the other part will run the chain with the changes (with yet another chainId) The opcode I propose guarantee that in such situation, contracts can continue using it without affecting their user\u2019s previous messages ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.120920745920746
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "57",
                    "likes": "0",
                    "time": "15/04/2019-22:00:19",
                    "content": "    wighawag:  Actually we can make it a process so that a new chainId is attributed to each side of the fork at every proposed changes   I definitely consider any such discussion of how to manage chainId out of scope for this proposal. I think that the ability to ensure safety when a change occurs is an important point, and we have a few proposals above. It really doesn\u2019t matter what the number is that is chosen, it either is or is not what the previous value was.  Options:  On-chain oracle:   Pros: no modifications required Cons: requires building a strong oracle, increases complexity and risk of central failure   History check opcode:   Pros: simpler, cheaper, low risk of failure Cons: requires a time oracle or user-side handling to ensure safety   Chain ID opcode:   Pros: simplest, cheapest, low risk of failure Cons: requires user-side handling to ensure old chainId is accepted   This is what I see as the pros and cons of the proposals so far. 2 and 3 are very similar, except 2 is fail-safe (all old chainId transactions are valid without user-side validation, no matter when they were signed) and 3 is fail secure (old transactions are not accepted unless user-side caching is implemented). I really don\u2019t think 1 is viable as it creates a central point of failure that way overcomplicates this proposal, although it can be experimented with today. The best oracle is the protocol, and the protocol provides this value, so it\u2019s something clients can come to consensus on without referencing external data, which in my opinion is the only time an oracle should be used. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.178683385579937
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "58",
                    "likes": "1",
                    "time": "16/04/2019-08:02:01",
                    "content": "On-chain oracle are a complex thing. I\u2019m yet to see any truly decentralized, trustless solution. Not even sure that is possible. In any case, I don\u2019t want to see projects being built right now depend on something not completely trustless to upgrade their signature policy. That is a huge deal and could cause massive denial of service. Having the chainid as an opcode is both simple and secure, much more than any existing oracle solution. Also there is an egg/chicken issue underlying here. To build a completely decentralized oracle we most probably need signed contribution to be verified onchain. These signatures want to be protected like any other \u2026 and they might need to be layer 2 for scalability purpose \u2026 so they most likely will rely on the onchain knowledge of the opcode. I am currently building an app that uses ERC721. The domain separator is computed by the constructor (chainId in the arguments) and never updated. I don\u2019t want to give anyone the power to change it, as it would have manor impact on the security of the platform. With this kind of opcode, I could put a public function that anyone could call without parameter and that would update the domain separator the use the current chainID. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.87124060150376
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "59",
                    "likes": "0",
                    "time": "16/04/2019-11:08:16",
                    "content": " I definitely consider any such discussion of  how  to manage  chainId  out of scope for this proposal. I think that the ability to ensure safety when a change occurs is an important point, and we have a few proposals above. It really doesn\u2019t matter what the number is that is chosen, it either is or is not what the previous value was.  I did not meant to have this as part of the proposal per se (as we will never be able guarantee that a chain will not simply reuse existing chainIds for whatever reason). I was simply pointing out that by using this process we make sure that 2 forks will always have different latest chainId which remove re-playability between them. No need for oracles. Plus even if such process is not used, the part of the community that disagree with the changes can always fork with a new chainId themselves. We agree that 1) is not an option as for 2)   Cons: requires a time oracle or user-side handling to ensure safety   I disagree with that statement. As mentioned we do not need an oracle as chain can always fork on a contentious fork. And as mentioned above, a process could make that automatic. As for \u201cuser-side\u201d handling, there is no extra work to be done by the smart contract when using option 2. It simply use that opcode passing the chainId used for signing the message as input and check the return value (true or false). This does not need any extra handling, contrary to option 3 where you rightly mention that it:   Cons: requires user-side handling to ensure old chainId is accepted   This is basically emulating the opcode of option 2) why not then simply use option 2) ? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.483939393939394
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "60",
                    "likes": "0",
                    "time": "16/04/2019-13:18:58",
                    "content": "    Amxx:  With this kind of opcode, I could put a public function that anyone could call without parameter and that would update the domain separator the use the current chainID.   Basically, option number 3 I listed above, where you implement a caching function in your code that trustlessly \u201cupgrades\u201d the value if and when it changes? (Also keeping tracking of the time it occuring for application purposes) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "61",
                    "likes": "0",
                    "time": "16/04/2019-13:27:32",
                    "content": "    wighawag:  I was simply pointing out that by using this process we make sure that 2 forks will always have different latest chainId which remove re-playability between them.   I think we largely agree, but it\u2019s important to establish a baseline here. Both chains caught up in a fork don\u2019t have to upgrade their value of chainId (which is one of @fulldecent\u2019s original points). If and when an upgrade occurs, one side could choose to upgrade while the other does not, or both could choose to upgrade. The later I would consider extremely unlikely, unless we propose (in a different EIP) a process for hard fork network upgrades of chainId (which I think is a good idea, but the details will be difficult to get right). We all agree that this process is out of scope here. I think we all agree that in this proposal, we simply need to design an adequate mitigation for these scenarios to improve handling of these situations. So, to put it simply, we need to design for the following situations:   chainId changes on one side of the fork, but not the other  chainId changes on both sides of the fork  The scenario where neither changes is pretty much unresolvable (no replay protection), but I would contend that social friction will enforce either 1. or 2. happening eventually (after a fork occurs). I hope we agree on this. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.489130434782608
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "62",
                    "likes": "0",
                    "time": "16/04/2019-13:46:50",
                    "content": "    wighawag:  I disagree with that statement. As mentioned we do not need an oracle as chain can always fork on a contentious fork. And as mentioned above, a process could make that automatic. As for \u201cuser-side\u201d handling, there is no extra work to be done by the smart contract when using option 2. It simply use that opcode passing the chainId used for signing the message as input and check the return value (true or false). This does not need any extra handling, contrary to option 3 where you rightly mention that it.   So, our two proposals are largely aligned, but make a different trade-off which I\u2019ll demonstrate. I of course prefer my side of the trade off, as it is easier and more secure to ensure the scenarios I described previous are adequately enough.  So, in your scenario, there is an opcode where given a chainId it returns True if that value is in the history, else it returns False. These values have no context of timing. In the scenario where both forks update their value of chainId post-fork, you are correct that there is no necessary mitigation, however in the scenario where one side of the fork does not update this presents a problem: a message signed on the fork where chainId did not upgrade after the fork occurred can be replaced on the chain where chainId did upgrade. In order to resolve this, you need to involve time into this scenario to delineate the two. You are correct that a time oracle is probably not useful for resolving this, but user-side handling has to be involved to ensure replay protection in this scenario, so you are incorrect on that point. Additionally, you have to have user-side handling anyways because how else will you get the value of chainId in the first place! (It would have to come from the signed message itself). Lastly, this increases complexity on the client implementation because each contentious fork would have to maintain yet another value in the lookup table (so it knows to return True or False). If we upgrade the value on every fork we do, then that\u2019s even more on the client side!  Conversely, in my proposal we do not need user-side handling to obtain the value of chainId because the opcode provides the current value. We would need user-side handling for determining when an update occurred (which could be done trustlessly, and cached) and it\u2019s up to the user (as it is in both our suggested mitigations) to get this right. What would be best is to retain this opcode (that returns current chainId) and propose a new suggestion that takes a value of chainId and returns the timestamp of when the fork occurred where that value was introduces. This resolves all discussions of user-side handling of time, and makes it much easier for developers to handle these upgrades, especially in the proposal where we move to every fork changing this value. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.617866161616162
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "63",
                    "likes": "0",
                    "time": "16/04/2019-15:15:38",
                    "content": " The scenario where neither changes is pretty much unresolvable (no replay protection), but I would contend that social friction will enforce either 1. or 2. happening eventually (after a fork occurs).  It is exactly for the same reason I believe we should only cater for case 2) since case 1) can be solved similarly to what you describe. This is why the opcode I propose is sufficient without requiring any \u201cuser-handling\u201d  Lastly, this increases complexity on the client implementation because each contentious fork would have to maintain yet another value in the lookup table (so it knows to return True or False). If we upgrade the value on every fork we do, then that\u2019s even more on the client side!  This is true. I never argued for the contrary but the idea has its purpose and should not be a problem. In any case as you mentioned you would need a similar strategy for your version of the opcode since in order to accept message signed with old chainIds, you would need a global caching smart contract for case like counterfactual state channel situation where the contract do not exist yet for example.  Conversely, in my proposal we do not need user-side handling to obtain the value of chainId because the opcode provides the current value.  I do not consider that user-handling. This is just passing an extra parameter for message signature verification. But if that is what you are concern about, I ll let you call that user-handling. But again with your opcode, this chainId will also need to be supplied anyway if you want to support old message, which was the whole point of my proposal.  What would be best is to retain this opcode (that returns current chainId) and propose a new suggestion that takes a value of chainId and returns the timestamp of when the fork occurred where that value was introduces. This resolves all discussions of user-side handling of time, and makes it much easier for developers to handle these upgrades, especially in the proposal where we move to every fork changing this value.  You seem to  overcomplicate things here. Assuming all fork have an updated chainId (which yourself describe as likely for the case when none of the fork change Ids) none of this is necessary To resume how I see the situation is that since forks can always update chainInds, we should consider the case where both fork update their latest chainId to different values (an outcome that is beneficial for both side of the fork) In that scenario, the opcode I propose is safe and sufficient. Now if you think we need to tackle situation where a community refuse to update its chainId at the expense of its users, then I think such community can decide to come up with a more complicated scheme to solve that. I am personally think this is unnecessary. Anybody else interested to comment ? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.619303150553151
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "64",
                    "likes": "1",
                    "time": "16/04/2019-19:35:13",
                    "content": "    wighawag:  It is exactly for the same reason I believe we should only cater for case 2) since case 1) can be solved similarly to what you describe. This is why the opcode I propose is sufficient without requiring any \u201cuser-handling\u201d   So the issue here, and this is why it needs to handle both scenarios, is there is currently no plan for it to work like this, so we can\u2019t rely on \u201cthe community\u201d adopting your suggestion without another separate proposal.     wighawag:  In any case as you mentioned you would need a similar strategy for your version of the opcode since in order to accept message signed with old chainIds, you would need a global caching smart contract for case like counterfactual state channel situation where the contract do not exist yet for example.   The difference is that my proposal would be more flexible (you don\u2019t have to do it unless you want to) whereas yours you would have to design in some mechanism. Counterfactual instantiation is an interesting counterpoint, but I could imagine some scheme that would only care about the current value provided by some final message signed at closing time, in which case my proposal would work (without modifications!) Another point is that you would have to pass in the chainId in your proposal separately to generate the domain separator. I think this may be too far down in the realm of implementation details to discuss further, it\u2019s simply an engineering tradeoff. I think we\u2019re largely at an impasse with two equally viable methods to implement this functionality.  Here is what I suggest:  We should put this EIP into Last Call as currently written as it\u2019s well-specified and can be used as a technical standard as is. You should create a separate EIP from your proposal as I believe it has value, and I also believe both could play well together! We probably need a third proposal to specify the process of setting chainId that is completely separate from this discussion. It is likely to be political in nature (as the length of this conversation surely attests to!), so siloing the political discussion away from the conversation for this opcode (and your proposal) would help bring this to a close. There is a significant opportunity to improve resilience of any signing scheme that uses chainId, but that is out of scope for this proposal (and yours as well)   I hope everyone finds this to be reasonable, as I believe further discussions along this point may prevent this conversation from ever being brought to a close, which means nothing gets done and that\u2019s worse for everyone. The conversation about whether this proposal (or another) is included in Istanbul is also a separate conversation I believe needs to take place on an alternative channel. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.385737628384687
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ajsutton",
                    "index": "65",
                    "likes": "0",
                    "time": "17/04/2019-05:23:14",
                    "content": "The EIP has been moved to last call but the test cases are still TBD. We really should fix that before accepting the EIP.  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "66",
                    "likes": "0",
                    "time": "17/04/2019-09:45:21",
                    "content": "    fubuloubu:  So the issue here, and this is why it needs to handle both scenarios, is there is currently no plan for it to work like this, so we can\u2019t rely on \u201cthe community\u201d adopting your suggestion without another separate proposal.   While a process would ensure the issue never happen (assuming the process is followed), in practise  there is no need for any established process. The fact that a chain can always update its chainId is sufficient. As I said if the community of that side of the fork do not want to simply update their chainId, it is up to them to come up with a better method.  you don\u2019t  have  to do it unless you want to  This is not true. Every L2 message that want to ensure its message can\u2019t be replayed on other chain that exist at the point of signing the message would need to use chainId as part of the message. By doing so, the verifying contract would need a way to check that this chainId is or was valid in the past. Else such message would not work on a fork that change its chainId. Imagine if many important contracts naively use the opcode as proposed and a contentious fork happen. How do we resolve the situation ? We either have all L2 messages replayable on both fork which defeat the purpose of what we tried to achieve here. Or we have one fork that accept defeat and break the validity of previously signed message for these application at the expense of its users. This could be disastrous. So if the opcode as described is chosen, we will need to put in place a contract that can be trustlessly updated to cache the past chainId. And every contract that want to verify the chainId would need to look it up. At which point, it is logical to conclude that the opcode should deal with that itself. By using the opcode I propose we ensure at the lowest level possible that L2 messages validity will be preserved across forks, while allowing the chainId to be updated to protect from replayability.  Another point is that you would have to pass in the  chainId  in your proposal separately to generate the domain separator.  EIP712 is not final and should probably be updated to allow for chainId to be added separately from the domainSeparator. Let\u2019s not constrain the protocol at this stage.   We should put this EIP into Last Call as currently written as it\u2019s well-specified and can be used as a technical standard as is.   I don\u2019t think it is wise to do so before we get more feedback on our discussion from other parties. The idea is not to add as many opcodes as possible to cover all possible wishes just because they are well specified. Let\u2019s reach consensus on the best method for L2 messages non-replayability and validity preservation. Also as mentioned above, I believe the EIP purpose is not fulfilled in the best way with the current opcode. Until we get consensus on how to resolve this by the community, the EIP should go back to draft status. My reasoning in a nutshell :  chains can always upgrade to update their chainId This ensure non-replayability chains will have their chainId change over time L2 messages signed in the past need to be valid in the future (in respect to chainId) simply providing the latest chainId (as proposed) can\u2019t offer this guarantee without an extra caching contract adding such caching contract emulate the opcode I propose => let\u2019s use that opcode instead.  Note: I really don\u2019t think it is necessary but for extra flexibility we could return the blocknumber at which the chainId was introduced instead of a boolean. This would allow to get the latest chainId via a trustlessly updatable contract. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.513211382113821
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "67",
                    "likes": "0",
                    "time": "17/04/2019-13:53:34",
                    "content": "So test cases and/or implementation is not a strict requirement for an EIP, but it helps aid the discussion and reduces work on client implementors later on down the line. Things get out of date so fast in feature branches, so it\u2019s not advisable to make it a strict requirement. I was planning on implementing the test cases when I got a chance. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.074074074074074
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "68",
                    "likes": "2",
                    "time": "17/04/2019-14:17:05",
                    "content": "    wighawag:  As I said if the community of that side of the fork do not want to simply update their chainId, it is up to them to come up with a better method.   So, as we discussed above, this isn\u2019t really a guarantee we can rely on, but we are largely talking past each other at this point. Can we agree that handling both scenarios (one side updates and both sides update) is important?     wighawag:  we will need to put in place a contract that can be trustlessly updated to cache the past chainId   This contract could be the user application itself, the caching is very easy to implement. It allows the developer the flexibility to implement their own scheme for reacting to upgraded chainId, which may be application-specific. It may not even matter at all! These type of signed messages are still largely being explored, we only know that clients will need chainId. A good example is meta-transactions. It would probably not be great to allow replays of old chainId signed messages since that\u2019s not how it\u2019s intended to be used. Flexibility is key.     wighawag:  By using the opcode I propose we ensure at the lowest level possible that L2 messages validity will be preserved across forks, while allowing the chainId to be updated to protect from replayability.   Neither one of our proposals fulfills all requirements here. I think both will work best together. For maximum flexibility, having both allows application developers to build what they see as necessary. If they get it wrong, that\u2019s not our fault, we just need to give them the tools to do what they need to do. If your proposal doesn\u2019t have a way to determine what the current value is, there are corner cases that could be unsafe. If this proposal doesn\u2019t have a way to query past values of chainId, it won\u2019t be able to accommodate older signed messages, which is also bad. Both play well together!     wighawag:  The idea is not to add as many opcodes as possible to cover all possible wishes just because they are well specified.   An EIP being Accepted doesn\u2019t mean it will be implemented. It only means it\u2019s well-specified and technically sound. If we spend more time arguing past each other, nothing gets done and we\u2019ve largely wasted our breathe. You have a proposal that has merit, you should create a separate proposal that we can move this discussion to. EIPs aren\u2019t sacred cows, what matters is when they get implemented. Maybe the implementers like your proposal better. Maybe they like this one better. Maybe they like both in parallel, as it provides the most succinct flexibility. Let\u2019s not spend more time modifying this proposal, second-guessing the client implementers and the rest of the community.     wighawag:  Note: I really don\u2019t think it is necessary but for extra flexibility we could return the blocknumber at which the chainId was introduced instead of a boolean. This would allow to get the latest chainId via a trustlessly updatable contract.   I think this would be required to ensure the most flexibility and security in the design, as it creates a strict ordering that can be relied on, instead of an external oracle or extra timestamp in the message. This would protect against some corner cases where a message was incorrectly signed after an update occurred, or a replay from a chain that did not choose to update their value. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.788653273809524
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "69",
                    "likes": "0",
                    "time": "17/04/2019-20:25:36",
                    "content": " An EIP being Accepted doesn\u2019t mean it will be implemented. It  only  means it\u2019s well-specified and technically sound. If we spend more time arguing past each other, nothing gets done and we\u2019ve largely wasted our breathe. You have a proposal that has merit, you should create a separate proposal that we can move this discussion to. EIPs aren\u2019t sacred cows, what matters is when they get implemented. Maybe the implementers like your proposal better. Maybe they like this one better. Maybe they like both in parallel, as it provides the most succinct flexibility. Let\u2019s not spend more time modifying this proposal, second-guessing the client implementers and the rest of the community.  You are right, sorry for having in some way polluted the discussion here. I was just trying to propose something that looked obvious to me and felt obliged to reply to what seemed to me incorrect statements. This has resulted in quite a back and forth. It was not totally fruitless though so thank you for engaging with me. I ll now start thinking about writing an EIP for the opcode I propose. But before I can\u2019t stop myself to make few clarifications  :  Can we agree that handling both scenarios (one side updates and both sides update) is important?  I agree it is important in itself but my point is that we do not need to worry about it since the responsibility lies elsewhere and it is in the interest of each side to make sure 2 chain will always have different latest chainId. We can thus assume it is always the case.  A good example is meta-transactions. It would probably not be great to allow replays of old  chainId  signed messages since that\u2019s not how it\u2019s intended to be used.  I would actually argue of the contrary, meta transaction user would obviously expect their transaction to be valid at the point of signing them. They would be disappointed to learn that because a fork happen in between, their tx got rejected . I actually have yet to see a case where it is useful for a contract to get access to the latest chainId (knowing that it is a changing value) except to verify that it is indeed a valid chainId. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.825487012987013
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ajsutton",
                    "index": "70",
                    "likes": "0",
                    "time": "17/04/2019-21:25:16",
                    "content": "    fubuloubu:  So test cases and/or implementation is not a strict requirement for an EIP, but it helps aid the discussion and reduces work on client implementors later on down the line. Things get out of date so fast in feature branches, so it\u2019s not advisable to make it a strict requirement. I was planning on implementing the test cases when I got a chance.   The test cases listed in the EIP shouldn\u2019t be for a specific implementation. For an EIP like this I\u2019d expect they\u2019d just identify the key situations to test (e.g. chain ID 1, chain ID at max value for a uint256, what happens if the chain ID is bigger than a uint256). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.037037037037036
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "71",
                    "likes": "0",
                    "time": "17/04/2019-23:03:07",
                    "content": "    wighawag:  But before I can\u2019t stop myself to make few clarifications    Lol, me too.     wighawag:  it is in the interest of each side to make sure 2 chain will always have different latest chainId   I don\u2019t think this is obviously true, but we are also speculating on what would happen since we haven\u2019t had a contentious split since chainId was introduced. Agree to disagree?     wighawag:  They would be disappointed to learn that because a fork happen in between, their tx got rejected   So, meta transactions are interesting because they\u2019re meant to exist short term (< 1 week). As per your point above, a switch to chainId would have to be known at least a few weeks ahead of time, so largely this wouldn\u2019t conflict and could be handled very easily without the additional context of supporting older signed messages. It\u2019s also largely speculation what would happen. Agree to disagree? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.767226890756303
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "72",
                    "likes": "0",
                    "time": "17/04/2019-23:04:17",
                    "content": "Yes, in the Ethereum/tests repository. Again, a test case in this repository is not a requirement for accepting an EIP, only for implementing it in the client (as should go without saying). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "73",
                    "likes": "2",
                    "time": "19/04/2019-05:05:33",
                    "content": "    fubuloubu:  Yes, in some ways I am trying to build in support for use cases that are not widely demonstrated yet, but many see the utility in having this available, and I think it would be better to have this available than to design for potential scenarios that have only occurred 1 time in the past 5 years of the project, and also have a few potential mitigations. How we set chainId could be changed in a future discussion, leveraging some hash-based mechanism for modifying it, but that is out of scope of this proposal, which aligns L2 use cases with the protocol domain separator that clients will directly use to sign L2 messages.   So I have 5 years to convince everyone that chain IDs should change at each consensus upgrade. This timeline is fair enough in the scheme of enterprise deployments. Challenge accepted.  @wignawag \u2026 [a function that returns true if chain ID is in the history of this chain]  Yes, this can be implemented as a trustless contract if the CHAINID opcode is available.  Overall, I had been looking at this proposal as a distraction or side step from the serious change management problems that exist. Looking anew, I see that this proposal plus some trustless protocols (like above and more) allows forwards compatibility with a future where every upgrade changes the CHAINID. Now I support this proposal. For last call and also for deployment. We should encourage application developers to consider the case that the CHAINID of their network changes. If they simply hardcode a check for CHAINID in their smart contract they might be surprised when their application suddenly wakes up with a new CHAINID and all outstanding counterfactuals and commitments are unenforceable. Please include @wignawag\u2019s point (could use a function to find if a chain ID is in this chain\u2019s history) in the EIP rationale section. I hope it can be clear from the reading the EIP that most developers will want to access it using the helper tool if they are validating off-chain signatures. And if gas is an issue (for the SLOAD) then I expect this is how people will actually use the tool: contract ClaimValidator {   ...    function loadClaim(account, bytes32 signature, data claim) {     ...   }    function loadClaimHistorical(bytes32 chainId, account, bytes32 signature, data claim) {     require(ChainIdHistorian.chainDidExist(chainId));     ...   } }   ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.752792906018712
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "74",
                    "likes": "0",
                    "time": "19/04/2019-07:10:38",
                    "content": "The specification section sucks.  Adds a new opcode at 0x46, which takes 0 stack arguments. It will return the chain id of the chain where the block was mined. It should cost 2 gas ( G_base ) to execute this opcode.  My request for changes:  Add mnemonic. E.g. \u201ca new opcode CHAINID at 0x46\u201d Don\u2019t use future tense, nor \u201cshould\u201d.  It will return -> It pushes to the stack. \u201cthe block was mined\u201d??? Nothing was mined yet. How about \u201cchain id of the current block\u201d? Check wording for opcodes as NUMBER, TIMESTAMP, etc. If you have decided what is the chain id size, please include this information.  Personally, I believe anything that requires data from outside of EVM should cost at least 10x more than arithmetic. But it\u2019s probably not worth to fight for it here because it matches the cost of other similar opcodes. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.832459207459207
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "75",
                    "likes": "1",
                    "time": "19/04/2019-09:16:06",
                    "content": "    chfast:  Personally, I believe anything that requires data from outside of EVM should cost at least 10x more than arithmetic. But it\u2019s probably not worth to fight for it here because it matches the cost of other similar opcodes.   This opcode does not requier data from outside the EVM. The chainID is written in the signed transaction, so it\u2019s pretty much like msg.sender ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.1875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "76",
                    "likes": "0",
                    "time": "19/04/2019-12:54:49",
                    "content": "    fulldecent:  Please include @wignawag\u2019s point (could use a function to find if a chain ID is in this chain\u2019s history) in the EIP rationale section.   Will do. I agree that this is important to capture. It is possible to design something alongside it to capture, but an opcode would be nicer. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "77",
                    "likes": "0",
                    "time": "19/04/2019-12:58:58",
                    "content": "    chfast:  My request for changes:  Add mnemonic. E.g. \u201ca new opcode CHAINID at 0x46\u201d Don\u2019t use future tense, nor \u201cshould\u201d.  It will return -> It pushes to the stack. \u201cthe block was mined\u201d??? Nothing was mined yet. How about \u201cchain id of the current block\u201d? Check wording for opcodes as NUMBER, TIMESTAMP, etc. If you have decided what is the chain id size, please include this information.    This all sounds good. Could you submit a PR?     chfast:  Personally, I believe anything that requires data from outside of EVM should cost at least 10x more than arithmetic. But it\u2019s probably not worth to fight for it here because it matches the cost of other similar opcodes.   So, I actually implemented this in Trinity leveraging the transaction context (of which chainId is a member). I think this might be the simplest way to implement, so clearly it is not some sort of oracle to the outside world since the transaction context is a core part of EVM execution (GASPRICE, CALLER, etc. are a part of this context)      Amxx:  This opcode does not requier data from outside the EVM. The chainID is written in the signed transaction, so it\u2019s pretty much like msg.sender   Edit: should\u2019ve read this first lol ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.469507575757576
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "78",
                    "likes": "1",
                    "time": "19/04/2019-16:00:59",
                    "content": "Wording updates proposed here https://github.com/ethereum/EIPs/pull/1952 Test cases should be added ASAP. This should also specifically address situations that happen during a network ID change. Off-by-one errors will be minimized if the test case is good. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 8.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "79",
                    "likes": "0",
                    "time": "19/04/2019-17:33:55",
                    "content": "@fulldecent As suggested, added @wighawag\u2019s analysis under Rationale within EIP-1344. Did not reset Last Call as this Rationale did not modify the proposal. If you both could read and accept this additional rationale under the following PR, I would appreciate it:   github.com/ethereum/EIPs       EIP-1344: Add Rationale about chain split     by fubuloubu   on 05:32PM - 19 Apr 19 UTC   1 commits   changed 1 files   with 4 additions   and 0 deletions.       Edit: crap, I think it auto-merged because I wrote the PR, but anyways if you guys have suggestions, please let me know (or better, submit a PR against it) ",
                    "links": [
                        "https://github.com/fubuloubu",
                        "https://github.com/ethereum/EIPs/pull/1953",
                        "https://github.com/fubuloubu",
                        "https://github.com/ethereum/EIPs/pull/1953"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "80",
                    "likes": "0",
                    "time": "19/04/2019-19:04:06",
                    "content": "    fulldecent:  Test cases should be added ASAP. This should also specifically address situations that happen during a network ID change. Off-by-one errors will be minimized if the test case is good.   So, testing this opcode should be simple, but testing the upgrade path is more complex because it would probably require a monkey patch of a client to show in practice. I don\u2019t think we have a methodology for doing this in the current protocol, which is about half our problems in this thread (and also out of scope since EIP-155 is the origin). ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.488095238095239
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "81",
                    "likes": "1",
                    "time": "19/04/2019-19:35:20",
                    "content": "Testing the upgrade is most important. And should definitely be specified. Don\u2019t need an automated test. Even a manual Test Procedure Specification for a human to perform will be sufficient. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "82",
                    "likes": "1",
                    "time": "19/04/2019-19:50:09",
                    "content": "That\u2019s what I was thinking. Glad we are aligned! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 8.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shemnon",
                    "index": "83",
                    "likes": "0",
                    "time": "20/04/2019-21:07:20",
                    "content": "Because this is an opcode there will need to be some level of automated testing in the reference tests.  We don\u2019t need to automate the contract lifecycle tests and contract migration.  There are multiple layers of tests here. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "84",
                    "likes": "0",
                    "time": "21/04/2019-17:51:55",
                    "content": "Hi @fubuloubu @fulldecent I created a new EIP for my VALID_CHAINID opcode proposal with an extensive rationale of why I think it is better than the CHAINID opcode proposed here, at least for the goal of protecting users of off-chain messages. And why we should include it instead of this one. Discussion here : EIP-1959 Valid ChainID opcode ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.420454545454545
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "85",
                    "likes": "0",
                    "time": "21/04/2019-18:19:07",
                    "content": "Thank you for adding your proposal separately. I have a few concerns over the alternative approach that I will articulate in that thread separately. The discussion of the strategy of which to include for implementation into a hard fork (like Istanbul) will be handled separately, as I believe your concerns are adequately logged in this discussion as well as the current EIP text under Rationale. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.802083333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "86",
                    "likes": "1",
                    "time": "21/04/2019-23:22:56",
                    "content": "@ @fubuloubu @wighawag Thank you, I am glad to see the competing proposal. I will add again that either CHAINID or VALID_CHAINID could be implemented from the other using a trustless contract. i.e. If CHAINID opcode is available then a trustless VALID_CHAINID contract can be deployed and everybody can trust that it operates the way that VALID_CHAINID is specified (when it is specified) to work. And vice-versa, ff VALID_CHAINID opcode is available then a trustless CHAINID contract can be deployed and everybody can trust that it operates the way that CHAINID is specified to work. If there is any more interest in this point, I\u2019ll be happy to discuss on the other thread at EIP-1959 Valid ChainID opcode. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.678571428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "87",
                    "likes": "0",
                    "time": "21/04/2019-23:45:30",
                    "content": "Yeah, I think we basically understand the discussion here. I might try and implement a simplistic version of the necessary mitigation to use as a comparison again the other proposal. I think that proposal needs more discussion, so I would agree that we should move any further suggestions along those lines there unless there is a strong concern with this specific proposal that is not already captured. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.220238095238096
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "88",
                    "likes": "0",
                    "time": "24/04/2019-10:20:57",
                    "content": "Hi, I reviewed the current rationale and from the discussion we had here and on EIP-1959, I think you should update to mention the following points :  the fact that contract can naively check chainID == message\u2019s chainID makes the opcode potentially dangerous to use It already mention the need for a caching system but it would be good to indicate that alternative solution do not need it It also does not mention the minority-led hardfork situation (as described here) . In particular:  with such caching system, it is actually not possible to properly protect from replay in case of a minority-led hardfork since the caching system will not accurately save the blockNumber at which the chainID became the latest. As such during the gap, messages signed with a blockNumber present in that gap, from the majority chain will be replayable on the minority chain even though they should not Even then, it does not mention the minority-led fork situation where the messages will need to include the blockNumber representing the time it was signed so that the contract can prevent it from being used across such forks And it also does not mention that it suffice only one important application to not protect using blockNumber for the minority-led fork to be at a disadvantage as such application will suffer from replay in that fork.   I would also mention as I did in EIP1959, the potential benefit in separating chainID from the domain separator since the chainID will change (but as mentioned a domain separator caching mechanism could work too)  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.185185185185185
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "89",
                    "likes": "0",
                    "time": "24/04/2019-10:46:51",
                    "content": "While I do still think that having this opcode would be a bug step forward I think it is also pretty clear that there needs to be a separate discussion concerning what is the purpose of a chain id and how is it represented. The case that a message should be valid on different chains (= chains with different chain ids) is not only related to signed messages, but also to normal transaction and I don\u2019t think this was never really discussed. In the core dev event last week the question came up if it is possible to design the chain id in a way that you can basically check both cases. Also as mentioned before it might actually be cleaner to adjust ecrecover to be able to handle a chain id that is encoded in the v parameter (same as for a normal transaction). It would also be interesting if there are other use cases besides signed messages for this opcode (since ecrecover changes would cover this too) ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.4453125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "90",
                    "likes": "0",
                    "time": "24/04/2019-15:39:21",
                    "content": "    wighawag:   the fact that contract can naively check chainID == message\u2019s chainID makes the opcode potentially dangerous to use    For some use cases this is still perfectly safe behavior, even if it changes values e.g. meta-transactions.     wighawag:   It already mention the need for a caching system but it would be good to indicate that alternative solution do not need it    I think the pros and cons are well captured already. It\u2019s a bad practice in my opinion to mention other proposals within a proposal if there are not explicit dependencies.      wighawag:   It also does not mention the minority-led hardfork situation (as described here). In particular:  with such caching system, it is actually not possible to properly protect from replay in case of a minority-led hardfork since the caching system will not accurately save the blockNumber at which the chainID became the latest. As such during the gap, messages signed with a blockNumber present in that gap, from the majority chain will be replayable on the minority chain even though they should not Even then, it does not mention the minority-led fork situation where the messages will need to include the blockNumber representing the time it was signed so that the contract can prevent it from being used across such forks And it also does not mention that it suffice only one important application to not protect using blockNumber for the minority-led fork to be at a disadvantage as such application will suffer from replay in that fork.       A minority-led fork is a special case of the scenario where one side changes chain ID and the other side doesn\u2019t. This scenario is already mentioned. If the minority fork doesn\u2019t implement replay protection, then yes replays are possible. That should be obvious. A properly-implemented caching mechanism can be purely trustless in this scenario, as anyone can operate it (it may even be included within the application\u2019s user flow).  Also, there may be application-specific scenarios where forcing the use of fork block height to differentiate changes in chain ID would be unnecessary, and potentially even harmful. The example given in the other thread was that of Plasma\u2019s message structure (a fairly large use case for EIP-712 and this proposal). In the Plasma scenario, there are blocks being managed asynchronously, and the Operator is tasked with publishing them on a regular interval. As a part of the publishing logic in the on-chain Plasma smart contract, the domain separator used could be trustlessly updated (using a caching mechanism), and all downstream clients would verify that the EIP-712 signing mechanism used the same domain separator as what would be required to validate the message on-chain later on. This creates a lock-step upgrade ensuring messages don\u2019t fall into corner cases, which would not be possible with a strictly fork block height-based mechanism. It may not be the best case scenario to mandate a particular style of handling this requirement for all possible applications, mostly because we don\u2019t know what those will look like. I liked EIP-1959 because it gave the option to use that mechanism if it made sense for your application, and it made it easy to do so. I don\u2019t think it replaces this proposal as succinctly.      wighawag:   I would also mention as I did in EIP1959, the potential benefit in separating chainID from the domain separator since the chainID will change (but as mentioned a domain separator caching mechanism could work too)    This could indeed be mentioned (in both scenarios) but this should be rare enough (at least under the current process for changing chain ID, of which there isn\u2019t any) that it may be unnecessary to make the distinction. We are after all talking about a scenario that has happened exactly 0 times in the past, and is only projected to occur because EIP-155 was added after the DAO fork to solve a potential issue that was now possible. It may be unlikely, but another fork like that could never happen again, or it could be 5-10 years away from happening again! Even if it happened on a yearly basis (we do hard forks every 9-12 months currently), I doubt it would be considered burdensome to the application to handle it with a properly-designed caching mechanism.      rmeissner:  I think it is also pretty clear that there needs to be a separate discussion concerning what is the purpose of a chain id and how is it represented.   I definitely agree, and this fits the framework we\u2019ve been discussing that potentially a hash-based mechanism for setting chain ID might be created which updates this parameter automatically on every fork (e.g. @fulldecent\u2019s proposal).     rmeissner:  The case that a message should be valid on different chains (= chains with different chain ids) is not only related to signed messages, but also to normal transaction and I don\u2019t think this was never really discussed.   Do you mean that messages signed with older chain IDs in an off-chain signing process? As mentioned, it is application specific, and I don\u2019t think mandating a particular style is helpful as we are likely to miss something. An example of something we do need to think of is that all transactions in the unconfirmed pool are signed with a particular value of chain ID, and those messages would get dropped by the protocol if that changes. This might be desirable behavior, basically cleans out the unconfirmed pool on a regular basis if hash-based chain ID were adopted. I think further discussions of these types of things of how chain ID is set is out of scope of this proposal, and we should pick up another discussion thread for figuring this out. I\u2019m fairly confident at this point that with this proposal we can handle any scenario required out of those discussions. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.222711267605634
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "91",
                    "likes": "0",
                    "time": "24/04/2019-21:46:44",
                    "content": " For some use cases this is still perfectly safe behavior, even if it changes values e.g. meta-transactions.  The problem is not that it is safe in some behaviour, the problem is that it can be easily used wrongly. If an application use it wrongly by assuming that simply checking chainID for equality is enough and a hardfork that change the chainID happen, the application get broken. On that note contrary to what you say, meta transactions themselves would benefit from accepting past chainID. I would actually argue that is indeed unsafe to not do it as there are scenarios where the user will be unavailable to resubmit the meta tx in time. The fact that you do not see it prove that it is easy to used that opcode wrongly. When users send metatx, they assume the tx will be executed. They don\u2019t expect to have to sign it again (not just resubmitting, as a relayer could do it) later. If the meta-tx smart contract do not allow for past chainID, this assumption break easily at fork transition. A fork should ideally not bother the users. A no downtime solution should always be the goal. So if we can achieve this, we should do it. It could be argued that around the fork time, wallet could already force the use of future chainID (and relayer would then wait that time before publishing the metatx) but this assume they know what the message is destined to be use for.  A minority-led fork is a special case of the scenario where one side changes chain ID and the other side doesn\u2019t. This scenario is already mentioned.  As mentioned, that special case (which you agreed was an important concern in EIP-1959 discussion. You even pointed that as the weak point of EIP-1959 since it simply return a boolean)  can\u2019t be handled properly via the opcode proposed here (see below). As such  it should be mentioned in the EIP.   If the minority fork doesn\u2019t implement replay protection, then yes replays are possible. That should be obvious. A properly-implemented caching mechanism can be purely trustless in this scenario, as anyone can operate it (it may even be included within the application\u2019s user flow)   These 2 points show a misunderstanding of the issue. The smart Contract in question would have replay protection using the caching solution mentioned in the rationale. It thus receive the chainId from the message (and let say it also receive the block number representing the time at which the message was signed) and check it against the cache. Now let say a minority-led hardfork happen at block X so the minority fork has a new chainID from that time onward while the majority chain keep the same chainID (since it did not fork) Now let say a user of both majority and minority chain signs a message for that smart contract at block X+1 and want it to be applied to the majority chain only (the purpose of replay protection). Unfortunately the user has no choice but to use the majority chainID which turn out to also be a past chainID of the minority chain (It would already be cached there). As you can see, a replay is possible. Now the way to prevent the problem is to use the blockNumber provided as part of the message to check if the message block number happen after the fork (if it does then it should not be replayable). Unfortunately since the cache has a delay inherent due to being implemented as a normal smart contract the replay will still be possible for message signed at blockNumber smaller than the blockNumber at which the cache was updated with the latest chain ID. EIP1965 does not have this issue and allow thus minority-led hard fork to happen without being exposed to replays, This preserves an important decentralisation component of blockchain where we should give equal opportunities to every communities that want to fork away. Of course, in the case of EIP-1344 the replay window is small but that could be critical in some situation.  Also, there may be application-specific scenarios where forcing the use of fork block height to differentiate changes in chain ID would be unnecessary, and potentially even harmful. The example given in the other thread was that of Plasma\u2019s message structure (a fairly large use case for EIP-712 and this proposal).  You simply showed there that plasma did not need to use the precise block number at which the chainID changed. As for forcing the use of a block number, this is not true. You can always provide your own. In other words both can be used, the application specific block number and the block number assigned by EIP-712. The point is that in order to guarantee replay protection for those application that require the strict version of it, EIP-712 will need to be modified so wallet ensure correct values to protect their users.  messages don\u2019t fall into corner cases, which would not be possible with a strictly fork block height-based mechanism.  As mentioned above, nothing prevent you from using a different mechanism for blockNumber. EIP1965 will still allow you to verify that a chainID was valid at a specific block no matter how you came up with that number. To conclude, while I agree that not all points mentioned need to be added/ expanded in the rationale.  the point about minority-led hard fork need to be addressed, (like EIP-1959 does for example) I would also still strongly advise you to clarify better why a naive chainID equality check is dangerous. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0394385026737964
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "92",
                    "likes": "0",
                    "time": "24/04/2019-21:59:22",
                    "content": "    rmeissner:  The case that a message should be valid on different chains (= chains with different chain ids) is not only related to signed messages, but also to normal transaction and I don\u2019t think this was never really discussed.   That\u2019s a good point. Contrary to @fubuloubu 's opinion, I think this is an important feature to have. Using a similar system than EIP1965 would allow transaction at fork boundary to be accepted as normal without downtime, an obviously desirable property form the user point of view. The users might also want to be sure their transactions do not get replayed on a particular side of the fork, even before the fork happen. Arround the time of the fork, the wallet could set the transaction chainId  to be of the future chainID. Miner would leave it in the pool until the chainID change. For dealing with minority-led fork, the blockNumber at which the transaction was signed should also be included (like EIP-1965) ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.7023809523809526
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chriseth",
                    "index": "93",
                    "likes": "0",
                    "time": "29/04/2019-07:23:10",
                    "content": "I\u2019m very sorry if this has been discussed before: From a conceptual standpoint, I would prefer if this could be a precompiled contract, since it is external to actual computations in the EVM. Until we reduce the gas costs for calls to precompiled contracts (I would very much like to include this in the next hard fork, if possible), using an opcode is probably the only practical possibility. If we \u201cwaste\u201d a full opcode for this, the let\u2019s at least make it extensible in some way: Make it take a parameter and return the Chain ID if the parameter is zero, the Hardfork number if it is one, and so on and also define reserved and non-reserved parameters. Would that be a good suggestion? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.031060606060605
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "94",
                    "likes": "1",
                    "time": "29/04/2019-13:46:34",
                    "content": "    chriseth:  I would prefer if this could be a precompiled contract, since it is external to actual computations in the EVM   Would like to make the point that tx.origin is also external to the actual computations in the EVM, and is obtained through the signed transaction in a very similar way that chain ID would be obtained. Chain ID was added to the transaction structure in EIP-155 as a protocol update, so in many ways this is just completing that work. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.416666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "95",
                    "likes": "0",
                    "time": "29/04/2019-13:50:26",
                    "content": "    chriseth:  If we \u201cwaste\u201d a full opcode for this, the let\u2019s at least make it extensible in some way: Make it take a parameter and return the Chain ID if the parameter is zero, the Hardfork number if it is one, and so on and also define reserved and non-reserved parameters.   There is alternative suggestions more along this path (EIP-1959, EIP-1965) if you are interested. I believe them not to be as flexible for the end-user as this proposal, but feel free to check those out. It has been suggested to make those pre-compiles due to their added complexity. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.895833333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "96",
                    "likes": "1",
                    "time": "10/05/2019-15:19:54",
                    "content": "I decided to draft an example of a \u201cTrustless Oracle Contract\u201d for historical chain IDs, which is something that could very easily be implemented, audited, and leveraged as a standard for any potential use case requiring access to historical chain IDs, without the complexity of alternative proposals. Check it out here:   github.com   fubuloubu/chain-id-oracle/blob/master/ChainIdOracle.vy struct ActivePeriod:     start_block: uint256     end_block: uint256  # Chain ID => Range of accepted block numbers (inclusive) chain_id_history: map(uint256, ActivePeriod)  # Cache of the last time the chain ID was updated previous_update_blocknumber: uint256  # Cache of last setpoint of chain ID # Note: must be initialized! previous_chain_id: uint256   @public def __init__():     self.previous_chain_id = tx.chain_id     # Note: keep previous_update_blocknumber equal to 0      This file has been truncated. show original        Again would like to note that assuming what the end user might want to use current chain ID for may not be known in advance, and adding a more complicated API may otherwise prevent the implementation of specific use cases that a simpler API would allow through some smart contract magic. ",
                    "links": [
                        "https://github.com/fubuloubu/chain-id-oracle/blob/master/ChainIdOracle.vy",
                        "https://github.com/fubuloubu/chain-id-oracle/blob/master/ChainIdOracle.vy",
                        "https://ethereum-magicians.org/t/eip-2014-extended-state-oracle/3301/3",
                        "https://ethereum-magicians.org/t/hardfork-meta-istanbul-discussion/3207/4"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.516443452380953
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "97",
                    "likes": "2",
                    "time": "11/05/2019-12:49:43",
                    "content": "Wow we were thinking yesterday along the same lines then. I\u2019ve draft this EIP which may be relevant: https://github.com/ethereum/EIPs/pull/2014 ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.833333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gumb0",
                    "index": "98",
                    "likes": "1",
                    "time": "24/07/2019-15:00:34",
                    "content": "EIP is now implemented in aleth https://github.com/ethereum/aleth/pull/5696 ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "99",
                    "likes": "1",
                    "time": "26/07/2019-15:47:27",
                    "content": "Was accepted for Istanbul as of the call today, however @karalabe made the suggestion that implementations should reference a hard-coded value of chain ID present in the client instead of the value provided by EIP-155 compatible transactions (which the reference implementation uses). This would reduce the corner case that EIP-155 technical allows not providing chain ID in a transaction, and also makes it more compatible with EIP-695 (adds Chain ID JSON-RPC call). ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.833333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "100",
                    "likes": "0",
                    "time": "26/07/2019-19:35:01",
                    "content": "@fubuloubu can you specify the value range of the chainid returned? Is it 64-bit, is it 256-bit, \u2026? It would be nice to know it as we\u2019re trying to have explicit ranges, see EIP-1985. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 8.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "101",
                    "likes": "1",
                    "time": "26/07/2019-20:35:04",
                    "content": "256-bit. I didn\u2019t realize it wasn\u2019t in the proposal ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "102",
                    "likes": "0",
                    "time": "29/07/2019-16:11:16",
                    "content": "It\u2019s perfect, thank you. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 10.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "103",
                    "likes": "2",
                    "time": "29/07/2019-16:12:47",
                    "content": "This EIP is well past last call date. Will the process to move from Last Call to Accepted be activated? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.583333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "104",
                    "likes": "0",
                    "time": "29/07/2019-19:40:46",
                    "content": "I have https://github.com/ethereum/EIPs/pull/1994 open for that. With recommended inclusion into Istanbul, I am hoping we can move this to Accepted soon so that implementers may be able to reference this proposal in a Solidified state. I\u2019m still working on the reference implementation into Trinity, but the Aleth implementation is here: https://github.com/ethereum/aleth/pull/5696 ",
                    "links": [
                        "https://github.com/ethereum/aleth/pull/5696"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "105",
                    "likes": "0",
                    "time": "15/08/2019-11:20:08",
                    "content": "    shemnon:  However EIP-155 where this scheme was introduced defines 1337 as a Geth devnet, which breaks this.   To clear this part of the confusion: that was added after the adoption of EIP-155 in a hard fork as well as the update of YP. I clearly remember the ACD calls (around 2016 or 2017) where a 1 byte value was agreed on. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.847222222222222
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "106",
                    "likes": "0",
                    "time": "15/08/2019-11:21:34",
                    "content": "    fulldecent:  PROPOSAL: The correct chain ID should be sha3(tar_gz(reference_implementation) || genesis_block) . If the reference implementation changes to an incompatible version (i.e. a hard fork) then the chain ID is changed.   While I think this is a clever idea, in the worst case it means the calculation for the transaction exceeds 256 bits. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 3.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "107",
                    "likes": "0",
                    "time": "17/08/2019-02:27:50",
                    "content": "Thank you. Maybe more clever (read: risky) is an alternate implementation that does not depend on concatenation: sha3(sha3(tar_gz(reference_implementation)) ^ sha3(genesis_block)) ^ sha3(genesis_block) ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.111111111111112
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "108",
                    "likes": "0",
                    "time": "20/08/2019-12:48:18",
                    "content": "Maybe the 64-bit unsigned integer (uint64) would be enough? I don\u2019t like planning for use cases that may be never needed. Even if you want to use a hash function, truncating the output to 64 bits seems good enough (@axic\u2019s tip). ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.166666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "109",
                    "likes": "1",
                    "time": "20/08/2019-13:27:45",
                    "content": "I\u2019m strongly in favour not making it 256-bit wide. Allowing it to be 256-bit wide means that the RLP encoding of a transaction must use >256-bit arithmetic to calculate the v field. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.388888888888888
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "110",
                    "likes": "0",
                    "time": "20/08/2019-15:00:21",
                    "content": "64 bits is a decent amount of entropy to avoid hash collisions with normal use, and there would likely be other mitigating factors if chain ID were hash-based and someone wished to exploit it to fake out other network node\u2019s network discovery phases (or however it might be used). Given @axic\u2019s observation of the need to change RLP encoding of transactions to support a larger field, I think this is a reasonable request. What\u2019s the worst case scenario for the v field?  If there\u2019s consensus for this, I can update the EIP ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.314814814814815
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "111",
                    "likes": "1",
                    "time": "20/08/2019-22:02:11",
                    "content": "    fubuloubu:  What\u2019s the worst case scenario for the v field?   From EIP-155:  If block.number >= FORK_BLKNUM and v = CHAIN_ID * 2 + 35 or v = CHAIN_ID * 2 + 36 , then when computing the hash of a transaction for purposes of signing or recovering,  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 0.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "112",
                    "likes": "0",
                    "time": "21/08/2019-09:56:53",
                    "content": "To make sure I understand. Do you want to set max chain id value such that v = CHAIN_ID * 2 + 36 will fit in 64-bits? Then I\u2019d recommend targeting 63 bits - then you would allow this computation with signed types. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "113",
                    "likes": "0",
                    "time": "21/08/2019-12:47:25",
                    "content": "No, he was saying that the max value of chain ID must be less than MAX_UNIT256/2-36 to fit in 256-bit arithmetic. 64 bits is well inside that ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.583333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "114",
                    "likes": "0",
                    "time": "21/08/2019-14:25:45",
                    "content": "I have no strong opinion whether the chain id or the complete calculation should be 64-bit, but I\u2019d argue on the RLP level calculations must be able to support 256-bit so either way should be fine. I\u2019d also argue that eventually the transaction format should be cleared up and this workaround be removed as it was only added to minimize the impact of changes back in 2016/2017. By this logic chain id could be 64-bit. I am also writing up an \u201cerrata\u201d EIP to EIP-155 to clarify what we\u2019re discussing here \u2013 as EIP-1344 only discusses EVM. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.571428571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "115",
                    "likes": "0",
                    "time": "06/09/2019-11:43:10",
                    "content": "    fubuloubu:  64 bits is well inside that   Will you make this change to the EIP? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "116",
                    "likes": "0",
                    "time": "06/09/2019-18:45:33",
                    "content": "Added: https://github.com/ethereum/EIPs/pull/2263 Also noticed some of the links were broken, so updating those separately.  Edit: Links PR here: https://github.com/ethereum/EIPs/pull/2264 ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/2264"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 3.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/michaelsproul",
                    "index": "117",
                    "likes": "0",
                    "time": "15/01/2021-03:59:14",
                    "content": "I just noticed that this opcode is absent from the yellow paper. Does anyone fancy adding it?   github.com/ethereum/yellowpaper     \t      Missing CHAINID opcode (EIP-1344)            opened 03:37AM - 15 Jan 21 UTC               michaelsproul               The yellow paper is presently missing the CHAINID opcode (0x46) from the description of the EVM. This opcode was introduced in...         ",
                    "links": [
                        "https://github.com/ethereum/yellowpaper/issues/784",
                        "https://github.com/michaelsproul"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "118",
                    "likes": "1",
                    "time": "19/01/2021-16:18:42",
                    "content": "Hmmm I would look into it  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                }
            ]
        }
    ],
    "group_index": "164"
}