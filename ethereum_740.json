{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-1822-universal-upgradeable-proxy-standard-uups/2842",
            "title": "EIP-1822: Universal Upgradeable Proxy Standard (UUPS) ",
            "index": 2842,
            "category": [
                "EIPs"
            ],
            "tags": [
                "proxy-contract",
                "eip-1822"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/pi0neerpat",
                    "index": "1",
                    "likes": "3",
                    "time": "04/03/2019-19:49:09",
                    "content": "Universal Upgradeable Proxy Standard (UUPS), pronounced \u201coops,\u201d is similar to existing proxy contracts, in that it creates an escape hatch for upgrading to a new smart contract when a bug or vulnerability is found. Here we introduce an improvement upon proxy contracts which can be used as a holistic lifecycle management tool for smart contracts. Our motivation for developing UUPS was to reduce contract deployment cost for our onboarding tool, while maintaining universal compatibility and keeping ownership in the hands of the developers. View the explainer and simple tutorial    Medium    Introducing the \u201cEscape-hatch\u201d Proxy Universal Upgradeable Proxy Standard (UUPS), pronounced oops, is similar to existing proxy contracts. Proxy contracts create an escape\u2026 Reading time: 7 min read       View the full EIP   github.com   ethereum/EIPs/blob/master/EIPS/eip-1822.md --- eip: 1822 title: Universal Upgradeable Proxy Standard (UUPS) author: Gabriel Barros <gabriel@terminal.co>, Patrick Gallagher <patrick@terminal.co> discussions-to: https://ethereum-magicians.org/t/eip-universal-upgradeable-proxy-standard-uups status: Draft type: Standards Track category: ERC created: 2019-03-04 ---  ## Table of contents  <!-- TOC -->  - [Table of contents](#table-of-contents) - [Simple Summary](#simple-summary) - [Abstract](#abstract) - [Motivation](#motivation) - [Terminology](#terminology)     This file has been truncated. show original      If you have any comments, edits, or suggestions, let us know here! ",
                    "links": [
                        "https://medium.com/@terminaldotco/escape-hatch-proxy-efb681de108d",
                        "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1822.md",
                        "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1822.md",
                        "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1822.md"
                    ],
                    "GPT-summary": "The post introduces the Universal Upgradeable Proxy Standard (UUPS), which is an improvement upon existing proxy contracts. The author explains the motivation behind developing UUPS and how it can be used as a holistic lifecycle management tool for smart contracts. The post also includes a link to an explainer and simple tutorial. A 3rd party could give constructive criticism or ask questions about the proposal.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Interoperability and Scalability",
                        "None",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.384356962481962
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "2",
                    "likes": "2",
                    "time": "04/03/2019-21:00:14",
                    "content": "Won\u2019t have any comments until there is something to comment, but as a huge fan of ERC1538 I\u2019m really curious about want you have to propose  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pi0neerpat",
                    "index": "3",
                    "likes": "0",
                    "time": "04/03/2019-21:05:39",
                    "content": "Still waiting on review from an EIP Auditor, but I went ahead and updated the link with the PR. Looking forward to hearing your thoughts! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jess.simpson",
                    "index": "4",
                    "likes": "2",
                    "time": "08/03/2019-16:32:24",
                    "content": "I just did the Remix example on the medium article. What a way to explain the EIP, great work there  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 9.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gbarros",
                    "index": "5",
                    "likes": "0",
                    "time": "08/03/2019-19:55:16",
                    "content": "Gabriel here. Anxious to get your feedback and have great discussions! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ali2251",
                    "index": "6",
                    "likes": "1",
                    "time": "12/03/2019-09:59:43",
                    "content": "Hi, I am Ali, author of https://docs.upgradablecontracts.com/ and have been researching in the area of upgradability for a while now. I maybe missing something there but I cant see any improvements to the proxy contracts and the links you have provided to the Gnosis are OpenZeppelin are way too old, I suggest looking at their contracts in Production (Gnosis Safe) and ZeppelinOS. To my specific concern.   Gnosis Safe contracts in particular do not use the first slot,  they use this: https://github.com/gnosis/safe-contracts/blob/development/contracts/proxies/Proxy.sol#L28   How is your pattern different from Zeppelins Unstructured storage? to me they look the same   How do you achieve a governance change? (If its such that the owner points to an address which is a contract which handles governance such as a multi-sig, I believe thats been around for a long time)   I am happy to have a chat offline if that helps but cant see the point of the EIP, but very open to being educated! Best, Ali ",
                    "links": [
                        "https://github.com/gnosis/safe-contracts/blob/development/contracts/proxies/Proxy.sol#L28"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.022222222222222
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "7",
                    "likes": "0",
                    "time": "16/03/2019-17:34:40",
                    "content": "    ali2251:  How do you achieve a governance change? (If its such that the owner points to an address which is a contract which handles governance such as a multi-sig, I believe thats been around for a long time)   I\u2019ve proposed something very similar to ERC1822  with a callback mechanism for initialization of the governance. Proposal isn\u2019t written yet but the code is available here. In particular, you can check the test/010_upgrade.js to see an example ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.430555555555555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pi0neerpat",
                    "index": "8",
                    "likes": "0",
                    "time": "16/03/2019-20:36:09",
                    "content": "Hey I saw this a few weeks ago on twitter. Excited to finally see the code. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.291666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pi0neerpat",
                    "index": "9",
                    "likes": "1",
                    "time": "16/03/2019-21:24:27",
                    "content": "Hi Ali, thanks for pointing this out. We weren\u2019t aware of this particular implementation, but will add it to the EIP discussion section. There are a few differences between ours and the Zeppelin unstructured example. I\u2019ll start by saying that the overall the purpose of this EIP is to create a standard proxy (be it Zeppelin, the one we present, or a combination). By doing so we can improve developer experience across the ecosystem, and make a highly accessible interface rather than fragmented and incompatible implementations. The following are two examples of common actions we may wish to perfom for many different proxy contracts. The UUPS allows us to avoid writing new code for every different proxy implementation.  Verify both the contract source code and initialization code Create your own proxy of an existing deployed contract, using your own initialization parameters.  Another difference is that the storage slot is intentionally choose as \u201cProxiable\u201d, and not a random string. Again, this helps us standardize the process. Regarding governance, I think the approach your describing we debunk in the Medium post. Governance is not in an external contract. It can be implemented directly into the Logic Contract itself. This makes it much simpler to design Happy to answer more questions! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.977961432506888
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "10",
                    "likes": "0",
                    "time": "16/03/2019-22:35:41",
                    "content": "To answer your tweet here, I\u2019m discussing that with Fabian from erc725 before proposing a new opposing standard for account proxy. My first objective is not generic upgradable contracts, but identity proxy with upgradable governance. I\u2019m sure there is a lot in ERC1822 I could benefit from. Feel free to PM me is you want to discuss that. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.9188311688311686
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gbarros",
                    "index": "11",
                    "likes": "0",
                    "time": "19/03/2019-14:45:01",
                    "content": "Hey Amxx, I am also interested in identities and have been playing with 725. Don\u2019t you think this here could be the the smallest possible interface/base for an identity, since it\u2019s (almost) fully upgrade-able, then we could add some very basic functionality for identity abilities ? Kinda the way 725 is already heading. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.416666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "12",
                    "likes": "0",
                    "time": "20/03/2019-08:57:55",
                    "content": "I think your design is missing a mechanism to initialize the memory state of the proxy when the logic contract is updated. updateCodeAddress must include much more then just updating the targeted logic. It potentially needs to reset the memory state of the proxy and configure the new logic. An exmaple is that, if you have an identity proxy that is a simple ownable contract, and you want to update it to a multisig, you should cleanup the owner and set up the multisig persmissions in a single transaction when updating the logic. This is why I include semantics for initilization function, and pass bytes to describe initialization operation. Without that I\u2019m afraid updating security policy will be either insecure of non user friendly ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.799963924963925
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "13",
                    "likes": "0",
                    "time": "20/03/2019-13:50:04",
                    "content": "I believe what i\u2019m proposing in ERC1836 is close to the minimal subset of ERC1822 that has the added functionnality needed to manage \u201cidentities\u201d through proxy ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gbarros",
                    "index": "14",
                    "likes": "0",
                    "time": "20/03/2019-13:50:18",
                    "content": "I think the addition of \u201cre-initialization\u201d code is a great suggestion. I wouldn\u2019t go as far as say it\u2019s a reset, but definitely it\u2019s a process that might be needed. Although there is already space for it happen, I agree that it\u2019s not the best user experience not having it in a single tx if possible. I will think a bit and suggest an implementation for it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.523809523809524
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "15",
                    "likes": "0",
                    "time": "20/03/2019-13:56:14",
                    "content": "I think state reset is needed for 2 reason:   I might want to upgrade from mutlisig1 to multisig2 or from multisig2 to multisig1. If the 2 were dot designed to be compatible, I one will end up assuming fiels are null when the previous delegate set them. This can be keys or anything else.   When moving from multisig1 to multisig2 then back to multisig1 I will assume no traces of are left that would break the assumptions of the second usage of multisig1.   That is why I believe some data should formalized by ERC1836 to stay as an invariant \u2014 nonce / nonceless replay protection / identity generic data (from ERC725) for example \u2014 and everything else should be cleaned up. We could however see the cleanup as a layer on top of the standard, with the basic updateDelegate / updateCodeAddress not performing the cleanup and an added cleanup function that would clean then call the upgrade mechanism. That way you have the choice to cleanup before upgrading or not (in a single tx) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.314285714285715
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gbarros",
                    "index": "16",
                    "likes": "0",
                    "time": "20/03/2019-14:07:07",
                    "content": "A reset is something potentially impossible, or at the very least cost prohibitive. If you are upgrading from multisig1 to multisig2, you are not just randomly pointing to another implementation but rather something more like fromMultisig1ToMultisig2 implementation/logic contract. Also, I remember from a conversation with Fabian where his was proposing (when discussing identity) those contract whose address are beacons (not meant to be changed, such as the 725) be managed by some other contract. This came up when talking how, in this particular case, a 725 is often managed by a single owner but in the future might be managed by a multsig. In his view, when it happens you change the owner to a 734 contract. I think that\u2019s the best option for when changes are quite drastic ( although I do see how you could potentially make it happen with a \u201csimpler\u201d upgrade). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None",
                        "None"
                    ],
                    "Sentiment": 4.960714285714285
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "17",
                    "likes": "1",
                    "time": "20/03/2019-14:14:45",
                    "content": "I believe multisig1 and multisig2 cloud be ERC1077 (universal login), gnosis safe, uport, \u2026 things that you may want to move from and to in no particular succession. My issue with having an ERC734 owning an ERC725 is that:  By calling the ERC725 proxy you would not be able to access info from the multisig (like ERC1271 interfaces) \u2026 this can be solved by a fallback in the proxy, which i proposed as a PR to ERC725 The multisig owns no asset, and therefore cannot easily refund relayer for meta transaction (or the multisig has to be ERC725 specific \u2026 which I think isn\u2019t a good idea) You end up with a LOT of multisig (one per proxy) which is expensive to deploy and fill the blockchain memory \u2026 keep in mind that they will be disposable  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.96875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gbarros",
                    "index": "18",
                    "likes": "1",
                    "time": "20/03/2019-14:29:09",
                    "content": "  You end up with a LOT of multisig (one per proxy) which is expensive to deploy and fill the blockchain memory \u2026 keep in mind that they will be disposable   You missed the point of UUPS hahaha. You wouldn\u2019t really deploy the whole 734 every time, just deploy an UPPS and point to it.  The multisig owns no asset  But it manages a contract that has assets. It is able to implement 1077 with no trouble and ask the 725 to issue the repayment. All this while the other systems are completely unaware of what is really going on with the setup (734->725).  By calling the ERC725 proxy you would not be able to access info from the multisig.  As of now, it\u2019s not part of the ERC725, and for that, I agree that it is not straightforward. But you could have an implementation of 725 that is aware of outside management, meaning another contract. All this to say, that you really don\u2019t need to resort to \u201cstate\u201d resets. Once a user deploys a contract with a vendor, they will be very limited on migrating it to another vendor\u2019s implementation. Therefore, it makes sense that vendors will keep track (as they have), of their implementations, and when updates/upgrades are available they will have to check for compatibility. We can only try to make this less of a \u201clocked with a vendor\u201d kind of situation. And I think decoupling where possible, as 725 being simple but managed externally is one of those measures. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.517721861471862
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "19",
                    "likes": "1",
                    "time": "20/03/2019-14:35:25",
                    "content": "    gbarros:  You missed the point of UUPS hahaha. You wouldn\u2019t really deploy the whole 734 every time, just deploy an UPPS and point to it.   Ok so instead of having potentially millions of abandonned multisigs, you have millions of abandonned ERC1822 \u2026 sure it\u2019s better, but still sounds bad to me     gbarros:  But it manages a contract that has assets. It is able to implement 1077 with no trouble and ask the 725 to issue the repayment. All this while the other systems are completely unaware of what is really going on with the setup (734->725).   But you have 2 different version of the 1077, one for when it\u2019s a standalone, and one for when it\u2019s behind an ERC725 In the end it\u2019s a matter of personal preferences. I see the point of your organisation. It\u2019s less likely to break but is more expensive. I see mine as being more elegant and cheap, but also more complex for SCs developers ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.621666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gbarros",
                    "index": "20",
                    "likes": "1",
                    "time": "20/03/2019-14:46:46",
                    "content": " millions of abandonned ERC1822  Next iteration will have a solution for it. Glad we could talk. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "21",
                    "likes": "1",
                    "time": "23/06/2020-18:41:47",
                    "content": "    pi0neerpat:  Another difference is that the storage slot is intentionally choose as \u201cProxiable\u201d, and not a random string. Again, this helps us standardize the process.   To improve compatibility of this proxy with existing and future solutions, I think it would be much better to use the slot defined in EIP-1967: Standard Proxy Storage Slots. @pi0neerpat Can you explain the reasons why this was explicitly decided against? We\u2019re trying to move said EIP to Final state and it would be good to have UUPS on board. We really do like this model and want to provide an implementation of it in OpenZeppelin Contracts but the choice of an incompatible storage slot sticks out as a problem for us. For inclusion in OpenZeppelin it would also be necessary to move this EIP to Final. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.916666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pi0neerpat",
                    "index": "22",
                    "likes": "1",
                    "time": "24/06/2020-20:00:01",
                    "content": "We are on board too with this new 1967 storage slot naming. Working on it here and will report back here once we are finished https://github.com/ethereum/EIPs/pull/2750 ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.340909090909091
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/hellwolf",
                    "index": "23",
                    "likes": "0",
                    "time": "24/07/2020-14:36:58",
                    "content": "Currently the purpose of proxiableUUID is not well explained. It seems to me it would be made more useful, if it would be about differentiating different types of logic contract as opposes to the slot of the implementation: abstract contract Proxiable {  ...    /**      * @dev Proxiable UUID marker function.      *      This would help to avoid wrong logic contract to be used for upgrading.      */     function proxiableUUID() public pure virtual returns (bytes32);      /**      * @dev Update code address function.      *      It is internal, so the derived contract could setup its own permission logic.      */     function _updateCodeAddress(address newAddress) internal {         require(             proxiableUUID() == Proxiable(newAddress).proxiableUUID(),             \"Proxiable: NOT_COMPATIBLE\"         );         ProxyUtils.setImplementation(newAddress); ...  While in actual implementation of a specific contract:     function proxiableUUID() public pure override returns (bytes32) {         return keccak256(\"org.rdai.contracts.RToken.implementation\");     }  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.474489795918367
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pi0neerpat",
                    "index": "24",
                    "likes": "0",
                    "time": "24/07/2020-19:24:28",
                    "content": "Yes the language here is vague about what the uuid could be intentionally. Would adding some more examples here be helpful? Or would you want to see the section changed to explain more about how uuid should be used?   github.com   ethereum/EIPs/blob/master/EIPS/eip-1822.md#proxiable --- eip: 1822 title: Universal Upgradeable Proxy Standard (UUPS) author: Gabriel Barros <gabriel@terminal.co>, Patrick Gallagher <blockchainbuddha@gmail.com> discussions-to: https://ethereum-magicians.org/t/eip-1822-universal-upgradeable-proxy-standard-uups status: Draft type: Standards Track category: ERC created: 2019-03-04 ---  ## Table of contents  <!-- TOC -->  - [Table of contents](#table-of-contents) - [Simple Summary](#simple-summary) - [Abstract](#abstract) - [Motivation](#motivation) - [Terminology](#terminology)     This file has been truncated. show original      ",
                    "links": [
                        "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1822.md#proxiable",
                        "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1822.md#proxiable"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/hellwolf",
                    "index": "25",
                    "likes": "0",
                    "time": "25/07/2020-16:15:48",
                    "content": "The code example from the proposal is:     function updateCodeAddress(address newAddress) internal {         require(             bytes32(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7) == Proxiable(newAddress).proxiableUUID(),             \"Not compatible\"         );  And that is suggesting proxiableUUID is basically the slot ID, which I find un-useful. If I wanted to distinguish different type of logic contract, I would rather use the UUID scheme I proposed in the previous reply. Is that close to what you have had in mind, or I have deviated from the original idea? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.260416666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/novaknole",
                    "index": "26",
                    "likes": "2",
                    "time": "15/12/2020-13:00:18",
                    "content": "Hi All, Is this thread still going on ? I would love to ask some questions that I found very interesting and confusing by following this EIP \u2026 ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.0625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jpitts",
                    "index": "27",
                    "likes": "0",
                    "time": "15/12/2020-17:25:33",
                    "content": "Definitely post whatever you have to ask here, Discourse puts updated threads on top on the Forum home page. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/hellwolf",
                    "index": "28",
                    "likes": "0",
                    "time": "16/12/2020-21:25:49",
                    "content": "We have been using it (with some extensions) at Superfluid.finance, would love to push this forward more. @pi0neerpat what do you think? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/poojaranjan",
                    "index": "29",
                    "likes": "0",
                    "time": "28/01/2021-16:10:38",
                    "content": "A wonderful overview with superb Remix demo of Universal Upgradable Proxy Standard by @pi0neerpat & @gbarros on Peep An EIP. Recording available to follow      ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving entirely positive feedback on proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 7.4
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "30",
                    "likes": "2",
                    "time": "04/03/2021-14:10:41",
                    "content": "Hello, While experimenting with proxy patterns, and trying to come up with an implementation that would be nice and modular, we realize there is an issue with the proxiableUUID as a security mechanism. proxiableUUID() returns a specific value that is supposed to help distinguish between a UUPS compatible logic, and any other smart contract. The point being that is we update a proxy to point to a non-UUPS compatible contract, this would not include/expose the necessary upgrate mechanisms, and this would break further upgradeability. However, there is an entier class of contract that do expose the proxiableUUID logic but do not contain the corresponding logic: UUPS proxies. A UUPS proxy will forward any call to the implementation, and since the implementation is requiered to implement the UUID mechanism, the proxy will actually mimic that. However, upgrading your proxy to use another proxy as your logic will instancty and irrevocably break your proxy. Thus, we feel like the security mechanism described in ERC-1822 is not good, and should either be removed or modified. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.212053571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "31",
                    "likes": "2",
                    "time": "16/03/2021-20:20:39",
                    "content": "@pi0neerpat How do you feel about removing the proxiableUUID mechanism from the EIP? The resulting EIP would only document the UUPS pattern and not impose any restrictions on the ABI of implementation contracts. I\u2019m not sure if this is compatible with the original goals of the EIP. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.208333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/CryptoKiddies",
                    "index": "32",
                    "likes": "1",
                    "time": "11/08/2021-00:33:17",
                    "content": "A couple of issues with the restricting logic functions sections: contract Owned is Proxiable {     // ensures no one can manipulate this contract once it is deployed     address public owner = address(1);     // DOS vulnerability     function constructor1() public{         // ensures this can be called only once per *proxy* contract deployed       // *typo* require should check address(1) below         require(owner == address(0));         owner = msg.sender;     }      function updateCode(address newCode) onlyOwner public {         updateCodeAddress(newCode);     }      modifier onlyOwner() {         require(msg.sender == owner, \"x\");         _;     } }  The quasi constructor can be DOS\u2019ed by malicious miners, so it would be far preferable to pass in the owner address immediately. Minor, the require check has a typo. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.041666666666666
                }
            ]
        }
    ],
    "group_index": "740"
}