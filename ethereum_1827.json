{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-5267-retrieval-of-eip-712-domain/9951",
            "title": "EIP-5267: Retrieval of EIP-712 domain ",
            "index": 9951,
            "category": [
                "EIPs"
            ],
            "tags": [
                "NONE"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "1",
                    "likes": "7",
                    "time": "15/07/2022-13:49:35",
                    "content": "Discussion for EIP-5267.   Ethereum Improvement Proposals   EIP-5267: Retrieval of EIP-712 domain A way to describe and retrieve an EIP-712 domain to securely integrate EIP-712 signatures.       This EIP complements EIP-712 by standardizing how contracts should publish the fields and values that describe their domain. This enables applications to retrieve this description and generate appropriate domain separators in a general way, and thus integrate EIP-712 signatures securely and scalably.  ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-5267",
                        "https://eips.ethereum.org/EIPS/eip-712",
                        "https://ethereum-magicians.org/t/eip-712-eth-signtypeddata-as-a-standard-for-machine-verifiable-and-human-readable-typed-data-signing/397/34"
                    ],
                    "GPT-summary": "The post discusses EIP-5267, which proposes a way to describe and retrieve an EIP-712 domain to securely integrate EIP-712 signatures. The author explains how this EIP complements EIP-712 by standardizing how contracts should publish the fields and values that describe their domain. The post also invites discussion and feedback on the proposal, and a third party asks a question about the proposal.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Interoperability and Scalability",
                        "Privacy, Security and risk management",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.6875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cylon56",
                    "index": "2",
                    "likes": "0",
                    "time": "19/07/2022-17:19:15",
                    "content": "Hi @frangio - This seems a great, common-sense way to standardize EIP-712 domain retrieval. Couple questions:  Are there some specific examples of projects suffering the issues that this EIP will alleviate that you can share? How big do you think the impact would be if this became widely adopted? Are there any existing implementations using this approach in production right now?  Note: I work with @frangio in a separate team at OpenZeppelin but I thought this question would be better asked in the public forum in case others found it useful. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.116071428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "3",
                    "likes": "3",
                    "time": "19/07/2022-18:01:57",
                    "content": "    cylon56:  Are there some specific examples of projects suffering the issues that this EIP will alleviate that you can share? How big do you think the impact would be if this became widely adopted?   All decentralized ERC20 exchanges that don\u2019t have or only have partial support for permit are suffering from this issue. Currently, the only way to use ERC20 permits is to either hardcode the EIP-712 domain for a subset of tokens, and/or to \u201cguess\u201d the domain and verify that you guessed it correctly with DOMAIN_SEPARATOR. The first option is not scalable and the second option is not reliable and not general. Additionally, they don\u2019t help with other EIP-712 usecases: while ERC20 has a name() function that can help the guess for permits, other standards or contracts don\u2019t. A concrete example is 1inch, which has partial support. USDC on Ethereum mainnet has the option to use permit, but permit is not available on 1inch on Arbitrum even though almost all tokens have permit because it\u2019s the default of the bridge. I believe this is a cosequence of having no good general and scalable way to request EIP-712 signatures like permits. I hesitate to speculate on the potential impact. I don\u2019t think EIP-712 is usable without something like what I\u2019m proposing.     cylon56:  Are there any existing implementations using this approach in production right now?   Not yet, that I\u2019m aware of. I\u2019ve discussed this problem with some people before but this is the first solution that has been proposed I think. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.026360544217687
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ZumZoom",
                    "index": "4",
                    "likes": "4",
                    "time": "22/07/2022-08:58:31",
                    "content": "Hi @frangio. I agree that permit support is a struggle without standardised way of domain retrieval. I think that better example will be Polygon standard PoS tokens like USDC or USDT. They all use the domain EIP712Domain(string name,string version,address verifyingContract,bytes32 salt) instead of the more widespread EIP712Domain(string name,string version,uint256 chainId,address verifyingContract). The diversity of domains and lack of domain structure exposure makes it difficult to support all the different domains which why only the most widespread ones are supported. Overall your suggestion seems great and will surely improve the permit support in dapps. ",
                    "links": [
                        "https://polygonscan.com/address/0xc2132d05d31c914a87c6611c10748aeb04b58e8f"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.15
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/d3mage",
                    "index": "5",
                    "likes": "0",
                    "time": "26/07/2022-06:58:06",
                    "content": "Hello. After reading the EIP, I would ask @frangio to add a minor clarification to the section regarding fields. \u201cif and only if domain field i is present\u201d makes it easier to understand what fields are we talking about.  The only question is why bits are read from least significant to most significant? Wouldn\u2019t it be more convenient to use big-endian notation? But overall this EIP is a really good one, expecting it to be widespread ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.05
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "6",
                    "likes": "0",
                    "time": "27/07/2022-15:56:46",
                    "content": "Thanks @d3mage! What difference do you see from changing it to \u201cdomain field\u201d? It seems the same as the current text to me. The choice of endianness is a tradeoff. The way it\u2019s specified now it\u2019s really easy to specify and implement the decoding function (see the JS snippet in Reference Implementation). What you suggest might make it easier to write the Solidity part (when writing manually at least), is this the reason you were suggesting the change of endianness? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.383333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/d3mage",
                    "index": "7",
                    "likes": "2",
                    "time": "28/07/2022-01:41:45",
                    "content": "From my personal experience: took me some time to figure out what fields we were talking to. So a small pointer would be sufficient for a reader to pay attention and understand what those fields are. If I understand it properly, the choice of endianness is driven by the goal of creating a generic backend, compatible with any domain (welp, this is what this standard is about). In such case, I can only agree with you. Thanks for your response  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.96875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/philipliao",
                    "index": "8",
                    "likes": "1",
                    "time": "07/08/2022-13:08:23",
                    "content": "This is an excellent EIP and solves a true pain point. Right now, determining the EIP-712 domain of contracts is either: guess and check, or digging into the source code. It could also be nice to deploy a canonical registry contract on each chain that \u201cvalidates\u201d the EIP-712 Domain. Anyone can attempt to \u201cregister\u201d the domain for a given contract, but this will only succeed if the hash of the domain is equivalent to the contract\u2019s DOMAIN_SEPARATOR. Might need some consideration for proxy contracts like USDC Finally, people could look up function eip712Domain(address target) in largely the same way that they would if the original contract implemented this EIP (which many immutable contracts cannot). This view function would likely need to recompute the hash and check the DOMAIN_SEPARATOR again, in case the proxy implementation has changed its domain Maybe this registry contract already exists, but would be nice to have for existing tokens that cannot implement this standard (and new tokens that don\u2019t know about this standard) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.3537878787878785
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "9",
                    "likes": "1",
                    "time": "07/08/2022-22:42:55",
                    "content": "Thanks! And on-chain registry could be useful, but I expect some sort of off chain registry for those contracts anyway. The info could just be embedded in token lists. I think the off chain approach is slightly more powerful in the sense that a human can verify if the domain is immutable (whereas a smart contract registry couldn\u2019t do that). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.303571428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "10",
                    "likes": "0",
                    "time": "03/09/2022-07:14:07",
                    "content": "Thanks @frangio for making this proposal, this is indeed much needed for EIP-712 to be truly usable Couple comments:  The proposal does not implement EIP-165. I guess this is intentional and would like to see the rationale for it. I suppose this is because if the function throws, then we know the contract does not support this proposal. Technically a minimum gas limit should be specified then to be accurate. The proposal uses a function instead of an event. My first impression is that an event should be more than sufficient since the tx signer that needs to make use of EIP-712 will be able to provide the information to the contract. If there is a use-case for on-chain retrieval of the domains that cannot be achieved with the tx signer providing the info, it would be great to see it mentioned in the rationale. If on the other hand, the function is intended to be only called off-chain, one could solve the gas limit requirement mentioned in the previous point by specifying that the block gas limit need to be provided  Actually, while I was writing this last comment I realised a potential rationale for using a function: if the parameters are somehow dynamic, it would not be possible to use events. One particular example is the chainID which in several contracts is made dynamic to support minority forks. (While an event could technically be triggered in such case, it would require an external action to trigger the tx). But maybe  you have more to add here. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.692708333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "11",
                    "likes": "0",
                    "time": "03/09/2022-09:56:55",
                    "content": "Please provide a link to your proposal, now I\u2019m interested how events can solve this. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "12",
                    "likes": "0",
                    "time": "03/09/2022-11:44:09",
                    "content": "oh, I do not have a proposal, just was thinking an event could be used instead of the function like event EIP712Domain(bytes1 fields,       string memory name,       string memory version,       uint256 chainId,       address verifyingContract,       bytes32 salt,       uint256[] memory extensions);  but like I mentioned on dynamic parameter like chainId, this is not as great as the event would have to be triggered ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 7.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "13",
                    "likes": "0",
                    "time": "04/09/2022-01:02:32",
                    "content": "Thanks for the feedback! I\u2019ve considered an event but discarded it due to the issue with dynamic domains that you point out, and also that I believe it\u2019s not as simple to fetch an event as it is to query a view function. For example, Cloudflare\u2019s Ethereum Gateway supports eth_call but does not support the RPC endpoints related to logs. I don\u2019t know if logs would remain reliable in the future due to pruning.  I didn\u2019t really consider ERC-165 but my thinking was as you described, if the function reverts it should be assumed not to be there.     wighawag:  Technically a minimum gas limit should be specified then to be accurate.   Do you mean a maximum? In order to give clients a minimum gas limit to submit, the EIP would need to specify the maximum gas the function can use. I can see that technically there\u2019s a problem if there is no maximum in the spec, but in practice eth_call runs with a large amount of gas so it wouldn\u2019t run into that problem, and hardcoding gas limits is generally seen as a bad idea nowadays due to possible pricing changes in the future. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.924107142857143
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "14",
                    "likes": "0",
                    "time": "04/09/2022-06:29:19",
                    "content": " I\u2019ve considered an event but discarded it due to the issue with dynamic domains  yes, it indeed makes sense  Do you mean a maximum? In order to give clients a minimum gas limit to submit, the EIP would need to specify the maximum gas the function can use.  Yes, a maximum for the function to use  I can see that technically there\u2019s a problem if there is no maximum in the spec, but in practice eth_call runs with a large amount of gas so it wouldn\u2019t run into that problem, and hardcoding gas limits is generally seen as a bad idea nowadays due to possible pricing changes in the future.  If there is no use for any contract to call that function on-chain, then the maximum gas could be the block gas limit, this remove the need for hardcoding any specific value. But this would indeed be mostly a technical details as in practise it should never matter. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.584077380952381
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "15",
                    "likes": "1",
                    "time": "04/09/2022-09:43:32",
                    "content": "    frangio:  For example, Cloudflare\u2019s Ethereum Gateway supports eth_call but does not support the RPC endpoints related to logs.   Respectfully, I think Cloudflare\u2019s Ethereum Gateway doesn\u2019t matter for making EIP decisions. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dror",
                    "index": "16",
                    "likes": "0",
                    "time": "04/09/2022-14:06:05",
                    "content": "IIRC, the problem is how to map a domain separator of a specific contract to its generating fields, to be included in the signTypedData call. The domain-separator itself is traditionally exposed by contracts as bytes32 public DOMAIN_SEPARATOR While it is possible for contract to expose a public eip712Domain , this does not help existing tokens. My suggestion is to add a registrar for domains: a singleton contract that exposes a method function validateDomainSeparator(bytes32 domainSeparator, uint8 fields, string memory name, string memory version, address verifyingContract, bytes32 salt)  That validates this domain and register it. (note that the uint fields is a bitmask as in your definition, which also includes \u201cchainId\u201d, which is not passed as a parameter, but has to match the current network\u2019s chainId) This registrar is permission-less, since only the parameters define the domain, not the caller. Note that this registrar is not instead of adding an eip712Domain method, but in addition to it. specifically, such registrar can\u2019t support extensions. We can also extend this registrar to register actual tokens, as long as they support DOMAIN_SEPARATOR() or getDomainSeparator() view methods ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.975
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "17",
                    "likes": "0",
                    "time": "05/09/2022-21:33:14",
                    "content": "    TimDaub:  Respectfully, I think Cloudflare\u2019s Ethereum Gateway doesn\u2019t matter for making EIP decisions.   My point is not about this particular service provider but about the availability of logs in general. If a service provider has decided not to make them easily available, there is reason to believe others won\u2019t either.  @dror My initial intention was for existing tokens to be supported by an off-chain registrar. Do you see any use cases where an on-chain registrar like you describe is necessary? Or other reasons why it may be superior? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.057291666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dror",
                    "index": "18",
                    "likes": "0",
                    "time": "05/09/2022-22:06:57",
                    "content": "    frangio:  My initial intention was for existing tokens to be supported by an off-chain registrar. Do you see any use cases where an on-chain registrar like you describe is necessary?   I\u2019m trying to get into the root requirement: we want a way to get per-domain the information that wallets need in order to prompt the users. We don\u2019t want an off chain database, since that has scalability/availability issue. Your model achieve this by adding a method to each contract that provide the domain. With my model, instead of an api method per contract, there is a singleton and one method which gets the contract as parameter. (And I does rely on the contract to expose DOMAIN_SEPARATOR to return the hash) The major difference, of course, is that your model can support extension fields in the \u201cdomain separator\u201d, whereas a central registry is more rigid. Not that both solve only half the problem, as there is the REQUEST_TYPE, which can\u2019t be generalized, since it differ with each request. The only need for a domain separator is in cases where the request type itself is too generic, and just by itself can serve different purposes. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.197916666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/hiro",
                    "index": "19",
                    "likes": "0",
                    "time": "18/09/2022-06:42:09",
                    "content": "There is an issue with how EIP-5267 is defined: the return parameter list includes parameters named name and version, and these exactly match two optional but widely-supported functions (public fields) added to ERC20 contracts. Consequently, when implementing eip712Domain() in an ERC20 contract that contains these fields, the compiler gives Warning: This declaration shadows an existing declaration. Renaming the public functions is not an option, since it is part of the ERC20 contract\u2019s (optional extension) API. And there is no Solidity compiler directive for disabling this warning. Therefore, if you want a clean build (no warnings), only the return values from eip712Domain() can be renamed. However, renaming the return params by adding underscores or similar is not only ugly, but it will create incompatibilities (code breakage) if the return values are being read by a Javascript Web3 library like Ethers that pulls the return parameter names from the API: function eip712Domain() external view returns (bytes1 fields, string memory _name, string memory _version, uint256 chainId,             address verifyingContract, bytes32 salt, uint256[] memory extensions)  Therefore, probably in the EIP-5267 spec, these parameter names should be renamed to something like tokenName and tokenVersion. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 4.953703703703703
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "20",
                    "likes": "0",
                    "time": "19/09/2022-02:31:39",
                    "content": "Interesting find. However, I don\u2019t think this is true:     hiro:  it will create incompatibilities (code breakage) if the return values are being read by a Javascript Web3 library like Ethers that pulls the return parameter names from the API   The client (e.g. the JS code) would interact with the contract using a fixed ABI spec that defines return value names that are independent of the contract source code. The contract can use any names it wants in its source code without affecting compatibility with that client. Additionally, the return value names in the EIP are non-normative (i.e. a compliant implementation can use different names; this should be implicitly understood), and since this is due to Solidity idiosyncrasies and limitations, I would not change the EIP based on this problem. Note that tokenName and tokenVersion are not good options because EIP-712 is relevant beyond tokens. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.597222222222222
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/hiro",
                    "index": "21",
                    "likes": "0",
                    "time": "19/09/2022-22:04:56",
                    "content": "    frangio:  The client (e.g. the JS code) would interact with the contract using a fixed ABI spec that defines return value names that are independent of the contract source code. The contract can use any names it wants in its source code without affecting compatibility with that client.   Currently, in order to instantiate a web3 Contract object, libraries like Ethers require the user to submit a minimum of the contract address and the contract ABI (in either human-readable string form or JSON). The ABI is output by Solidity. It would be very annoying if the user had to go in and manually edit the ABI file to manually change these parameter names every time a new version of the contract is built and deployed, from the versions that were built (e.g. _name and _version) to the versions that the user wants to use in the JS API (e.g. name and version). The creator of Ethers is considering pulling the ABI directly from Etherscan, so that to instantiate a Contract object, you would only have to specify the address of an Etherscan-verified contract. At that point, whatever is built by Solidity, and deployed, is what will be automatically exposed in Javascript. So yes, names exposed in Solidity do in fact matter in Javascript code. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.853535353535354
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "22",
                    "likes": "0",
                    "time": "20/09/2022-22:12:20",
                    "content": "An application or a library that instantiates a Contract object in order to consume its EIP-5267 interface would do so based on a user-provided address and a known ABI embedded in the application or library. The known ABI would have known names, they would not depend on the names that were present in the contract source code. Take an ERC20 wallet as an example. When the user loads a new token address, the wallet will not fetch the ABI from an explorer, it will interact with it through a known ABI for ERC20 tokens. The same thing should happen in an application or library that interacts with EIP-5267 compliant contracts. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.227272727272727
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "23",
                    "likes": "0",
                    "time": "19/10/2022-04:12:58",
                    "content": "@frangio\u2019s ERC lightning talk at Devcon in Bogota on EIP-5267 ERC Lighting Talks - YouTube ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "24",
                    "likes": "0",
                    "time": "27/10/2022-14:14:02",
                    "content": "Hi @frangio this is important EIP, thank you for authoring. Two questions from me:  What is the rationale choosing bytes1 field instead of byte field or uint8 field? What is the rationale of putting a salt field in the domain? It seems not reasonable to get salt from remote, unless the understanding of salt is different, could you ellaborate?  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "25",
                    "likes": "0",
                    "time": "27/10/2022-22:41:24",
                    "content": " I think bytes1 and byte are synonyms. As for byte vs integer types, I went with byte because it doesn\u2019t have integer semantics. The inclusion of salt in the domain is taken directly out of EIP-712. I think it should be seen as a salt to the domain separator, and shouldn\u2019t be confused with a salt for the message being signed, which would be different.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "26",
                    "likes": "0",
                    "time": "04/11/2022-06:01:41",
                    "content": "I could not imagine how salt could be retrieved from the function state, are you referring to nonce instead? In the current snapshot of reference implementation, you gave pragma solidity 0.8.0;  contract EIP712VerifyingContract {   function eip712Domain() external view returns (       bytes1 fields,       string memory name,       string memory version,       uint256 chainId,       address verifyingContract,       bytes32 salt,       uint256[] memory extensions   ) {       return (           hex\"0d\", // 01101           \"Example\",           \"\",           block.chainid,           address(this),           bytes32(0),           new uint256[](0)       );   } }  which shows salt as 0. Can you give more real example of how salt will be generated from contract function? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.836363636363636
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "27",
                    "likes": "0",
                    "time": "04/11/2022-16:45:02",
                    "content": "This EIP makes no statements about the semantics of salt. All that EIP-712 says is:  a disambiguating salt for the protocol. This can be used as a domain separator of last resort.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "28",
                    "likes": "0",
                    "time": "04/11/2022-17:14:20",
                    "content": "    frangio:  a disambiguating salt for the protocol. This can be used as a domain separator of last resort.   I see. Maybe just the name salt is confusing, but I can understand the 712\u2019s using it as a last resort to prevent replay attack if chainId is not sufficient to disambiguate\u2026  QQ: Clarify computation of domainSeparator, or provide an interface for implementors to decide domainSeparator = hashStruct(eip712Domain)  to make it more convenient for client to directly use. This is because with the field uint256[] memory extensions, I assume there is two ways. to interpret the potential computation of domainSeparator:   {fields, name, version, chainId, contractAddress,salt} // Original EIP-712  {fields, name, version, chainId, contractAddress,salt, extensions}  // EIP-712 plus extensions introduced in EIP-5267  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.953125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "29",
                    "likes": "0",
                    "time": "04/11/2022-20:41:06",
                    "content": "If extensions are present they must be included in the domain (but the field would not be an extensions field, it would be other fields defined by the extensions). If this is not clear I can add an example. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 4.708333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "30",
                    "likes": "0",
                    "time": "14/12/2022-19:22:03",
                    "content": "Got it. thank you @frangio . I am in strong support of this EIP-5267. Thanks for this proposal. Is there any plan soon for OZ to expose what the methods are exposed in EIP-5267? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving entirely positive feedback on proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.583333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "31",
                    "likes": "0",
                    "time": "14/12/2022-19:43:19",
                    "content": "@frangio @wighawag , inspired by your discussion about event vs function, given the lesson we learn in ERC721Metadata, it would be nice for an event could be used to notify when an update occurs to of EIP-712Domain ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 8.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "32",
                    "likes": "0",
                    "time": "15/12/2022-18:56:21",
                    "content": "    xinbenlv:  given the lesson we learn in ERC721Metadata   Can you share some reference to what you mean? In general, it may not be possible to emit an event when the domain changes. For example, if the chain forks with a new chain id the EIP-712 domain immediately changes and there is no opportunity to trigger that event, unless triggered manually after the fact. That said, it could still be useful to have an optional event. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.173863636363636
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "33",
                    "likes": "0",
                    "time": "15/12/2022-20:01:51",
                    "content": " Can you share some reference to what you mean?  ERC721Metadata is a good interface, a little pity that it didn\u2019t define a way to trigger update, hence EIP-4906 is drafted and serve as a complement to it.  In general, it may not be possible to emit an event when the domain changes. For example, if the chain forks with a new chain id the EIP-712 domain immediately changes and there is no opportunity to trigger that event, unless triggered manually after the fact.  Yes, that\u2019s the case, it won\u2019t emit an event. It will aways need to be executed TX in order to emit the event.  That said, it could still be useful to have an optional event.  Yes, exactly, this is what I mean. An optional event for implementor to have an option to notify callers who care about change of domain. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.261931818181819
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "34",
                    "likes": "0",
                    "time": "10/01/2023-03:18:18",
                    "content": "I\u2019ve added an explanation of the use of the extensions array, and also added an optional event to emit when the domain changes. (EIP-5267: Clarify use of extensions and add event by frangio \u00b7 Pull Request #6297 \u00b7 ethereum/EIPs \u00b7 GitHub) I did some more research on backwards compatibility and put together a small app to show that it is possible to reconstruct the EIP-712 domain of contracts that don\u2019t impement this EIP by guessing the domain. https://eip5267.vercel.app I added a minor comment about this in the EIP (I don\u2019t want to go into detail about it in the spec) and requested the move into Last Call.   github.com/ethereum/EIPs         Update EIP-5267: Move to Last Call   ethereum:master \u2190 frangio:5267-backwardscompat              opened 06:25PM - 08 Jan 23 UTC                 frangio               +4 -2           ",
                    "links": [
                        "https://eip5267.vercel.app",
                        "https://github.com/ethereum/EIPs/pull/6300",
                        "https://github.com/ethereum/EIPs/pull/6300",
                        "https://github.com/frangio",
                        "https://github.com/ethereum/EIPs/pull/6300/files"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.166666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "35",
                    "likes": "0",
                    "time": "10/01/2023-15:24:13",
                    "content": "Congrats on moving to last call.  Cross posting some editorial questions hoping to get @frangio 's clarification I left on github PR  Discussion: can you share the rationale of extensions being format as uint256 instead of bytes32 ?  Extensions are described by their EIP numbers because EIP-712 states: \u201cFuture extensions to this standard can add new fields [\u2026] new fields should be proposed through the EIP process.\u201d  Here EIP-712 didn\u2019t specify what format of fields will be, so it\u2019s open to future designer to design, EIP-5267 is one of such future design. Q1. Could author share your thoughts into why choose the format of extensions an uint256[] vs bytes32[] or  generally bytes? This is one of the problem that EIP-5750 is trying to address and thus when EIP-5267 made a design choice that\u2019s different, I\u2019d love to learn the rationale and understand it better. When using uint256[] and described in EIP-5267 as it needs to be a EIP number, does it mean only EIP number will be allowed in the extension as a way to provide extending information? Will EIP number be sufficient? Do you anticipate some of these elements could be re-purposed in the future? Q2. In the reference implementation,     return (           hex\"0d\", // 01101           \"Example\",           \"\",           block.chainid,           address(this),           bytes32(0),           new uint256[](0)       );  and also in javascript   if (extensions.length > 0) {     throw Error(\"Extensions not implemented\");   }  Is it intentional that in author\u2019s perspective the extension shall at least have one element? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.222787081339712
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "36",
                    "likes": "0",
                    "time": "10/01/2023-18:19:43",
                    "content": "    xinbenlv:  Could author share your thoughts into why choose the format of extensions an uint256[] vs bytes32[] or generally bytes   The extensions array has a specific meaning. It\u2019s an array of EIP numbers. There is no reason to encode this as bytes32[] or bytes.     xinbenlv:  When using uint256[] and described in EIP-5267 as it needs to be a EIP number, does it mean only EIP number will be allowed in the extension as a way to provide extending information   Yes. This follows the EIP-712 specification:  Future extensions to this standard can add new fields with new user-agent behaviour constraints. User-agents are free to use the provided information to inform/warn users or refuse signing. Dapp implementers should not add private fields, new fields should be proposed through the EIP process.  This means that applications that want to use new fields should do so by creating an EIP. The resulting EIP number would go in the extensions array. Please also see the new code under Reference Implementation showing what supporting an extension EIP would look like.     xinbenlv:  Is it intentional that in author\u2019s perspective the extension shall at least have one element?   No, there are no constraints on the number of elements. The reference Solidity implementation returns an empty array, and this is expected to be the most common value. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.202452153110047
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "37",
                    "likes": "0",
                    "time": "10/01/2023-18:40:08",
                    "content": "    frangio:  Future extensions to this standard can add new fields with new user-agent behaviour constraints. User-agents are free to use the provided information to inform/warn users or refuse signing. Dapp implementers should not add private fields, new fields should be proposed through the EIP process.   When EIP-712 says \u201cnew fields should be proposed through the EIP process.\u201d this means there will be exceptions. This means, when you choose \u201cEIP numbers\u201d as the sole possible value of extensions  it rule out all exceptions that (1) compliant EIP-712 implementations may choose to ignore the \u201cshould\u201d wording soft spec of EIP-712 and introduce behavior at their sole discretion without proposing an EIP or (2) the EIP process stops functioning like the YellowPaper or (3) EIP-number stops being a number but some chars like softly proposed by @Pandapip1 and a few others in the debate of how EIP numbers shall be assigned and {revoked, reassigned, corrected}. it also rule out the case when the EIP number is the only granularity. For example, when used with complicated EIP (EIP-4337), it couldn\u2019t specify a sub interface or sub behavior in that EIP or other more complicated EIPs. For example, in a cross-chain validation scenario (EIP-5164 may lead to), EIP or implementer may want to specify a chain-pair in some case and EIP-5267 will be too restrictive (see footnote #1).  If this is indeed the intention of EIP-5267, sure this can be a design choice author makes. But I like to flag this as explicit and suggest we spell out rationales leading to these decisions.  Footnote #1: An counter example is that EIP-1271 doesn\u2019t have an extension field, therefore we end-up needing EIP like EIP-6066 to specify a new method and all developers need to re-establish a consensus to follow or not follow that new function. function isValidSignature(uint256 tokenId, bytes32 hash, bytes calldata data)  Follow up the debate of EIP-1271 lacks a tokenId or general extraData field in the EIP-5750 ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/6066"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.228822314049587
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "38",
                    "likes": "0",
                    "time": "27/01/2023-19:32:51",
                    "content": "I reached out to the author of eip712-codegen @danfinlay to consider adding this uint256 extensions field which it currently don\u2019t have. [Early feedback needed] Propose to adding extension fields by xinbenlv \u00b7 Pull Request #8 \u00b7 danfinlay/eip712-codegen \u00b7 GitHub so that all the compliant contracts of EIP-5267 could be supported by eip-712-codegen. Note: this is en example why I feel we need EIP-5750 to help people come to a consistent way to represent extension. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.583333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "39",
                    "likes": "0",
                    "time": "27/01/2023-19:41:18",
                    "content": "Or maybe what really needs to be considered is the represent the extensibility of EIP-712, which you wrote Additionally, the type of the EIP712Domain struct needs to be extended with the subdomain field. This is left out of scope of this reference implementation.  so that subdomains could be included. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "40",
                    "likes": "1",
                    "time": "27/01/2023-22:06:21",
                    "content": "From my comment in eip712-codegen#8: I would recommend ignoring extensions for now. They are specified in the EIP for future proofing but so far no extensions have been defined. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "41",
                    "likes": "1",
                    "time": "09/02/2023-20:00:43",
                    "content": "This EIP is now Final ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xinbenlv",
                    "index": "42",
                    "likes": "1",
                    "time": "09/02/2023-22:00:35",
                    "content": "Congrats @frangio ~ this is a big step forward making 712 even more adopted! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.5625
                }
            ]
        }
    ],
    "group_index": "1827"
}