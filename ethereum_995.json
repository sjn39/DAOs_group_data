{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-712-eth-signtypeddata-as-a-standard-for-machine-verifiable-and-human-readable-typed-data-signing/397",
            "title": "EIP-712: eth_signTypedData as a standard for machine-verifiable and human-readable typed data signing ",
            "index": 397,
            "category": [
                "EIPs"
            ],
            "tags": [
                "eip-712"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/dekz",
                    "index": "1",
                    "likes": "4",
                    "time": "18/05/2018-02:36:30",
                    "content": "For on-going discussion and feedback for EIP712. Draft is available here  1*CQGgWQxexBzc66zDygAJZQ.png1600\u00d71121 226 KB   Left old, new right  ",
                    "links": [
                        "https://ethereum-magicians.org/uploads/default/original/1X/293c7a7103091711b80cae1ddf5dd3e7afe3bd63.png"
                    ],
                    "GPT-summary": "The author is seeking feedback and discussion on the EIP-712 proposal, which aims to establish a standard for machine-verifiable and human-readable typed data signing. The post includes a link to the draft of the proposal.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "None",
                        "None",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.768398268398268
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/interfluidity",
                    "index": "2",
                    "likes": "1",
                    "time": "09/08/2018-20:25:49",
                    "content": "Just a minor point that should probably be cleaned up. In the draft spec\u2026  Returns DATA: Signature. As in eth_sign it is a hex encoded 129 byte array starting with 0x. It encodes the r, s and v parameters from appendix F of the yellow paper in big-endian format. Bytes 0\u202664 contain the r parameter, bytes 64\u2026128 the s parameter and the last byte the v parameter. Note that the v parameter includes the chain id as specified in EIP-155.  But EIP-155 Chain IDs can be larger than a byte (elsewhere in the spec it is encoded as uint256). Clients probably should not rely on a fixed length response of 129 bytes. Perhaps \u201ca hex encoded byte array of at least 129 bytes\u2026\u201d ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.821428571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Recmo",
                    "index": "3",
                    "likes": "1",
                    "time": "10/08/2018-08:33:44",
                    "content": "This is copied almost verbatim from the official Ethereum JSON RPC. Personally, I think packing the three values into a hex string is a bad idea and I would rather have a structure with v, r, s attributes. Given the elsewhere mentioned confusion about v,r,s vs. r,s,v order and the above mentioned assumptions on the size of v I\u2019m inclined to go for the object approach instead of packed binary. What do you think? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 3.8333333333333335
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/interfluidity",
                    "index": "4",
                    "likes": "1",
                    "time": "10/08/2018-08:52:12",
                    "content": "I agree that it\u2019d probably be clearer to return a JSON object. Labeled fields eliminate a lot of ambiguity. If you don\u2019t do this, you\u2019ll have to keep it in r,s,v order given the variable length of v. (And that\u2019s a bit weird, since transactions are signed in v,r,s order.) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 2.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/perpetualescap3",
                    "index": "5",
                    "likes": "0",
                    "time": "04/09/2018-13:30:32",
                    "content": "What is the purpose of the domain separator?  The domain separator prevents collision of otherwise identical structures. It is possible that two DApps come up with an identical structure like Transfer(address from,address to,uint256 amount) that should not be compatible. By introducing a domain separator the DApp developers are guaranteed that there can be no signature collision.  What I mean is, should it be verified \u201cagainst\u201d anything? Great work by the way, @Recmo! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.145833333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "6",
                    "likes": "0",
                    "time": "26/09/2018-14:28:46",
                    "content": "Hello, I don\u2019t exactly know where to ask questions about EIP\u2019s, so I\u2019m trying my luck here \u2026 At the end of EIP-712\u2019s draft, there is a link toward example files (.sol for the smart contract and .js for the tester). In the smart contract, hashes are computed using keccak256(abi.encode(...)). I am used to doing keccak256(abi.encodePacked(...)), which is slightly different when dealing with addresses and correspond to web3.utils.soliditySha3. using encodePacked and soliditySha3 I managed to have both part of my application compute hashes the same way, but in order to benefit from the EIP full potential I have to make sure other entities (like metamask) will be able to reproduce my hashes. The thing is, encodePacked can be nested, which is a feature I need due to my struct having to much members \u2192 too much local variable to do a single abi.encode. I saw in the EIP that this is discussed as \u201calternatives\u201d \u2026 and that the encoding should be feaseable in place \u2026 but not being fluent in assembly, I\u2019m not very confident in my ability to do the hashStruct myself \u2026 ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.571611721611721
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "7",
                    "likes": "1",
                    "time": "28/09/2018-10:22:50",
                    "content": "Hi, I have just heard that this EIP is getting finalized. I would like to propose an important change: It has been discussed briefly before and was the reason domain separator came into being in the first place but I would like to bring back the possibility again to add the \u201corigin\u201d back into the data being signed. see https://github.com/ethereum/EIPs/pull/712#issuecomment-330501545 and https://github.com/ethereum/EIPs/pull/712#issuecomment-364495160 This would allow smart contract to ensure the user has signed the data in a set of allowed origin. The web3 signer would be in charge to add the origin data. This is not a data that can be set independently so that the user can\u2019t be cheated in thinking the data is for another purpose. Note that this extra data can only increase the security of the proposal. ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/712#issuecomment-364495160"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.480158730158731
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Alko89",
                    "index": "8",
                    "likes": "3",
                    "time": "24/03/2019-11:25:39",
                    "content": "Hi Has anyone managed to verify typed data with an array? Most of examples I found still don\u2019t define arrays, not even the reference example: https://github.com/ethereum/EIPs/blob/master/assets/eip-712/Example.js#L102 How would one verify a signature with data structured like for example:     struct Action {         uint8 kind;     }      struct Order {         address sender;         Action[] actions;     }  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "9",
                    "likes": "3",
                    "time": "24/03/2019-11:44:47",
                    "content": "I discussed that with @remco at EthCC, and he confirmed that the process for hashing array (fixed or arbitrary size) isn\u2019t formally described yet. This is one of the last points that need addressing before ERC712 can be finalized. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Alko89",
                    "index": "10",
                    "likes": "2",
                    "time": "24/03/2019-12:39:37",
                    "content": "What can I do to help finalize it? I\u2019m not sure how to tackle this. For example how to define typehash for the struct with arbitrary size array? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "11",
                    "likes": "0",
                    "time": "24/05/2019-14:16:46",
                    "content": "iExec is using ERC712 for active production on mainnet since V3 was deployed in on may 15th. I\u2019m sure we are not the only one. It\u2019s high time this ERC moves toward finalization. I believe one of the last obstacle is the formalisation of dynamic array hashing (which is something iExec will need for V4, so I\u2019m trice motivated to get that sorted out). Only then will we have Ledger (and other wallet) support. @Recmo , as far as I understand, you are the ERC712 leader (at least you are to me) \u2026 do you have any opinion on that ? I\u2019d love to contribute to move this ERC forward but I don\u2019t feel like I have the weight needed to lead it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.318939393939393
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "12",
                    "likes": "1",
                    "time": "27/05/2019-16:46:51",
                    "content": "There are at least three issues to resolve / take decision on for EIP-712 in my opinion:  array hashing (as you mentioned) the origin proposal (including the non-interactive signature bit)  : see comments on EIP-712 and my blog post Note that while in the latter comments from me and @Recmo  a solution involving a special envelope is mentioned. I actually disagree with it since it would force standards built on top of EIP-712 to choose whether they support origin or not. Origin should be part of the raw EIP-712 proposal like chainId is chainId and blockNumber pair for replay protection on minority-led forks => if blockNumber is included, they can\u2019t be part of a static domain separator as blockNumber would be updated frequently, see discussion on EIP-1344, EIP-1959 and EIP-1965   ",
                    "links": [
                        "https://medium.com/@wighawag/3-proposals-for-making-web3-a-better-experience-974f97765700",
                        "https://ethereum-magicians.org/t/eip-1344-add-chain-id-opcode/1131",
                        "https://ethereum-magicians.org/t/eip-1959-valid-chainid-opcode/3170",
                        "https://ethereum-magicians.org/t/eip-1965-valid-chainid-for-specific-blocknumber-protect-all-forks/3181"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.578983516483516
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "13",
                    "likes": "0",
                    "time": "28/05/2019-19:56:51",
                    "content": "    wighawag:  chainId and blockNumber pair   I\u2019m not sure where the pair came from, but chainId should be sufficient by itself as it should not change very often. Even if a rotating chainId process is add to hard fork upgrades, it would still change less than 1-2 times per year, and that is something easily tracked and submitted separately by the application, depending on the methodology used. As stated in EIP-1344\u2019s discussion, some applications may not require historical chainId at all, or may desire an application-specific way of updating it for increased safety of the application. We\u2019re still unsure which methodology will be chosen in Istanbul, so I would caution against premature optimization here. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.9375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "14",
                    "likes": "0",
                    "time": "28/05/2019-21:10:22",
                    "content": "I agree that if chainId was the only thing to change, we would be fine. That is why I mention the (chainID, blockNumber) pair. The need for blockNumber was discussed as part of our conversations. It is explained here : EIP-1959 Valid ChainID opcode and in the rationale of EIP-1965 It is to allow fork led by minority to not suffer from replay issues from the majority inaction (since the current chainId from the majority chain would be a past chainId on the minority chain). The blockNumber at which the message was signed can ensure replay protection by making smart contract disregard message signed at a blockcNumber where a chainID is a past one. with EIP-1965 it simply expressed this way : require(validChainId(message.chainId, message.blockNumber), \"invalid message on that chain\");  And by letting wallet setting the blockNumber as part of EIP-712, they protect users from replay issues. A protection that EIP-1344 can\u2019t handle properly since the required caching mechanism would leave a gap.     fubuloubu:  As stated in EIP-1344\u2019s discussion, some applications may not require historical chainId at all, or may desire an application-specific way of updating it for increased safety of the application.   While it is technically true that they do not require it to function, they require it to function as expected. Indeed, smart contract that disregard past chainID will render their user dependent on the message submission timing. For example, a user could not rely anymore on being able to delay a message, since as soon as a hardfork happen, the user would have to sign the message again. This is less than ideal and why I think we should consider all application as benefiting from respecting past chainIDs. But we should probably discuss that in EIP-1344 discussion thread if my comments there were not clear enough. ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-1965"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is seeking feedback",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.336466165413533
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "15",
                    "likes": "0",
                    "time": "28/05/2019-21:27:32",
                    "content": "    wighawag:  The need for blockNumber was discussed as part of our conversations.   It\u2019s a requirement if 1959 or 1965 is adopted. It is not if 1344 is adopted instead. I think the decision to update this specification relies on the outcome of what is adopted in that case.     wighawag:  For example, a user could not rely anymore on being able to delay a message, since as soon as a hardfork happen, the user would have to sign the message again   For certain use cases, this is acceptable. For some, it is actually more ideal. An example of the former is the meta-transaction use case, where chainId is used as a domain separator for offline signing. These transactions are meant to be resolved in under a day, so if an older value of chainId is used, it is acceptable to ask the user to re-submit with the new value. An example of the later is Plasma Transactions. In that use case, it is required that the value of chainId chosen aligns with the value that the operator uses in their block submission summary transaction, therefore it is important that the operator has control over what value is accepted by the contract (can be updated trustlessly, during the block submission transaction). chainId might be updated in between submissions, therefore it is important that the operator only accept submissions with the correct value of chainId that they will upload, and reject others. Having it be either/or would be more dangerous. We can continue this conversation in the EIP-1344 thread, as it relates to prior discussion we\u2019ve had on this exact topic. My point was not to prematurely optimize for an EIP that is not yet confirmed to be in the next hard fork, as we are still figuring out which path will be chosen. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.965458152958153
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "16",
                    "likes": "1",
                    "time": "28/05/2019-22:05:19",
                    "content": " An example of the former is the meta-transaction \u2026 it is acceptable to ask the user to re-submit with the new value.  Acceptable but not desirable  An example of the later is Plasma Transactions. \u2026the operator has control over what value is accepted by the contract (can be updated trustlessly, during the block submission transaction).  As already mentioned in our previous conversation, such chainId information can be provided by other means. It does not need to be coupled with EIP-712 where the role of chainId is replay protection     fubuloubu:  We can continue this conversation in the EIP-1344 thread, as it relates to prior discussion we\u2019ve had on this exact topic. My point was not to prematurely optimize for an EIP that is not yet confirmed to be in the next hard fork, as we are still figuring out which path will be chosen.   I agree, the reason I posted my 3 points here is that I realized not everywhere is aware of the current dicussion about chainID. EIP-712 was designed before that.  I think the decision to update this specification relies on the outcome of what is adopted in that case.  My goal was not to update the spec, it was just to bring awareness to the current discussion. Did not want EIP-712 to get finalised without that info first. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.234343434343435
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/PhABC",
                    "index": "17",
                    "likes": "0",
                    "time": "29/05/2019-14:31:38",
                    "content": "    Amxx:  I discussed that with @remco at EthCC, and he confirmed that the process for hashing array (fixed or arbitrary size) isn\u2019t formally described yet. This is one of the last points that need addressing before ERC712 can be finalized.   Can\u2019t we simply re-use the EIP-712 hashStruct for byte arrays? So long as one of the contract down the line can interpret this embeded hashStruct, the original contract called doesn\u2019t need to know what this hashStruct is. It will simply take the hash of that byte array before doing an EIP-712 hash, like specified in the spec and can then pass that bytes array to another contract, which understands what the structure of that bytes array is. We could also use the functions structure in some instances, where the first 4 bytes are a \u201cfunction signature\u201d (e.g. bytes4(keccak256(buyTickets(unit256 _amount)) and the rest of the bytes array would be the encoded arguments for that \u201cfunction signature\u201d. Of course, the bytes4 don\u2019t need to be functions per say either. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is seeking feedback",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.409722222222221
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "18",
                    "likes": "0",
                    "time": "04/06/2019-08:16:55",
                    "content": "    PhABC:  Can\u2019t we simply re-use the EIP-712 hashStruct for byte arrays? So long as one of the contract down the line can interpret this embeded hashStruct, the original contract called doesn\u2019t need to know what this hashStruct is. It will simply take the hash of that byte array before doing an EIP-712 hash, like specified in the spec and can then pass that bytes array to another contract, which understands what the structure of that bytes array is.   Reusing the logic of byte arrays for uint[], bytes32[] or any other array of \u201cnative types <= 1 word\u201d is ok, but it goes against the whole proposal for arrays of struct (such as a Recipient[] where Recipient would be a struct with multiple entries). I believe the logic would be to hash each entry, turning the Recipient[] into a bytes32[] and then hashing the bytes32[]. The drawback is that this cannot be done in place. In the end, it\u2019s pointless what I believe the logic should or should not be, as long as we have ONE way to do it that is part of the standard ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.170940170940171
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cag",
                    "index": "19",
                    "likes": "2",
                    "time": "14/06/2019-19:35:56",
                    "content": "Here\u2019s maybe a way to do general array hashing: https://github.com/MetaMask/eth-sig-util/pull/54  Arrays of atomic types have been encoded as a hash of its contents, where its contents are word-aligned according to the type. Arrays of dynamic types have been encoded as a hash of each element\u2019s hash. Arrays of structs retain their encoding as a hash of its contents\u2019 concatenated hashStructs. Arrays of arrays are encoded recursively, as a hash of the contained arrays\u2019 hash encodings concatenated.   Additionally, how should clients handle missing values in an eth_signTypedData structure? eth-sig-util currently skips over fields which are missing, but it uses the same type hash, meaning a struct like Foo(uint256 bar,bytes32 baz) may only have hashStruct(typeHash(Foo) . baz) if bar is undefined on the message. In the PR, because it was simpler to do so in the rewrite, I\u2019ve made every field specified in the typeHash required, but Dan wanted to know if there was a preference for the optional behavior. Note that this is different from requiring fields like string name to be specified in the EIP712Domain struct. I\u2019m asking about the behavior once the type has been specified whether or not those fields specified should be considered optional. Personally, I think this should be an error, since using the Foo example, how do you know whether second part of the hashStruct payload refers to bar or baz?  I have a feeling that maybe asking to limit the scope of EIP-712 and introducing this in an EIP extension may be the way to go, as I may have heard of some hardware vendors claiming EIP-712 support, where for them it might actually mean something along the lines of \u201cflat structures containing primitive types\u201d support (I think somebody might have mentioned that being a EIP finalization target). If so, it would be good to get the opinion of relevant stakeholders in this discussion, as I would guess it wouldn\u2019t be feasible to upgrade existing hardware that\u2019s out there claiming EIP 712 support, but I haven\u2019t read through the original discussion thread on Github yet, as it\u2019s pretty long\u2026 It could be that it\u2019s just the crypto primitives being implemented in hardware though, and that software support for this may be added after the fact, in which making this a patch to the EIP could make sense instead.  I\u2019ve done some looking into whether or not this extension can be added to hardware, and it seems that for the majority of the cases, hardware support is for building blocks, and support just has to be added on the Ethereum app level in the case of Ledger or at the firmware level in the case of Trezor. Since this is the case, and because the recent discussion seems to imply dynamic and nested types will be part of the final spec for this EIP, I\u2019ll write an update to this EIP accordingly.  I\u2019ve written a PR to ERC-712 here. In addition to the changes quoted above, I\u2019ve made all specified struct members mandatory except for structs. The reason why structs are not mandatory is because I\u2019ve realized that the standard intended for recursive types to be possible. As an example, consider: struct Node {     bytes data;     Node next; }  This was a valid type in the standard, but it wasn\u2019t clear how to encode instances of this type. With mandatory struct members, this type would not be possible to express. I\u2019ve taken the liberty to state that given the example, the next field may either be encoded recursively as its structHash, or as bytes32(0) when expressing its absence from an instance. ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/2190/files"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.212962962962963
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/PhABC",
                    "index": "20",
                    "likes": "1",
                    "time": "25/10/2019-13:25:07",
                    "content": "Regarding ABIv2 for encodeData, I was investigating and asked Chris from the solidity dev team what he thought. Here is his response ;  image.png2346\u00d7542 116 KB  Any insight @Recmo @dekz ? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/maurelian",
                    "index": "21",
                    "likes": "1",
                    "time": "25/10/2019-15:47:20",
                    "content": "Link for the lazy: https://eips.ethereum.org/EIPS/eip-712 ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 3.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fubuloubu",
                    "index": "22",
                    "likes": "1",
                    "time": "26/10/2019-04:56:06",
                    "content": "That\u2019s problematic. It\u2019s a good thing there isn\u2019t much uptake of this standard yet, although it is very useful and it would be good to clear any issues up. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.741666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/3esmit",
                    "index": "23",
                    "likes": "0",
                    "time": "31/12/2019-06:33:56",
                    "content": "In case of a fork, the signatures would only work in the fork that didn\u2019t changed chainId, to solve that, please use EIP-1344 in the 712 standard. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/adridadou",
                    "index": "24",
                    "likes": "0",
                    "time": "02/12/2020-13:11:11",
                    "content": "Hi everyone, I am not sure where is the best place to ask this so I\u2019m trying here. I\u2019m looking at EIP-712 v4 and the scheme to encode arrays. eth-sig-util is managing it well (and I guess correctly) on the client side but I can find no example on how to do that in solidity. My understanding is that encoding an array of 3 strings arr = [\u201c1\u201d, \u201c2\u201d, \u201c3\u201d] is equialent to keccak256(abi.encode(keccak256(abi.encodePacked(arr[0])), keccak256(abi.encodePacked(arr[1])), keccak256(abi.encodePacked(arr[2]))) So first thing, is this correct? if yes, how can I implement that in solidity? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.666666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "25",
                    "likes": "1",
                    "time": "04/12/2020-09:22:18",
                    "content": "I\u2019m sure you can do better / in place by writing it in assembly, but here is a \u201cquick\u201d answer: function hash(string[] calldata array) internal pure returns (bytes32 result) {     bytes32[] memory _array = new bytes32[](array.length);     for (uint256 i = 0; i < array.length; ++i) {         _array[i] = keccak256(bytes(array[i]));     }     result = keccak256(abi.encodePacked(_array)); } ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.350649350649351
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nlordell",
                    "index": "27",
                    "likes": "5",
                    "time": "05/03/2021-10:27:40",
                    "content": "Hey everyone, I just wanted to bring up what I believe to be a minor issue in the eth_signTypedData JSON RPC specification. Specifically, it doesn\u2019t go into much detail about the JSON representation of the message object and the supported Solidity primitive values. For example, what is an acceptable encoding for a uint32? Are all 100, 1e2, \"100\", \"0x64\" accepted? Should they be treated like QUANTITIES so only \"0x64\" is valid? In this regard, MetaMask for example, seems to accept both hexadecimal and decimal strings for uint256. While I don\u2019t have any particular suggestion on what the supported formats should be, I do believe it should be specified in the EIP. ",
                    "links": [
                        "https://eth.wiki/json-rpc/API#hex-value-encoding"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.395833333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "28",
                    "likes": "0",
                    "time": "31/08/2021-07:16:48",
                    "content": "@Recmo @dekz Do you need help finishing this spec? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "29",
                    "likes": "0",
                    "time": "02/09/2021-18:26:33",
                    "content": "How are clients expected to know what parameters to use in the domain separator? This is easy when signing for a particular contract with a known domain separator, but there is no standard mechanism for use cases where it is not known beforehand. For a concrete example, people have run into this problem in EIP-2612 (ERC20 permit). Some tokens include the version parameter (OpenZeppelin, USDC), others don\u2019t  (COMP), and those who do may use different values (OpenZeppelin: default \"1\", USDC: \"2\"). There is no way to query the contract if version is used and with what value. EIP-2612 includes a DOMAIN_SEPARATOR getter, but it would be wrong to use this value without verifying that it corresponds to the current chain id, for which all the parameters are necessary. I imagine any other EIP that builds on EIP-712 signatures will run into the same issue. The only solution right now is to make it a part of those EIPs what the domain separator is supposed to look like, but I think it would be better to include a standard mechanism either in EIP-712 or in a complementary EIP. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.270238095238096
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wchargin",
                    "index": "30",
                    "likes": "1",
                    "time": "28/09/2021-00:51:16",
                    "content": "The current draft of EIP-712 says:  Specification of the eth_signTypedData JSON RPC The method eth_signTypedData is added to the Ethereum JSON-RPC. The method parallels eth_sign. eth_signTypedData The sign method calculates an Ethereum specific signature with: sign(keccak256(\"\u0019Ethereum Signed Message:\\ \" + len(message) + message))).  I don\u2019t understand the last line. Isn\u2019t this supposed to be sign(keccak256(\"\u0019\u0001\" + domainSeparator + hashStruct(message)))  instead, as described in the \u201cSpecification\u201d section above? The listed definition describes eth_sign, not the new eth_signTypedData, and does not seem consistent with Ethers\u2019s TypedDataEncoder.encode (as used in the Wallet implementation of Signer._signTypedData), nor with OpenZeppelin\u2019s ECDSA.toTypedDataHash. Is this a copy-paste error in the spec, or am I missing something? ",
                    "links": [
                        "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/1b27c13096d6e4389d62e7b0766a1db53fbb3f1b/contracts/utils/cryptography/ECDSA.sol#L216-L218"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.133116883116883
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/barf",
                    "index": "31",
                    "likes": "0",
                    "time": "17/10/2021-14:36:10",
                    "content": "Anyone has any examples of verifying eth_signTypedData_v4 in Solidity? I\u2019m using recoverTypedSignature_v4 from eth-sig-util and it works great but when I try to verify the signature with openzeppelin\u2019s EIP712 draft, it returns a different address. Draft EIPs - OpenZeppelin Docs Of course I also tried to write it myself from the spec, but same results. It would be nice if this proposal was finalized because then it would be much more usable. I could only get v3 to work\u2026 ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.583333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "32",
                    "likes": "1",
                    "time": "16/11/2021-20:27:24",
                    "content": "EIP-2613 (ERC20 Permit) is blocked from becoming a Final EIP because it has a dependency on EIP-712 which is still a Draft. Are the EIP authors interested in moving EIP-712 to Final? @Recmo @dekz ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/D3v",
                    "index": "33",
                    "likes": "1",
                    "time": "12/04/2022-20:46:16",
                    "content": "Any update about this proposal? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "34",
                    "likes": "1",
                    "time": "15/07/2022-19:37:57",
                    "content": "    frangio:  How are clients expected to know what parameters to use in the domain separator?   I\u2019ve gone ahead and created an EIP to tackle this issue I mentioned. Please take a look and let me know your thoughts.   Ethereum Improvement Proposals   EIP-5267: Retrieval of EIP-712 domain A way to describe and retrieve an EIP-712 domain to securely integrate EIP-712 signatures.          EIP-5267: Retrieval of EIP-712 domain EIPs       Discussion for EIP-5267.     This EIP complements EIP-712 by standardizing how contracts should publish the fields and values that describe their domain. This enables applications to retrieve this description and generate appropriate domain separators in a general way, and thus integrate EIP-712 signatures securely and scalably.     ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-5267",
                        "https://ethereum-magicians.org/t/eip-5267-retrieval-of-eip-712-domain/9951",
                        "https://eips.ethereum.org/EIPS/eip-712"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal"
                    ],
                    "Sentiment": 6.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "35",
                    "likes": "1",
                    "time": "25/07/2022-12:40:32",
                    "content": "EIP-712 is now in Last Call. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                }
            ]
        }
    ],
    "group_index": "995"
}