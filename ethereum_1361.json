{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/a-case-for-a-simpler-alternative-to-eip-3074/6493",
            "title": "A case for a simpler alternative to EIP 3074 ",
            "index": 6493,
            "category": [
                "EIPs"
            ],
            "tags": [
                "signatures",
                "eip-3074"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "1",
                    "likes": "4",
                    "time": "16/06/2021-02:13:21",
                    "content": " A case for a simpler alternative to EIP 3074 The AUTH/AUTHCALL mechanism is very appealing from a developer\u2019s point of view.  It gives anyone the ability to come up with an invoker that can implement different batching strategies (e.g. supporting multiple nonces for better parallelism), gas abstraction models, complex account abstraction methods, etc. The flexibility comes from being completely unopinionated about how this mechanism is used.  Instead of requiring the developer to conform to a particular pattern, we require the user to sign an invoker-parsed commit hash, and let each developer set discretionary restrictions based on the commit. However, this flexibility comes at an extremely high security cost.  I would like to make a case for a simpler alternative that would get us most of the benefit at a much lower risk. Why is signing an AUTH commit riskier than signing a transaciton to any other buggy/malicious contract? When signing a transaction to a contract, the user takes a known risk of losing assets controlled by that contract.  The user could sign an approval transaction to an ERC20 contract, approving a malicious DEX contract. The malicious DEX contract could then withdraw the user\u2019s entire balance of that ERC20.  But\u2026 it cannot withdraw the user\u2019s tokens from other ERC20 contracts without requiring specific approvals.  Nor can it do anything else on behalf of the user.  The approval is specific. EIP 3074, on the other hand, requires the user to sign a blank cheque and assume that the invoker is honest and not buggy.  A malicious/buggy invoker could do anything on behalf of the user - access any asset owned by the user, vote on behalf of the user, take ownership of any contract owned by the user, etc. Worse yet, the invoker can do it now and in the future, because the nonce implementation is controlled by the invoker.  A buggy/malicious implementation of the nonce logic could allow replaying the user\u2019s past transactions.  Combined with buggy logic of other parts of the commit verification, it could be used to perform any future action on behalf of the user.  Even if the bug is discovered, the user has no way to revoke that blank cheque.  The EOA is compromised forever. Writing a correct invoker is tricky and we are almost certain to get it wrong occasionally.  The non-exhaustive list of checks/pitfalls/conditions that invokers should be wary of at the end of the EIP gives us a glimpse of that.  This list will inevitably grow, possibly through a painful discovery process. Furthermore, a malicious actor could implement a honest-looking invoker with an intentional subtle bug which will be exploited after a lot of EOAs AUTH that invoker. The attack may go unnoticed for a long time if it doesn\u2019t steal from the user directly or immediately. Governance hijacking example  EveSwap, a malicious DEX, implements an invoker for its users.  It sponsors their gas through its airdropped EVE token and batches their approve+transfer transactions. EveSwap\u2019s invoker appears honest and never steals user tokens because that would be discovered immediately. Users are happy.  Trades are cheap and successful, nothing bad happens for months. However, every time someone trades AliceSwap governance tokens, ALI, it self-delegates the user\u2019s AliceSwap voting rights. Once delegation crosses a threshold, EveSwap hijacks AliceSwap through a governance proposal.  EveSwap users are unlikely to notice this process because their trades are always successful, but the end result is devastating for AliceSwap. Cross-chain replay example The EIP rightly suggests that the commit should cover chainid.  However, this is not enforced by the protocol, just the invoker.  An invoker with the same address on another chain might skip this check (or any check for that matter).  EveSwap lives on the EVM-compatible BobSpongeChain, which also supports EIP 3074.  It deploys a honest invoker there. Users trade on BobSpongeChain using the invoker, and then use a bridge to move their assets to Ethereum. EveSwap uses the same deployment key to deploy a different invoker on Ethereum, at the same address.  The Ethereum invoker doesn\u2019t check the commit at all.  It just checks ownerOnly and acts as a generic AUTH/AUTHCALL proxy for its owner. EveSwap hijacks the Ethereum EOAs of all its users and gets away with all their assets.  The users never transacted on Ethereum, and the invoker running on BobSpongeChain went through rigorous security audits and was found to be secure.  And yet, everyone lost their assets. Ethereum prevents this through the replay protection in EIP-155.  AUTHCALL doesn\u2019t.  By delegating all commit checks to the invoker, we lose any transaction protections offered by Ethereum.  The attack is possible because protection becomes discretionary.  If this EIP is accepted, the AUTH message must include chainid explicitly, not as part of the commit. What can we do instead? My proposal is to implement a more opinionated mechanism that enforces the meaning of the commit at the protocol level.  The commit structure will be typed (as in EIP 712) so the wallet will present it in a user-readable format.  The user will know exactly what the transaction will look like, and have confidence that it cannot be replayed later on any chain, without relying on the honesty and competence of an individual developer who implemented the invoker. A possible implementation: AUTH will replace the commit hash with a typed structure containing a list of authorized calls.  For each call, {nonce,to,gas,calldata,value,chainid} will be specified.  The signature will be verified, and the entire list will be saved as authorized_transactions instead of the authorized address variable. AUTHCALL will get a new arg, index, which points to an address in the list created by the last AUTH. The EOA\u2019s nonce will be incremented on each AUTHCALL.  Not a nonce stored by the invoker, but the actual account nonce. Pros:  User gets full visibility into what\u2019s going on. Security is enforced by the protocol. Still allows batching and account abstraction.  Cons:  Opinionated about the nonce implementation and doesn\u2019t support parallelism. Transactions of complex invokers become cumbersome because the user has to see and accept a list of all the calls.  A different implementation could support a different nonce scheme.  But whatever mechanism we use, MUST be enforced by the protocol rather than the invoker. Complex invokers that perform a large number of user calls should arguably be prevented anyway.  Complex operations should be implemented as a normal smart contract rather than attempt to implement an algorithm using multiple EOA calls. Alternative: entirely avoid the hard fork Another option is to avoid the AUTH mechanism altogether, and solve the account abstraction and batching problems through an alternative mempool as suggested by @vbuterin Pros:  No need for a hard fork.  The new type is supported through smart contracts and nodes that are aware of them. Can be used to implement anything that EIP 3074 could be used for, without introducing additional risk.  Con:  Not backward compatible with existing EOAs.  Users will need to deploy a contract wallet and move assets to it.  Unless the requirement is to support existing EOAs without migration, this seems to be the safer option. ",
                    "links": [
                        "https://notes.ethereum.org/@vbuterin/alt_abstraction",
                        "https://ethereum-magicians.org/t/eip-3074-auth-and-authcall-opcodes/4880/77",
                        "https://ethereum-magicians.org/t/we-should-be-moving-beyond-eoas-not-enshrining-them-even-further-eip-3074-related/6538",
                        "https://ethereum-magicians.org/t/shanghai-candidate-eip-3074/10781/5"
                    ],
                    "GPT-summary": "The author of the post argues against the proposed EIP 3074, which allows for flexible invoker mechanisms but poses a high security risk. Instead, the author proposes a more opinionated mechanism that enforces security at the protocol level and provides full visibility to the user. The post also includes examples of potential attacks and suggests an alternative mempool solution. The post is an explanation and critique of the proposed EIP 3074.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Privacy, Security and risk management",
                        "Interoperability and Scaleability",
                        "Law and regulations",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.192937309603977
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "2",
                    "likes": "5",
                    "time": "16/06/2021-06:35:39",
                    "content": " Introduction Thank you so much for the in-depth review! This is incredibly valuable, and you raise excellent points. I\u2019ve understood a couple different criticisms that I\u2019d like to summarize and discuss separately, before diving into your alternative proposal:   Principle of Least Privilege: once an invoker has an authorization, it has complete control over the signing account.  Buggy or Malicious Invokers: invokers may be complex pieces of software, and may contain bugs or even be malicious.  Eternal Authorizations: once signed, without a cooperating invoker, an authorization lasts forever.  Chain Id and Clever Contract Creation: an invoker on one chain (testnet, Ethereum fork, etc.) seems secure and checks the chain id, but a malicious invoker is deployed at the same address on another chain which does not check the chain id.   Criticisms  Principle of Least Privilege  Once an invoker has a signed package, it has complete control over the signing account.  This is absolutely a concern shared by all of us authors. At first glance, it might seem like signing an EIP-3074 package is strictly worse than an infinite ERC-20 allowance. Instead of granting access to one token, you\u2019re granting access to all of them, forever. Oh, and it\u2019s irrevocable. As @danfinlay pointed out in his excellent comment, many people have compared EIP-3074 to unix\u2019s sudo command: signing a 3074 transaction is like giving up complete control over your account. Both of these comparisons (to ERC-20 allowances, and to sudo) are true, to some extent, but they lack a lot of nuance. An ERC-20 allowance has two components: what address is authorized, and an amount that address has access to (which may be infinite.) The owner has zero control over what the authorized address does with their allotment. A malicious contract could look safe, but when authorized, it transfers all the tokens away. On the other hand, an EIP-3074 authorization can set incredibly specific rules through the invoker for what can be done with the tokens. To bring this back into the unix analogy, I believe EIP-3074 is a lot more like the setuid bit than sudo itself. An executable which has the setuid permission assumes the identity of its owner rather than the identity of the executing user. Oftentimes, the owner will be root, allowing non-root users to execute specific tasks with elevated permissions. My central theme here is that while an EIP-3074 authorization grants the invoker full power over the signing account, the fact that the invoker is programmable enables extremely fine-grained control over exactly what can be done with that power. EIP-3074 is not sudo. It\u2019s setuid.  Buggy Invokers  Invokers may be complex pieces of software, and may contain bugs or even be malicious.  This is unequivocally true. There will be buggy invokers. There will be invokers designed to scam. There will be trojan invokers who try to collect authorizations over time and eventually topple DAOs. I still believe EIP-3074 is worth pursuing in its current flexible form. With UI mitigation, good security messaging, and carefully built code we can keep the majority of people (and their assets) safe.     yoavw:  Why is signing an AUTH commit riskier than signing a transaciton to any other buggy/malicious contract?   This comparison has come up several times while socializing EIP-3074, and I\u2019ll defer once again to @danfinlay. He summed up why we shouldn\u2019t compare EIP-3074 authorizations to traditional transactions more eloquently than I can in his comment. I\u2019ll quickly paraphrase it here:  EIP-3074 allows a user to delegate full control of their account, and therefore invokers are better understood as part of the wallet\u2019s own code and not as a separate contract.  In other words, we shouldn\u2019t compare signing an EIP-3074 package to a traditional transaction, but to installing an extension for a wallet. Few wallets do this today, and none of them do it lightly. EIP-3074\u2019s security proposition is very similar: install a malicious wallet/extension and get pwned; sign an authorization to a bad/buggy invoker and get pwned. If I rewrite your paragraph replacing \u201cEIP-3074\u201d with \u201cwallet\u201d (and I mean zero disrespect here, I just couldn\u2019t come up with a better way to convey my point), your criticism is equally valid:  [Using an Ethereum wallet] requires the user to sign a blank cheque and assume that the [wallet] is honest and not buggy. A malicious/buggy [wallet] could do anything on behalf of the user - access any asset owned by the user, vote on behalf of the user, take ownership of any contract owned by the user, etc.  I think, therefore, it\u2019s reasonable to draw the conclusion that invokers have a similar security profile as wallet software. Wallets are already complex pieces of software, attached to browsers as often as not. The fact that they are not compromised on a daily basis gives me a little hope that we can write safe and solid code. I would be remiss not to point out that wallets never transfer your private key, and EIP-3074 authorizations would necessarily be public, so there is that added risk. I would argue that invokers will be much simpler than wallets in general, so I think that balances out somewhat. Buggy invokers would have to be seriously and obviously broken to be compromised to the level you suggest. Obviously the more complex the invoker is, the more opportunity for issues, but we can structure invokers in such a way that the more bug-prone/complex sections happen after the easy-to-verify sections. Essentially, check nonces before running batched transactions. On-chain replay protection is putting a nonce in the commit, comparing a storage slot, then incrementing it. Screwing that up is difficult (not impossible, of course .) To change the authorization\u2019s target you\u2019d basically need to omit it from the signed commit, and same with the calldata. Also somewhat difficult to screw up. I don\u2019t think it\u2019s outside of the realm of possibility for wallets to reject invokers which haven\u2019t been formally verified and extensively audited. Combine that with strong best practices, and an attitude of abundant caution, and I think we can be reasonably certain that even the buggiest of whitelisted invokers won\u2019t allow attackers to obtain permanent access to an account. Malicious invokers are a completely different beast. Audits and formal verification can only go so far here. Instead we have to rely on social mechanisms, like whitelists and reputation. A huge part of the security proposition of EIP-3074 requires that wallets:  Ban, generally, any signature which might look like an EIP-3074 authorization; and Allow a limited number of \u201ctrusted invokers\u201d that have met some acceptance criteria.  Initially, for example, we expect wallets to whitelist their own sponsored transaction invokers. These invokers will likely only allow transactions originating from one of their official sponsor addresses, limiting the damage they can cause. Further, wallets have extreme pressure to maintain stringent standards for their invoker whitelists. Users are free to move from one wallet to another, so even a hint of insecurity could destroy their reputation, and decimate their entire business model.  Eternal Authorizations  Once signed, without a cooperating invoker, an authorization lasts forever.  This is certainly a departure from other authorization patterns, like ERC-20 allowances. Similarly to the principle of least authority, however, EIP-3074 gives invokers the ability to define exactly how revocation (or expiry) will work. At the simplest, an invoker can reuse nonce replacement to implement revocation, which should be simple enough to implement with some confidence. You could also limit validity to specific block number ranges, which is also trivial to implement.  Chain Id and Clever Contract Creation We\u2019ve went back and forth on chain id several times, and I think this seals it as necessary. Are you convinced @MicahZoltu?  Alternatives  Nested Transactions This seems pretty similar to other approaches to batched transactions like EIP-2711, or EIP-3005 except with the execution controlled by a contract. It\u2019s actually quite similar to the original EIP-3074 design. One potential issue with your proposal is that a transaction from the signer\u2019s account can invalidate a sponsored transaction bundle, wasting the sponsor\u2019s funds.  Do Nothing There are a couple use cases that EIP-3074 enables, which I don\u2019t think can be implemented without some change. Synthetic EOAs, which are useful for state channels, are a really interesting unique feature of EIP-3074. Contract wallets have a lot of the same issues as EIP-3074 invokers, so I don\u2019t think they\u2019re a better solution.  The End Thanks again for your comments, and for catching the issue with chain id! We all really appreciate the thorough review. ",
                    "links": [
                        "https://en.wikipedia.org/wiki/Setuid",
                        "https://ethereum-magicians.org/t/eip-3074-auth-and-authcall-opcodes/4880/61",
                        "https://eips.ethereum.org/EIPS/eip-2711",
                        "https://eips.ethereum.org/EIPS/eip-3005",
                        "https://github.com/ethereum/EIPs/blob/d89ff42f53f2c3e0d4d44f63a273ab8ccfa4d18b/EIPS/eip-3074.md"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None"
                    ],
                    "Sentiment": 5.632382798080472
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "3",
                    "likes": "2",
                    "time": "16/06/2021-17:46:23",
                    "content": "Thanks for your quick and detailed reply!     SamWilsn:  EIP-3074 is not sudo. It\u2019s setuid.   I agree with you 100% on that.  The sudo analogy is wrong, at least the way most people perceive sudo - as shell access rather than a specific command hardcoded in /etc/sudoers. I\u2019m thinking about EIP 3074 exactly as setuid.  Consider the history of setuid binaries.  I used to audit those binaries in the early days of Linux, and before that on closed-source systems like Sunos/Solaris/Ultrix/Irix.  I found vulnerabilities in almost all of them, usually leading directly to unrestricted root access, and sometimes just as a stepping stone to achieving that (e.g. no direct code execution but can be manipulated to truncate an important file of my choosing, leading to privilege escalation). In fact, most of the privilege escalation attacks on Unix based systems in the 1990\u2019s and early 2000\u2019s were due to buggy setuids. It took a couple of decades to weed most of these bugs out, and required adding system level restrictions over the years, such as removing setuid support for interpreted executables (anything starting with #! such as shell/perl scripts), because they were almost impossible to secure.  Just recently, CVE-2021-3156 reported such vulnerability that has been hidden in plain sight for 10 years. Adding setuid to Ethereum might have similar results.     SamWilsn:  I still believe EIP-3074 is worth pursuing in its current flexible form. With UI mitigation, good security messaging, and carefully built code we can keep the majority of people (and their assets) safe.   To continue your Unix analogy, Linux eventually became more secure when it largely moved away from setuid executables in favor of an approach that caused much less trouble than setuid executables -  supporting specific privileged operations through system level daemons.  Such daemon typically starts from init, drops all unneeded capabilities, chroot itself to an empty directory if it doesn\u2019t need filesystem access, setreuid/setregid itself to an unprivileged uid/gid, and only then start interacting with users.  For example, if ntpd needs to set the system clock, it doesn\u2019t need to communicate with time-servers while running as root.  Instead, it only retains CAP_SYS_TIME, then switches to run as an unprivileged user before opening a network socket.  Therefore the worst that an attacker could do is mess with the time, not execute root level code. This time-proven approach is what I think Ethereum should adopt if we need a privileged operation.  The alternative I suggested attempts to implement that.  The requirement is to perform an action on behalf of a user, but there is no requirement to allow the invoker perform just any action - only to reflect the user\u2019s intention.  Hence I tried to drop the unlimited capability and replace it with one that is strictly tied to the user\u2019s request.     SamWilsn:  I think, therefore, it\u2019s reasonable to draw the conclusion that invokers have a similar security profile as wallet software.   Fair comparison.  The invoker becomes a wallet extension. One major difference though: if a wallet adds support for extensions, it is affects only that wallet, and only above a certain version.  EIP-3074 adds extension support to all wallets. Some problems that stem from this difference:  Old unaware wallets become compromised.  Anyone using a pre-EIP-3074 wallet could be enticed to sign a benign-looking message that actually transfers its control to such extension.  The unaware wallet will not warn the user that it is actually an extension installation rather than a normal transaction. Even with EIP-3074-aware wallets that warn the user, many users will be enticed by short term benefits such as a DEX offering sponsored gas for their trades.  Most users won\u2019t realize that they\u2019re signing away full control of their wallet rather than just a trading authorization.  Immediate saving is easy to see, but delayed consequences are hidden. For hardware wallets it breaks user expectations.  When I sign a transaction on my hardware wallet I can verify it on the wallet\u2019s screen without relying on the browser-based wallet.  A wallet extension like EIP 3074 breaks that expectation.      SamWilsn:  Buggy invokers would have to be seriously and obviously broken to be compromised to the level you suggest. Obviously the more complex the invoker is, the more opportunity for issues, but we can structure invokers in such a way that the more bug-prone/complex sections happen after the easy-to-verify sections. Essentially, check nonces before running batched transactions.   Challenge accepted  If EIP 3074 is merged in its current form, I\u2019ll try to release an invoker with a subtle bug that violates this assumption under a pseudonym and see how long it remains undiscovered.     SamWilsn:  On-chain replay protection is putting a nonce in the commit, comparing a storage slot, then incrementing it. Screwing that up is difficult (not impossible, of course .) To change the authorization\u2019s target you\u2019d basically need to omit it from the signed commit, and same with the calldata. Also somewhat difficult to screw up.   At the risk of giving away the kind of subtle bugs I have in mind, consider a complex invoker that performs the nonce check as early as possible and stores it in a mapping.  The audit focuses on this pre-nonce-check code and it seems perfect.  However, deep inside some unrelated post-authentication housekeeping function I introduce a bug that allows me to overwrite arbitrary storage in the contract.  After collecting enough authorizations, I start resetting user nonces and replaying transactions.     SamWilsn:   Ban, generally, any signature which might look like an EIP-3074 authorization; and Allow a limited number of \u201ctrusted invokers\u201d that have met some acceptance criteria.    EIP-3074 aware wallets can do that, but we\u2019ll be putting legacy users at risk of installing bad extensions without knowing that they even exist. If we want to require wallets to be aware, then we need a new transaction type, incompatible with old wallets, and only accept the AUTH opcode when triggered from a transaction of the new type.     SamWilsn:  Further, wallets have extreme pressure to maintain stringent standards for their invoker whitelists. Users are free to move from one wallet to another, so even a hint of insecurity could destroy their reputation, and decimate their entire business model.   Wallet maintainers are not necessarily qualified to identify subtle/malicious bugs in invokers. To use another OS analogy, Microsoft added drivers-signing many years ago and its reputation relies upon not signing malicious drivers.  Microsoft security engineers are quite capable.  And yet, researchers got them to whitelist malicious drivers.  Apple does that for any iOS app, requiring a signature from Apple itself in order to run an app on your iphone.  Their reputation depends on it.  And yet, malicious apps occasionally make it through and cause some damage until discovered and removed. When I use a hardware wallet I don\u2019t rely solely on MetaMask for my transaction security, although I\u2019m sure the MetaMask team are among the best experts in the field.  I rely on what I see on the hardware wallet screen, and I know that even if MetaMask is compromised it cannot abuse my EOA, now or in the future.  EIP-3074 takes away that confidence and forces me to rely on MetaMask to audit and whitelist invokers. On the other hand, it enables a lucrative business model for wallet maintainers .  Most wallets (except MetaMask with the swaps support) don\u2019t make a lot of money, but with EIP 3074 they can directly capitalize on their reputation (once), by robbing all of their users including high-value ones that use hardware wallets for signing anything of value.     SamWilsn:  At the simplest, an invoker can reuse nonce replacement to implement revocation, which should be simple enough to implement with some confidence. You could also limit validity to specific block number ranges, which is also trivial to implement.   Yes, an invoker could implement pretty good protection schemes.  But the model is discretionary, not mandatory protocol level protection.  As you explained, it\u2019s equivalent to a setuid executable, where I must trust the implementation of that particular binary rather than kernel level enforcement such as dropping unused capabilities. Kernel level guarantees are stronger than usermode checks \u2192 protocol level guarantees are stronger than contract checks.     SamWilsn:  One potential issue with your proposal is that a transaction from the signer\u2019s account can invalidate a sponsored transaction bundle, wasting the sponsor\u2019s funds.   Yes, I\u2019m aware of the issue with changing the actual account state and conflicting with another transaction from that account.  It\u2019s hard to mitigate without maintaining separate nonce storage for invokers.  However it would make sense to maintain this additonal nonce storage at the protocol level and mandate that it is used as part of AUTHCALL so that an invoker can\u2019t replay messages even if it is buggy/malicious. Another possible mitigation is to assume that miners run mev-geth (most of them already do), and have the sponsor pay the miner directly, but only if the nonce check succeeds.  The sponsor is no longer exposed to griefing through invalidation, and neither is the miner because the transaction will never get mined. I believe my proposal preserves the principle of least privilege, as I explained in the minimally-privileged daemon analogy above.  What do we lose by implementing something like that instead of adding a setuid bit?  It would make sense to list the downsides of such approach compared to EIP 3074, so that we can decide if it is worth the extra risk.     SamWilsn:  There are a couple use cases that EIP-3074 enables, which I don\u2019t think can be implemented without some change. Synthetic EOAs, which are useful for state channels, are a really interesting unique feature of EIP-3074.   Does my proposal of adding a mandatory signature check for specific AUTHCALLs hinder state channels support?  I think it can be used the same way as EIP 3074.  The user needs to sign the latest state in any case.     SamWilsn:  Contract wallets have a lot of the same issues as EIP-3074 invokers, so I don\u2019t think they\u2019re a better solution.   Contract wallets share some of the issues but not all of them.  The user makes a deliberate choice to move assets to a contract wallet.  With EIP 3074 the user could be tricked to turn the wallet into a contract without moving assets or realizing what\u2019s going on.     SamWilsn:  Thanks again for your comments, and for catching the issue with chain id! We all really appreciate the thorough review.   Thank you for your detailed reply and insightful analogies.  Always a pleasure to discuss security issues with smart people. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None"
                    ],
                    "Sentiment": 5.50029340248496
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "4",
                    "likes": "2",
                    "time": "16/06/2021-19:08:43",
                    "content": "    SamWilsn:  We\u2019ve went back and forth on chain id several times, and I think this seals it as necessary. Are you convinced @MicahZoltu?   No, for the same reason as before.  Don\u2019t solve a problem on a lower layer that can be solved by a higher layer, especially when the solution involves restricting possibilities.  The goal is to build a simple and expressive instruction set, and it is up to people using those instructions to do so wisely.  As much as I hate it, there is a reason that the lowest level programming languages don\u2019t do even the simplest things like overflow protection. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.138888888888888
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "5",
                    "likes": "1",
                    "time": "16/06/2021-19:11:27",
                    "content": "    yoavw:  Old unaware wallets become compromised. Anyone using a pre-EIP-3074 wallet could be enticed to sign a benign-looking message that actually transfers its control to such extension.   IIRC, there are no popular wallets that allow arbitrary signing without enabling specific advanced features that come with dire warnings. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving negative feedback on proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "6",
                    "likes": "1",
                    "time": "16/06/2021-19:20:31",
                    "content": "I replied to a bunch of specific things below, but I think you may have a misunderstanding of how most wallets work today and what they allow.  If 3074 launched today, essentially no one would be able to sign a 3074 transaction because no wallet I know of supports signing arbitrary messages, and no wallet knows about 3074 messages.     yoavw:  Even with EIP-3074-aware wallets that warn the user,   I believe that every wallet we have talked to has asserted that they will not be allowing their users to sign arbitrary invokers.  I think they all plan on whitelisting vetted invokers only.     yoavw:  A wallet extension like EIP 3074 breaks that expectation.   I don\u2019t think any major hardware wallet will let you sign a 3074 transaction.  TBD how exactly hard are wallets will deal with this, but I\u2019m guessing a whitelist just like software wallets.     yoavw:  If we want to require wallets to be aware, then we need a new transaction type, incompatible with old wallets, and only accept the AUTH opcode when triggered from a transaction of the new type.   See above, this is essentially the case.  No wallet will even prompt a user to sign a 3074 message today.  Wallets will explicitly need to add support.     yoavw:  I rely on what I see on the hardware wallet screen, and I know that even if MetaMask is compromised it cannot abuse my EOA, now or in the future. EIP-3074 takes away that confidence and forces me to rely on MetaMask to audit and whitelist invokers.   Same as above, your hardware wallet won\u2019t let you sign a 3074 transaction by default.  They will need to update with that functionality, and I would be very surprised if any let you sign arbitrary 3074 messages without going through some advanced configuration. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.3689910468319555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "7",
                    "likes": "0",
                    "time": "16/06/2021-19:46:46",
                    "content": "    MicahZoltu:      SamWilsn:  We\u2019ve went back and forth on chain id several times, and I think this seals it as necessary. Are you convinced @MicahZoltu?   No, for the same reason as before. Don\u2019t solve a problem on a lower layer that can be solved by a higher layer, especially when the solution involves restricting possibilities. The goal is to build a simple and expressive instruction set, and it is up to people using those instructions to do so wisely. As much as I hate it, there is a reason that the lowest level programming languages don\u2019t do even the simplest things like overflow protection.   I think @yoavw has established that it cannot be safely done at a higher level:  I create a thoroughly vetted/audited/perfectly secure contract which checks the chain id, called ContractA. I deploy ContractA on goerli (or ETC, or BobSpongeChain) using a very special CREATE2 deployer, which allows arbitrary code to be deployed at the same address (and yes, this is 100% possible, we did it for fun a while back.) I create a malicious contract, ContractB, and deploy it using the same method on a different chain at the same address. ContractB does not check the chain id. I replay the authorizations given to ContractA against ContractB, gaining complete control of those accounts on the other chain.      MicahZoltu:      yoavw:  Old unaware wallets become compromised. Anyone using a pre-EIP-3074 wallet could be enticed to sign a benign-looking message that actually transfers its control to such extension.   IIRC, there are no popular wallets that allow arbitrary signing without enabling specific advanced features that come with dire warnings.       MicahZoltu:  No wallet will even prompt a user to sign a 3074 message today. Wallets will explicitly need to add support.   Metamask allows it, without any special configuration:  Screenshot from 2021-06-16 15-43-35760\u00d71350 88.1 KB  I\u2019m not sure if that warning is sufficiently dire. ",
                    "links": [
                        "https://ethereum-magicians.org/uploads/default/original/2X/7/7ffdc3e6f28ca891b329808d06e1dea21a67a3a9.png"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.340367965367966
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "8",
                    "likes": "1",
                    "time": "16/06/2021-20:18:30",
                    "content": "    MicahZoltu:  No, for the same reason as before. Don\u2019t solve a problem on a lower layer that can be solved by a higher layer, especially when the solution involves restricting possibilities. The goal is to build a simple and expressive instruction set, and it is up to people using those instructions to do so wisely. As much as I hate it, there is a reason that the lowest level programming languages don\u2019t do even the simplest things like overflow protection.   And how would you prevent the cross-chain attack I described above at a higher layer?  The invoker on BobSpongeChain is perfectly secure and yet it can\u2019t do anything about the attack on Ethereum. In general this argument is incompatible the principle of least privilege.  Would you trust an OS where there are no kernel level protections and everything is delegated to usermode processes?  Or a blockchain where all transactions are accepted into blocks, and clients are expected to detect double-spending transactions and disregard them?  Some things are best done at the infrastructure layer.     MicahZoltu:  IIRC, there are no popular wallets that allow arbitrary signing without enabling specific advanced features that come with dire warnings.   Hmmm, is Trezor popular enough to be considered? Let me try that with one of the Trezors I have on my desk here: $ trezorctl ethereum sign-message $(printf '\u0003some_hash') -n \"m/44'/60'/0'/0/0\" Please confirm action on your Trezor device. message: some_hash address: 0xB46d902CF5B12B8f00c93A6fe3800CDFA4ca4ef7 signature: 0x21ceb8fdd0c8b07c1721a9d1a48365914ca90d1ded9f125208b06a0731b181e30bdb15b10e17ed3c6da2e0f509d2753c0024a10d7787294b3de6523d67949d211b  Well, that worked.  And my Trezor didn\u2019t give me any warning.  Just displayed the message with the \u0003 character as a benign \u201c\u201d at the beginning of the message, and let me sign it. I haven\u2019t tried with a Ledger but I believe it will behave similarly.     MicahZoltu:  I replied to a bunch of specific things below, but I think you may have a misunderstanding of how most wallets work today and what they allow. If 3074 launched today, essentially no one would be able to sign a 3074 transaction because no wallet I know of supports signing arbitrary messages, and no wallet knows about 3074 messages.   Are you sure I\u2019m misunderstanding how wallets work?  Seems that two popular wallets (Trezor and MetaMask) do sign it.     MicahZoltu:  I believe that every wallet we have talked to has asserted that they will not be allowing their users to sign arbitrary invokers. I think they all plan on whitelisting vetted invokers only.   Well, at least some of them currently do.  Even if they block it in their next release, the existing ones are vulnerable. Furthermore, I don\u2019t want to trust their judgement on vetting invokers.  I trust them to sign transactions and messages.  As for smart contract, I\u2019d rather be vetting them myself.     MicahZoltu:  I don\u2019t think any major hardware wallet will let you sign a 3074 transaction. TBD how exactly hard are wallets will deal with this, but I\u2019m guessing a whitelist just like software wallets.   Well, one of them just did.     MicahZoltu:  See above, this is essentially the case. No wallet will even prompt a user to sign a 3074 message today. Wallets will explicitly need to add support.   Ditto.     MicahZoltu:  Same as above, your hardware wallet won\u2019t let you sign a 3074 transaction by default. They will need to update with that functionality, and I would be very surprised if any let you sign arbitrary 3074 messages without going through some advanced configuration.   Same as above. But aside from the legacy-wallet issue which I hope I sufficiently established above, I think you may be disregarding my main point regarding security design and what we can learn from setuid vulnerabilities in operating systems in the past 30-40 years. I believe we all agree that EIP 3074 invokers are equivalent to setuid executables.  Let\u2019s learn from what went wrong with setuid executables and how the problem was mitigated in the last decades.  We don\u2019t need to reinvent security when there\u2019s an equivalent we can learn from.  We have decades of relevant security research, and there are time-proven patterns we can study. Do you see a good reason to deviate from the established pattern here? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.4039420485175205
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "9",
                    "likes": "0",
                    "time": "16/06/2021-20:58:19",
                    "content": "    yoavw:  Well, that worked. And my Trezor didn\u2019t give me any warning. Just displayed the message with the \u0003 character as a benign \u201c\u201d at the beginning of the message, and let me sign it.   Are we sure it isn\u2019t prepending the \u0018Bitcoin Signed Message:\\  magic prefix? A quick google seems to suggest trezor will do that.     yoavw:  I don\u2019t want to trust their judgement on vetting invokers. I trust them to sign transactions and messages. As for smart contract, I\u2019d rather be vetting them myself.   You should always be free to do additional vetting yourself before signing anything, no? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.947619047619047
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "10",
                    "likes": "1",
                    "time": "16/06/2021-21:11:31",
                    "content": "    SamWilsn:  Are we sure it isn\u2019t prepending the \u0018Bitcoin Signed Message:\\  magic prefix? A quick google seems to suggest trezor will do that.   I think that\u2019s what they do for \u201ctrezorctl sign-message\u201d but not \u201ctrezorctl ethereum sign-message\u201d.  I haven\u2019t verified it now, but I recall that in the past I signed messages to a proxy contract with trezorctl and didn\u2019t have any issues.     SamWilsn:  You should always be free to do additional vetting yourself before signing anything, no?   Yes, but once it is whitelisted most people wouldn\u2019t even know that an invoker is involved.  It will appear just like any other transaction and most users won\u2019t be aware that they\u2019re essentially installing a wallet extension. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.304166666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "11",
                    "likes": "3",
                    "time": "16/06/2021-22:31:49",
                    "content": "    yoavw:  If EIP 3074 is merged in its current form, I\u2019ll try to release an invoker with a subtle bug that violates this assumption under a pseudonym and see how long it remains undiscovered.   Our testnet should still be running if you want to give it a shot! I\u2019d be curious to see what that would look like.  I\u2019m going to take some time to mull over your thoughts. Something akin to capabilities would be extremely interesting to me. I\u2019m not convinced that enshrining single-use transaction-like packages is the way to go, but I\u2019m certainly more open to alternatives to 3074 than I was a few days ago! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.158854166666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "12",
                    "likes": "1",
                    "time": "16/06/2021-22:42:27",
                    "content": "    SamWilsn:  Our testnet should still be running if you want to give it a shot! I\u2019d be curious to see what that would look like.   heh, doing it that way would miss the point since everyone will know there\u2019s an intentional bug to look for.  The experiment would be more fun when I publish it a bit later as part of a larger project.   But think something like what I described above, with an unrelated post-nonce function that overwrites arbitrary storage cells.  Or more likely, a post-nonce delegatecall to another contract that does that, using a mapping with the same name rather than an obvious asm snippet.  (I know delegatecall doesn\u2019t preserve AUTH but I don\u2019t mean using it for that - just to use it to overwrite some storage cell in the invoker).     SamWilsn:  I\u2019m not convinced that enshrining single-use transaction-like packages is the way to go, but I\u2019m certainly more open to alternatives to 3074 than I was a few days ago!   I\u2019m glad to hear that.  I think something like 3074 is important for use cases like account abstraction, gas sponsorship and state channels.  I just hope we can find a way to do it securely.  I\u2019ll be happy to discuss more ways to achieve this. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.909375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/matt",
                    "index": "13",
                    "likes": "2",
                    "time": "17/06/2021-00:40:09",
                    "content": "@yoavw I\u2019m quite conflicted on this cross-chain attack. On one hand, what you say sounds plausible. A malicious actor could deploy different code to the same address on different chains. But, IMO, you left out that there would be a glaring trail in the initcode and/or the deployment transaction. But at the same time, there doesn\u2019t seem to be any reasonable use case for cross-chain invokers\u2026 edit: I made the mistake of forgetting create operations are not tied to the hash of the initcode. I was thinking of create2  in that case you are right, this could be a bad attack. However, if in the \u201cguidelines for safe invokers\u201d we state that invokers should only be deployed via create2 and their initcode should not allow arbitrary code to be loaded, it should be perfectly safe. \u2013 My philosophy on this is that EIP-3074 has pitfalls and it\u2019s those pitfalls that make it so powerful. We can\u2019t know how people will use these primitives in 5-10 years. The fact that it\u2019s possible to prove, with absolute certainty, that an invoker cannot reach a bad state is a compelling reason for me to overlook the difficulties in creating the proof. I think the cost of proving safety is worth it, because it unlocks a rich set of functionality for EOAs. This cross-chain attack is just another checkbox to check when deciding if an invoker is safe. IMO, it\u2019s probably one of the easiest checkboxes since it just requires looking at the initcode (the HLL code is available, right? right\u2026?). Other than that, I think my main criticism with these Linux comparisons is that Ethereum isn\u2019t Linux. The things that work for Linux don\u2019t necessarily work for Ethereum. Supporting specific privileged operations is where EIP-3074 started (and EIP-2711 and EIP-2733). Again and again, we found the burden of the new functionality did not outweigh the gains provided. As soon as new storage reads or writes are introduced (this is what you\u2019re saying when you say \u201cspecific privileged operations\u201d - Ethereum has to check the \u201cdisk\u201d to get the permissions) to an EIP, either complexity/storage costs explodes or we\u2019re back to a rigid design whose pros usually don\u2019t outweigh the cons. If we try to reuse things like EOA nonces, we break invariants. If we save a new nonce, we have to figure out how and where. IMO, this* is a non-starter. *by \u201cthis\u201d I mean stateful checks. There are some stateless checks that we can do if there is sufficient desire. I am generally against them, but they are possible without significantly modifying EIP-3074. For example:  we can add a chainid parameter to the AUTH message we can add a block_number or epoch to the AUTH message, capping the amount of time a signature is valid \u2026 probably others!  But again, these are generally against my philosophy of EIP-3074. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.507031071998178
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "14",
                    "likes": "2",
                    "time": "17/06/2021-02:33:26",
                    "content": "This has been a very fun read, thank you to @yoavw for so many specific examples and even some alternative approaches. I\u2019ll be very curious to see if Trezor is prepending a prefix if not. If it\u2019s not, that\u2019s pretty bad. I think one of the strongest take-aways from this thread for me is \u201cwe should do a formal and systematic review of wallets\u2019 behavior for this type of signature\u201d I agree the MetaMask signature warning could be more dire (particularly in a 3074 environment), but it does say in red, that this signature risks entire control of the account. And we wrote that before 3074, so I\u2019m going to count it pretty prescient, even though it could be tighter.  Contract wallets share some of the issues but not all of them. The user makes a deliberate choice to move assets to a contract wallet.  There are now multiple consumer contract wallets that are being promoted to consumers who do not disclaim themselves as having contract bug risk. Vitalik himself promotes contract accounts as a safer alternative to EOAs. We\u2019re already well into the \u201cunspoken account-wide contract risk\u201d era. You could compare that behavior to a wallet signing 3074 messages without mentioning it to the user, for convenience sake. That\u2019s already the wallet environment, so to some degree, I think this argument is trying to prevent a type of risk that is already taken. That\u2019s a common theme I find when debating delegation: Can we keep people safe, by preventing certain types of delegation? I am of the camp that if a user has the ability to do something, they already have the de-facto ability to delegate it, it might just be inconvenient.  I don\u2019t want to trust their judgement on vetting invokers. I trust them to sign transactions and messages. As for smart contract, I\u2019d rather be vetting them myself.  I think it\u2019s reasonable for a wallet to help users know when they\u2019re taking on contract risk, and I\u2019d gladly make sure that MetaMask lets users avoid this kind of risk entirely, but like with contract accounts, it\u2019s already common for consumer products to integrate contract risk for their users without really emphasizing or mentioning it.  I believe we all agree that EIP 3074 invokers are equivalent to setuid executables. Let\u2019s learn from what went wrong with setuid executables and how the problem was mitigated in the last decades. We don\u2019t need to reinvent security when there\u2019s an equivalent we can learn from. We have decades of relevant security research, and there are time-proven patterns we can study.  I\u2019m not that familiar with the setuid executable example, and I\u2019d love some links to the example attacks and mitigations. From the earlier descriptions in this thread, it sounds like when you\u2019re using chroot, for example, you\u2019re still trusting a trusted computing base to restrict the behavior of subsequent programs being executed. In a way, this sounds a lot like a 3074 invoker in its current form: You trust an invoker, so it can attenuate control to other external scripts.  there doesn\u2019t seem to be any reasonable use case for cross-chain invokers\u2026  One hypothetical could be \u201cI want to delegate this account\u2019s control to this other key, on every network\u201d. This spectrum between the tradeoffs between user control and safety seems like a very well defined philosophical disagreement. I generally think that the Ethereum platform exists far on the \u201cdangerously free\u201d end of this spectrum, and some of the arguments for \u201ckeeping security at the protocol layer\u201d remind me of arguments in favor of per-app blockchains over an application-capable chain like Ethereum. I always figured bugs could exist at the protocol layer, too, so you might as well keep the entire platform more dynamic, but this seems like a distinction that the Ethereum community needs to decide for itself. Anyways, just sharing my initial thoughts. I think we should systematically review wallets that sign arbitrary bytes, and for any that do (MetaMask, Trezor?), consider the attack surface (can \u00d0apps ever propose an arbitrary signature to it? Does it receive a salient warning? How common are users who are willing to paste signature bytes from strangers into outdated signers?) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.301984126984127
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "15",
                    "likes": "1",
                    "time": "17/06/2021-17:11:59",
                    "content": "    yoavw:      SamWilsn:  Are we sure it isn\u2019t prepending the \u0018Bitcoin Signed Message:\\  magic prefix? A quick google seems to suggest trezor will do that.   I think that\u2019s what they do for \u201ctrezorctl sign-message\u201d but not \u201ctrezorctl ethereum sign-message\u201d. I haven\u2019t verified it now, but I recall that in the past I signed messages to a proxy contract with trezorctl and didn\u2019t have any issues.   So this is far from scientific, but I tried your signature, a signature from personal_sign, and a signature with eth_sign on MEW. Assuming I did all three parts correctly, since MEW validated the trezor signature and the personal_sign signature, but not the raw eth_sign signature, we can assume the trezor signature includes the magic prefix.  Trezor {     \"address\": \"0xB46d902CF5B12B8f00c93A6fe3800CDFA4ca4ef7\",     \"sig\": \"0x21ceb8fdd0c8b07c1721a9d1a48365914ca90d1ded9f125208b06a0731b181e30bdb15b10e17ed3c6da2e0f509d2753c0024a10d7787294b3de6523d67949d211b\",     \"msg\": \"\u0003some_hash\" }  Gives  0xB46d902CF5B12B8f00c93A6fe3800CDFA4ca4ef7 did sign the message: some_hash   personal_sign  {     \"address\": \"0x285608733D47720B40447b1cC0293A2e4435090e\",     \"sig\": \"0x0112651f89e8eaaf0331db857e23f77fe493249cf7d75f0c06ca1ed5e08581c340f0ba8713873cd65bba1d00c6cbdedb235e32130700a3c8f88d8858022eb90c1b\",     \"msg\": \"\u0003some_hash\" }  Gives:  0x285608733D47720B40447b1cC0293A2e4435090e did sign the message: some_hash   eth_sign  {     \"address\": \"0x285608733D47720B40447b1cC0293A2e4435090e\",     \"sig\": \"0x0667ebe3419e77d411844ab485027580977fa47259ab9780620043bfbaa88a961e188f287ad519fc11d9ac483b79202294ad3bddf2f546474e17ca40d1b43f431b\",     \"msg\": \"\u0003some_hash\" }  Gives:  Signer address is different than the derived address!  To use eth_sign, I had to manually hash the message, which came out to 0x2ff859a3a103a3c50abafb36eaf0ff4a80de20f68766573c10397d1199154515. This is probably the part I\u2019m most unsure of. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.084757834757834
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "16",
                    "likes": "1",
                    "time": "18/06/2021-02:19:59",
                    "content": "    matt:  @yoavw I\u2019m quite conflicted on this cross-chain attack. On one hand, what you say sounds plausible. A malicious actor could deploy different code to the same address on different chains. But, IMO, you left out that there would be a glaring trail in the initcode and/or the deployment transaction. But at the same time, there doesn\u2019t seem to be any reasonable use case for cross-chain invokers\u2026   What kind of glaring trail would you expect to find in the deployment?  I don\u2019t think I left anything out.  There shouldn\u2019t be any. To demonstrate it, I quickly hacked together a couple of invoker-like contracts, one that checks commits to verify the call data and prevent replays, and one that doesn\u2019t.  I deployed the legitimate one on kovan and the malicious one on ropsten, at the same addresses (0x2f37C1C864932c425Be17E73e9F7d3edc28AF010).  The contracts are available with verified code on etherscan so you can inspect their deployment and transactions: See anything detectable signs of fraud in the deployment of the legitimate invoker on kovan? And I sent a couple of transactions to demonstrate the attack.  I know it\u2019s nowhere near a full simulation of EIP 3074 but the EIP3074Simulation contract implements the security checks that matter for this demo.  authTest(bytes32 commit, uint8 _v, bytes32 _r, bytes32 _s) internal returns(address signer) verifies that the commit is signed along with the address of the invoker, returns the signer and assigns it to authorized.    function authcallTestAndReset(string memory what) internal returns(bool success) doesn\u2019t actually call anything but it verifies that authorized is set, and performs what on behalf of authorized (actually just emitting SuccessfulExecution(address who, string what)). Both invokers use that contract without changes, to simulate an EIP 3074 call.  But the contracts themselves are different despite having the same address: BenignInvoker on kovan implements replay protection and ensures that commit really represents what.  If you look at the first three transactions I sent it, you can see that the first one (0x324d4bc54319334fb92f4cd5efa93ab37d06e2f95f6fd79395777338a2d8c54d - sorry I can\u2019t link as this forum only allows two links per post) succeeded, and if you look at the decoded input you can see that it executed \u201clegitimate call\u201d on behalf of the signer.  The second transaction (0xcf7d3e0154af2acaed3ee9a1b7adfc3d97a0e61b3ca40ea098cb2c1e6568393f) reverted on a replay of the same call, and the third one (0x9869df67fa53fe003265bc09dcc800e2bc08fb75cb0aae189849627404784619) reverted on an attempt to change the what.  So this invoker seems legit. MaliciousInvoker deployed on ropsten omits the checks around commit (no replay protection, no check to associate what with commit).  I replayed the commit and signature from the first kovan transaction above, replacing just the what, and sent a couple of transactions malicious whats.  If you look at one of them, e.g. 0xb331067354431f085ea300cf748df1416a93430f858402f2595303c74c69bcb0, and decode the input, you\u2019ll see that it is identical to the kovan transaction except for having a malicious what. The point of this demo is to show the cross-chain attack I was talking about.  I think it\u2019s impossible to find anything illegitimate on the kovan invoker, and yet I\u2019m able to perform any action on behalf of the signer on ropsten. I hope this clarifies the attack and shows why it would be impossible to mitigate without checking chainid in AUTH.     matt:  I think the cost of proving safety is worth it, because it unlocks a rich set of functionality for EOAs.   I don\u2019t think it\u2019ll be possible to prove safety of an invoker when it is made so powerful.  But the question I keep coming back to, is what functionality do we lose by making it less powerful and have the user actually sign each AUTHCALL?  It clearly makes the invoker less risky, so we should compare the two approaches and see what we lose by taking away some of that power.     matt:  IMO, it\u2019s probably one of the easiest checkboxes since it just requires looking at the initcode (the HLL code is available, right? right\u2026?).   Well, the initcode is available in the contracts I linked above.  I don\u2019t think you can tell that something is wrong by looking at the legitimate one I deployed on kovan.     matt:  Other than that, I think my main criticism with these Linux comparisons is that Ethereum isn\u2019t Linux. The things that work for Linux don\u2019t necessarily work for Ethereum.   I used the Linux analogy because Sam described it as setuid (and he\u2019s totally right about it).  Since this is the closest analogy, it made sense to draw conclusions from problems it created and how they were mitigated over the years.     matt:  Again and again, we found the burden of the new functionality did not outweigh the gains provided.   I don\u2019t think we ever added something with that level of risk, but perhaps I\u2019m wrong.  In any case my philosophy around Ethereum is that we can add new functionality but need to be much more prudent than most other systems.  This is not a website, so the Facebook approach of \u201cmove fast and break things\u201d doesn\u2019t fit.  We should weigh the alternatives and find the least risky way to achieve the goal.  I\u2019m not sure EIP 3074 reaches that bar at the moment, but I do think it could with some changes.  What I\u2019m trying to do is start a public discussion about the pros and cons of various approaches, so that the community can determine the right trade-offs.     matt:  *by \u201cthis\u201d I mean stateful checks   I\u2019m also talking about stateless checks.  Specifically, check the same things that you already intend to check on a commit, but do it at the protocol level rather than the invoker.  Enforce security in the infrastructure, not an individual contract.     matt:  But again, these are generally against my philosophy of EIP-3074.   That\u2019s the crux of the matter.  The specific attacks we\u2019re discussing can all be mitigated one way or another.  The real discussion is about that philosophy.  Whether the protocol should be opinionated and enforce the principle if least privilege, or whether we delegate security to a smart contract.  My preference is the former, yours seems to be the latter. That\u2019s fine, we don\u2019t have to share the same philosophy.  I highly respect you and the rest of the authors if this EIP, as well as the other commenters in this thread, and I believe we are all working in good faith to make Ethereum better. The best way to decide is to discuss pros and cons, and let the community decide.  It would be helpful if we list some use cases that break if we enforce at the protocol level instead of the invoker, and then we can discuss whether they justify the increased risk.     danfinlay:  I\u2019ll be very curious to see if Trezor is prepending a prefix if not. If it\u2019s not, that\u2019s pretty bad. I think one of the strongest take-aways from this thread for me is \u201cwe should do a formal and systematic review of wallets\u2019 behavior for this type of signature\u201d   I haven\u2019t verified, but there\u2019s a good chance it\u2019s actually a message format and not directly signing the transaction (unlike Metamask which does).  Still, we\u2019re diving into specifics (e.g. which wallets currently support such messages).  Any specific case can be mitigated, including the attacks I demonstrated.  The bigger question is whether EIP 3074 really needs to be that powerful, or whether we can achieve much of the same value with a lower risk.     danfinlay:  I am of the camp that if a user has the ability to do something, they already have the de-facto ability to delegate it, it might just be inconvenient.   Would it be much more inconvenient to the user if the specific call has to be signed instead of a blank authorization?  The wallet could still hide that from the user, but it wouldn\u2019t be as vulnerable to invoker bugs since replay and modifications will be prevented at the protocol level.     danfinlay:  I\u2019m not that familiar with the setuid executable example, and I\u2019d love some links to the example attacks and mitigations.   It would be quite time consuming to come up with a full list, but if you search \u201csetuid\u201d on old bugtraq archives and CVEs, you can see numerous cases.  And then you can see that their frequency starts dropping, as more projects move away from using setuid in favor of daemons that drop privileges.  There was a steep decline in these bug reports when Linux completely banned setuid scripts, which broke many projects until they switched to a different model, but greatly improved security.  It was controversial at the time, but in retrospect it was the right call.  (As an anecdote, you could get root access with such scripts by just setting IFS=/ when invoking them, since it would run \u201cbin\u201d in the current directory as root, instead of /bin/sh, and this worked on almost all Unix based systems for a few years). I do recall some Usenix Security papers that analyzed the different approaches in the early 2000\u2019s but I haven\u2019t scanned for these old articles.  Personally I\u2019ve been involved in this specific space for the past 30 years so it seems obvious to me, but going through privilege escalation CVEs and seeing how many of them were due to setuid might help everyone realize the risk involved. Unfortunately even today we haven\u2019t fully gotten rid of this problem.  The CVE I linked earlier in this thread, from Jan 2021, demonstrates an attack against sudo, one of the last remaining setuid binaries.  It\u2019s hard to implement sudo without setuid so it keeps getting hit every couple of years. As for the mitigation, different approaches were tried, but the prevailing one is daemons that live in a \u201ccage\u201d and only retain the specific capability they need.  This is pretty much the standard.  In the past few years, since Linux added the unshare(2) syscall, containers like docker started also creating separate namespaces that made things even more secure.  We don\u2019t have an equivalent in Ethereum but it\u2019s interesting to think about it.  Ethereum strives to be the world computer, and can benefit from past OS security research.     danfinlay:  you\u2019re still trusting a trusted computing base to restrict the behavior of subsequent programs being execute   Yes, but the TCB in this case is the kernel which enforces the chroot, the mandatory permissions, the capabilities subsystem, selinux rules, etc.  The kernel is verified by more security people than most other parts of the system.  The equivalent here would be Ethereum as the TCB.  Ethereum itself (and EVM specifically) has been verified and is continuously verified by many security people.  Adding 3rd party invokers to the TCB would weaken that model, just like adding a setuid binary weakens the Linux TCB.     danfinlay:  In a way, this sounds a lot like a 3074 invoker in its current form: You trust an invoker, so it can attenuate control to other external scripts.   This is pretty much the definition of setuid (although setuid was banned for scripts by the Linux kernel due to numerous vulnerabilities, and can now only work with compiled binaries).  But since it increases the TCB, it makes sense to consider different approaches that wouldn\u2019t.     danfinlay:  One hypothetical could be \u201cI want to delegate this account\u2019s control to this other key, on every network\u201d.   But then how would you mitigate the attack I demonstrated above?  I don\u2019t think this use-case justifies putting everyone else at such high risk.  It would be almost trivial to exploit this.     danfinlay:  remind me of arguments in favor of per-app blockchains over an application-capable chain   Why?  Per-app blockchains are inherently weaker due to having less participants.  Ethereum\u2019s turing-completeness made it attractive enough to become secure.  There\u2019s no conflict. The fact that Ethereum gives us more freedom doesn\u2019t mean that we should become careless.  Any EIP needs to be scrutinized and considered against the alternatives.  I\u2019d be interested in an analysis of the use-cases that this EIP comes to solve, and whether this is the least risky way to solve them.  So far I haven\u2019t seen a use-case that can\u2019t be solved while still letting the user retain the signatory power over the EOA.     danfinlay:  I think we should systematically review wallets that sign arbitrary bytes, and for any that do (MetaMask, Trezor?), consider the attack surface (can \u00d0apps ever propose an arbitrary signature to it? Does it receive a salient warning? How common are users who are willing to paste signature bytes from strangers into outdated signers?)   As I noted above, I think this is diving into a specific case.  I think we should start from a higher level, document the use cases this EIP aims to solve, and then dive down to mitigating specific issues in specific solutions.     SamWilsn:  To use eth_sign, I had to manually hash the message, which came out to 0x2ff859a3a103a3c50abafb36eaf0ff4a80de20f68766573c10397d1199154515. This is probably the part I\u2019m most unsure of.   I haven\u2019t researched this beyond the snippet I pasted a few messages ago.  Considering the above, I suspect that Trezor is not signing a raw message.  But since the legacy wallets issue is not the primary issue (just one symptom of possibly giving too much power to the invoker), I think we should focus on the high level first. Let\u2019s try to get to a design that solves the required use-cases with the lowest risk possible, so that we end up with the most secure version of EIP 3074.  When we achieve that, we can go through specific issues (whichever will be left) and see how significant they are and what can be done about them.  And finally make a decision on the trade-offs around the ones we can\u2019t mitigate. Right now I think this thread is mostly debating that last part (trade-offs), treating EIP-3074 as a take-it-or-leave-it proposition and assuming that we just need to decide if the risk is worth it.  But I think we should explore improving the design and then maybe we won\u2019t need to debate trade-offs. ",
                    "links": [
                        "https://ropsten.etherscan.io/address/0x2f37c1c864932c425be17e73e9f7d3edc28af010#code"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.397410815680047
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/matt",
                    "index": "17",
                    "likes": "1",
                    "time": "18/06/2021-16:31:43",
                    "content": "    yoavw:  What kind of glaring trail would you expect to find in the deployment?   I retracted my above comment on this, I realize I was only thinking of the create2 case. In the case of create you\u2019re right, there is no way to know and we have to just trust the deployer. This of course is not acceptable. If we add the requirement that invokers must only be deployed via create2 then that should no longer be an issue. The init code will clearly show if it can sideload code. However, after some more discussion, I think we\u2019re going to put chainid into the auth msg. You presented a compelling argument and although we could tell people to only deploy via create2, we\u2019ve come up with no use cases for multi-chain messages.     yoavw:  I\u2019m also talking about stateless checks. Specifically, check the same things that you already intend to check on a commit, but do it at the protocol level rather than the invoker. Enforce security in the infrastructure, not an individual contract.   Things like chainId and blockNumber can be checked statelessly, because they\u2019re already easily available in the current executing context. There are also no other interpretations of them. nonce is different. There are many different schemes for replay protection. For example, instead of a sequential nonce you could have a map of tx hash to bool. Enshrining specific nonce mechanisms makes it difficult to have new ones. But the main issue is where do you even store this data? Can\u2019t use EOA nonces because they\u2019re already used by the tx pool to determine tx validity. You could have special precompile with storage, but this would be the first time that\u2019s been done. This is how this EIP actually started, but then we realized the EIP was unlikely to be accepted if it did something weird like that. Finally you could modify the trie to add a new account type / field. Trie changes are very difficult to pull off and making it a prerequisite for the EIP essentially means it won\u2019t be scheduled anytime soon. Plus, none of these changes are as flexible as just allow invokers do arbitrary things.     yoavw:  The real discussion is about that philosophy.   IMO Ethereum\u2019s philosophy has always been to prefer abstraction over specific implementation when possible. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.256581041507512
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "18",
                    "likes": "0",
                    "time": "19/06/2021-01:05:25",
                    "content": "    matt:  Things like chainId and blockNumber can be checked statelessly, because they\u2019re already easily available in the current executing context. There are also no other interpretations of them.   So can to and calldata.  There\u2019s little downside in verifying that they\u2019re signed by the EOA.  That would remove most attack vectors except for replay.     matt:  nonce is different   Right.  That\u2019s the only one where there\u2019s a real downside.  The most secure option is to make it part of the protocol, e.g. by adding to the trie.  But I can see why you want to avoid that for practical reasons.  Another option is to use a very simple smart contract that implements the same nonce protection as the EOA one, using its own storage.  Technically it doesn\u2019t need to be a precompile, although a precompile with storage has been suggested before.  EIP-2935 does that in a way, to save historical block hashes. While such nonce is the most secure option, it has a clear downside since it is opinionated about the kind of replay protection used, and prevents different protection schemes that would allow better parallelization, more efficient batching, etc. Another option, less secure but more flexible, is to use multiple storage-based replay protection contracts and whitelist them through EIPs.  The AUTH opcode will get an address of a replay protection scheme and a nonce for it.  AUTH will verify this tuple along with the rest (to, calldata, chainid, etc.) and then each AUTHCALL would call that. Each such replay protection contract will be audited by the community and approved through an EIP so they\u2019ll have to meet a higher bar than normal contract.  And even if a bug is discovered in one, the implications will be a replay at worst, rather than arbitrary calls on behalf of the EOA. The least secure option would be the same as above, but without a whitelist.  Let each invoker use its own replay-protection contract.  It is likely that some of them will be buggy, but still less likely than an invoker having a bug, and with less severe implications since it\u2019s just the replay protection rather than the entire invoker. I\u2019m inclined to suggest the whitelist-through-EIP approach since it\u2019ll enable the same functionality we get with EIP 3074 with as little security risk as possible. As far as I can tell, an AUTH that checks the signature on everything (including the nonce and the contract that checks it), and ensures that this contract is in the whitelist, would let us achieve anything that EIP 3074 gives us, with a much lower risk. Anyone will be able to implement an invoker, while leaving the user in control by signing each call. And anyone would also be able to come up with a new replay protection scheme, but would have to wait for the next fork to whitelist it. Do you see any important EIP 3074 use-cases that this scheme can\u2019t support? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.7059132996633
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/matt",
                    "index": "19",
                    "likes": "0",
                    "time": "20/06/2021-17:23:54",
                    "content": "You\u2019ve laid out 3 options here:  Max security, put replay protection info in trie. Medium security, implement replay protection in separate smart contract and allowlist via EIP. Low security, implement replay protection in separate smart contract and use without allowlist.  Like I mentioned, option 1) is basically a non-starter. EIP-2935 received similar push back. Option 2) is at odds philosophically with Ethereum. The only time we\u2019ve done something similar to protocol-level allowlisting is with precompiles. This has been a major pain point in core development. Everyone wants their precompile in the next hard fork. Admittedly, precompiles are usually difficult to audit since they are usually implementing specific cryptographic primitives. But regardless, there is significant desire to allow people to write efficient cryptographic primitives without being blocked by hard forks and ACD.     yoavw:  Do you see any important EIP 3074 use-cases that this scheme can\u2019t support?   No, this should be able to support all use-cases. Please note, this will inherently be more expensive due the additional contract call and be more complex to handle the edge cases. Option 3) is really no different functionally than the current proposal of EIP-3074. Yes, the parameters of AUTH change slightly, but invoker implementers can just deploy their replay logic into a separate contract. \u2013 I argue that option 2) is equivalent to how we want EIP-3074 to be used in practice. If wallet developers do allowlist certain \u201csafe\u201d EIP-3074 invokers (like they\u2019ve indicated), then the only invokers people will be able to use are the ones that have been \u201cdecided\u201d as safe. I don\u2019t see why forcing core devs to debate and decide on this is better than wallet developers doing the same. If we don\u2019t trust the developers of the wallet we use to upgrade their software securely, I think we have bigger problems. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.379336734693878
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "20",
                    "likes": "0",
                    "time": "22/06/2021-16:46:46",
                    "content": "    matt:  Option 2) is at odds philosophically with Ethereum   AFAIK there\u2019s no precedent in Ethereum for anything as powerful as setuid, so it\u2019s hard to draw a philosophy from other precompiles.  EIP 3074 would be the equivalent of adding support for additional signature schemes (e.g. BLS), but instead of baking it into the protocol or into precompiles, allow anyone to deploy a contract that implements a new signature type which would work with any EOA for transacting with unaware contracts.  I doubt that would be within Ethereum philosophy either.     matt:  No, this should be able to support all use-cases. Please note, this will inherently be more expensive due the additional contract call and be more complex to handle the edge cases.   Yes, it adds the extra cost of an additional CALL.  I think it\u2019s worth the significant risk reduction. As for edge cases, what kind of edge cases would it complicate?  I would actually expect it to simplify things because it decouples replay protection from the rest of the invoker logic.  The replay protection will have a very simple ABI.  It just receives an opaque nonce signed by an EOA (as part of the AUTH message), checks whether this nonce is accepted, and \u201cburn\u201d that nonce.  If it fails for whatever reason (fails the nonce check or runs out of gas) the AUTH call reverts.  There seems to be little room for edge cases.     matt:  Option 3) is really no different functionally than the current proposal of EIP-3074.   From security perspective it is different.  EIP-3074 currently gives the invoker a blank check which can be easily abused.  option 3 only enables replay.  A malicious invoker combined with a malicious replay-verifier could, at worse,  replay a transaction previously signed by the EOA for the same chainid.  Whereas with the current EIP-3074, the invoker could make any transaction on behalf of any EOA that ever signed a message to it. I\u2019m less keen on option 3 because it does enable replay attacks by a malicious replay-checker, so I think it should be protected by an \u201cEIP-shield\u201d.  But even without the EIP protection, it\u2019s still much more secure than the current proposal.     matt:  I argue that option 2) is equivalent to how we want EIP-3074 to be used in practice.   I think it\u2019s not equivalent.  See the explanation above.  With option 2, a malicious/buggy invoker can do much less damage than with EIP 3074.     matt:  If wallet developers do allowlist certain \u201csafe\u201d EIP-3074 invokers (like they\u2019ve indicated), then the only invokers people will be able to use are the ones that have been \u201cdecided\u201d as safe.   This moves the power from the community (in the form of the public EIP process) to the wallet maintainers.  The maintainer of a widely used wallet gets the power to set the standard without going through the scrutiny of the EIP process.     matt:  I don\u2019t see why forcing core devs to debate and decide on this is better than wallet developers doing the same.   The public process may be inefficient, but it has the advantage of being public.  It\u2019s the community\u2019s way to decide for/against something. The congress with all its debates is also an inefficient way to set policy, but replacing it with an efficient private company seems too risky. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.272981601731602
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/matt",
                    "index": "21",
                    "likes": "0",
                    "time": "22/06/2021-18:24:28",
                    "content": "It seems like we fundamentally disagree on the philosophy of Ethereum. It\u2019s unlikely my position on the topic will change, so we can set aside that disagreement for now.     yoavw:  As for edge cases, what kind of edge cases would it complicate?   In option 2), if you require AUTH perform a call-like operation into a replay protection contract you\u2019ll need to specify the interface, like you said. This complicates the consensus specification, because right now it does not need to be specified at the consensus-level. The main edge case I have in mind is what happens if someone calls the replay protection precompile/contract independently of AUTH? How can you securely pass data to the replay protector from AUTH? Do you need to do a second ecrecover or do you bind the replay protection to CALLER or do you magically shuttle it to the precompile? Could this lead to a sponsor being griefed? Should that even be considered by the protocol? These aren\u2019t unanswerable questions, but it certainly doesn\u2019t simplify things.  From security perspective it is different. EIP-3074 currently gives the invoker a blank check which can be easily abused. option 3 only enables replay. A malicious invoker combined with a malicious replay-verifier could, at worse, replay a transaction previously signed by the EOA for the same chainid. Whereas with the current EIP-3074, the invoker could make any transaction on behalf of any EOA that ever signed a message to it.  As you describe option 3) above, it is no different from EIP-3074 from security perspective. A malicious replay protector can say every nonce is valid. At that point, the malicious invoker again has a \u201cblank check\u201d. There is nothing forcing either the invoker or replay protector to check any part of the commit, where the actions are actually specified. So if a user can be forced to interact with a malicious invoker, they are at equal risk as with EIP-3074 as it\u2019s written.     yoavw:  I think it\u2019s not equivalent. See the explanation above. With option 2, a malicious/buggy invoker can do much less damage than with EIP 3074.   A malicious invoker under option 2) has the opportunity of 1 blank check, whereas option 3) has N blank checks. After that nonce is burned in option 2), the damage is done. However, if you can trick a user to signing a tx to a bad invoker, it\u2019s safe to assume you can trick them into signing an arbitrary transaction. I\u2019ve stated on multiple occasions that the argument \u201cbut the worst that can happen is one bad tx\u201d is a very weak counter argument to batching. Batching is coming. Whether it\u2019s via meta-txs, ERCs, or EIP-3074. When that time comes, one bad signature will be able to empty an EOA. Even if you disregard the fact that batching is coming, I don\u2019t think \u201csecurity by diversification\u201d is a strong argument that 1 blank check is acceptable. I investigated this more a while back.     yoavw:      matt:  I don\u2019t see why forcing core devs to debate and decide on this is better than wallet developers doing the same.   The public process may be inefficient, but it has the advantage of being public. It\u2019s the community\u2019s way to decide for/against something. The congress with all its debates is also an inefficient way to set policy, but replacing it with an efficient private company seems too risky.   This is an unfair comparison. You\u2019re framing it like \u201cwallet developers will hold all the power privately and the community will be helpless\u201d. EIP-3074 allows permissionless innovation. If the wallet developers block the adoption of a certain invoker, the community could fork the wallet and add it to the whitelist. Or they could build a new wallet. This is far easier than forking Ethereum to bypass the core developers. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.96697542653425
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "22",
                    "likes": "1",
                    "time": "22/06/2021-21:36:40",
                    "content": "    matt:  It seems like we fundamentally disagree on the philosophy of Ethereum. It\u2019s unlikely my position on the topic will change, so we can set aside that disagreement for now.   And that\u2019s what I love about this ecosystem   Disagreeing on philosophy shouldn\u2019t stop us from building an optimal solution together.  It actually makes us less likely to fall into the trap of group-thinking.     matt:  In option 2), if you require AUTH perform a call-like operation into a replay protection contract you\u2019ll need to specify the interface, like you said. This complicates the consensus specification, because right now it does not need to be specified at the consensus-level.   Right.  It means that the interface has to be well defined, just like the args of AUTH itself.  I\u2019d make the ABI accept a signed AUTH message because it contains everything this contract needs.  It then checks that address(this) is specified as the replay protection contract, extract the EOA from the signature, and use the opaque nonce field in its own logic.  Doesn\u2019t seem difficult to define but perhaps I\u2019m missing something.     matt:  The main edge case I have in mind is what happens if someone calls the replay protection precompile/contract independently of AUTH?   Why is that a problem?  If a user chose to sign an AUTH message and send it directly to the replay protection contract, then the user simply burned a nonce without using it.  Just like sending a transaction to self.     matt:  How can you securely pass data to the replay protector from AUTH?   One way is to make it a part of AUTH so it will call the contract directly.  Another is to change the semantics of AUTH to authorize its caller rather than the current context, so AUTH will only be called inside these whitelisted replay verifiers, and then delegated to the invoker.  Neither seem ideal but let\u2019s try to find a better way.     matt:  Do you need to do a second ecrecover or do you bind the replay protection to CALLER or do you magically shuttle it to the precompile?   No need for a second ecrecover.  The invoker knows that it\u2019s calling a trusted replay protection contract which already does its own ecrecover.  If the replay protection call is successful, it means that ecrecover has already succeeded.  The call should return the recovered address.     matt:  Could this lead to a sponsor being griefed? Should that even be considered by the protocol?   It should be considered, at least to the point of making it possible for sponsors to avoid being griefed.  We don\u2019t need to make it impossible to write a bad sponsor that can be griefed though. Why does it open the sponsor to a griefing attack any more than an EIP 3074 does?  It implements exactly the same logic that the invoker would, except that the replay protection becomes an external call.  Wouldn\u2019t the same griefing vectors work on both?     matt:  These aren\u2019t unanswerable questions, but it certainly doesn\u2019t simplify things.   You\u2019re right - it doesn\u2019t simplify things.  It\u2019s not meant to.  It is meant to remove the need for signing blank checks and improve security, by introducing an additional trust boundary.  Adding trust boundaries to a system always complicates its internal interactions, but it\u2019s still essential to the security of any complex system. Consider hardware security mechanisms like SGX (or any HSM for that matter).  The programming model of SGX is a pain to work with.  It\u2019s much easier to just keep all the secrets in your usermode process memory, perform all operations there, and not have to deal with context switches and stateless ops.  But this model makes it possible to secure sensitive operations in a way that protects them from bugs in the rest of the code. If a system has a small number of sensitive operations, it makes sense to separate them and make them less vulnerable to bugs in the rest of the system.  My suggestion is to do just that.  If the user signs everything except for the replay protection, then AUTH/AUTHCALL are no longer a major risk.  The only remaining risk point is the replay protection, so I\u2019m trying to separate that part.     matt:  As you describe option 3) above, it is no different from EIP-3074 from security perspective. A malicious replay protector can say every nonce is valid. At that point, the malicious invoker again has a \u201cblank check\u201d. There is nothing forcing either the invoker or replay protector to check any part of the commit, where the actions are actually specified. So if a user can be forced to interact with a malicious invoker, they are at equal risk as with EIP-3074 as it\u2019s written.   That\u2019s not what option 3 says.  In all three options, I\u2019m only referring to the replay protection, because I assume we already replaced commit with the actual content:     yoavw:  AUTH will replace the commit hash with a typed structure containing a list of authorized calls. For each call, {nonce,to,gas,calldata,value,chainid} will be specified. The signature will be verified, and the entire list will be saved as authorized_transactions instead of the authorized address variable. AUTHCALL will get a new arg, index, which points to an address in the list created by the last AUTH.   \u2026     yoavw:  The AUTH opcode will get an address of a replay protection scheme and a nonce for it. AUTH will verify this tuple along with the rest (to, calldata, chainid, etc.)   so regardless of the replay protection, AUTHCALL no longer has a blank check.  At most, if replay protection is broken, it can AUTHCALL a previously used call.  There\u2019s no commit in this model.     matt:  So if a user can be forced to interact with a malicious invoker, they are at equal risk as with EIP-3074 as it\u2019s written.   I don\u2019t think it is.  Let\u2019s assume the user is forced to interact with a malicious invoker.  With EIP 3074 it means that the user loses control over the EOA forever.  With option 3, there may be two cases:  The user interacts with a malicious invoker which uses a legit replay protector.  In that case there is no risk.  The invoker can decide whether to perform the AUTHCALL or not, but otherwise has no way to hurt the user. The user interacts with a malicious invoker which uses a malicious replay protector.  This is not possible in option 2 because replay protectors are whitelisted in an EIP.  With option 3 it\u2019s equivalent to not having a trusted replay protector, so the user\u2019s transaction may be replayed any number of times in the future.  But still, it cannot be modified by the malicious invoker.  If the user has 100 DAI and 100 UNI in an account, and signs a transfer of 10 DAI, the malicious invoker can replay it 10 times and steal all 100 DAI, but it can\u2019t touch the UNI.  It\u2019s pretty bad, but not nearly as bad as a malicious invoker in EIP 3074.  And yet, that\u2019s why I prefer option 2 which also mitigates that.      matt:  A malicious invoker under option 2) has the opportunity of 1 blank check, whereas option 3) has N blank checks. After that nonce is burned in option 2), the damage is done.   It\u2019s not what the options say.  In all three options, there are no blank checks.  AUTH verifies the entire content that used to be covered by commit.  The only thing that differs between the three options is how nonce is interpreted.     matt:  However, if you can trick a user to signing a tx to a bad invoker, it\u2019s safe to assume you can trick them into signing an arbitrary transaction. I\u2019ve stated on multiple occasions that the argument \u201cbut the worst that can happen is one bad tx\u201d is a very weak counter argument to batching. Batching is coming. Whether it\u2019s via meta-txs, ERCs, or EIP-3074. When that time comes, one bad signature will be able to empty an EOA.   Batching is coming, but it doesn\u2019t have to mean that a single bad signature will compromise the EOA forever.  In the model I suggested above, the user signs a message containing one or more AUTHCALL data.  If the user was tricked to misunderstand some of them, then yes, there will be damage.  But it doesn\u2019t mean the user loses control of the EOA.  With EIP 3074 it does. Batching, in itself, shouldn\u2019t change the Ethereum security model.  The user still needs to authorize every transaction in the batch, just like without batching.  The only difference is that they end up being batched for efficiency.  If by batching you mean that the user doesn\u2019t need to authorize each transaction, then it completely changes the Ethereum security model.     matt:  Even if you disregard the fact that batching is coming, I don\u2019t think \u201csecurity by diversification\u201d is a strong argument that 1 blank check is acceptable. I investigated this more a while back.    I do think batching is coming (and should come).  It just doesn\u2019t require blank checks. I didn\u2019t suggest \u201csecurity by diversification\u201d.  Do you see an blank checks in my suggestion?      matt:  EIP-3074 allows permissionless innovation.   It does.  I never meant that it stops innovation.  I\u2019m more concerned about security.  The issue is not whether the community can or cannot deploy new invokers (I know it can).  It\u2019s whether a malicious wallet maintainer who \u201cplays the long game\u201d (or just has a bug in the invoker) can cause. A wallet maintainer could devise tricks like the ones I suggested in my first post.  The wallet would look honest for months or even years, while collecting signatures.  Then, when enough money is on the table, become malicious.  For example, the wallet maintainer could use the delegation flow I suggested, allowing its maintainer to take over governance of other projects.  The users who just use the wallet for trading, will never notice or complain. Putting that kind of power in private hands creates incentives for certain people to exploit the system.  At some point someone definitely will.  By making it public, requiring replay protection to pass the EIP process, it becomes much harder to hide such schemes. Admittedly, a wallet maintainer could achieve the same goal by stealing and sending private keys to a server and performing the attack from there.  However it is far harder to hide that, than to hide a bug in an invoker or not even hide anything at all - just deploy the bad invoker to the other chain after a year (with the current EIP 3074 which excludes chainid). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.010231996839139
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/matt",
                    "index": "23",
                    "likes": "0",
                    "time": "23/06/2021-03:29:03",
                    "content": "    yoavw:  That\u2019s not what option 3 says. In all three options, I\u2019m only referring to the replay protection, because I assume we already replaced commit with the actual content:   Ah, I see. I apologize, I\u2019m having trouble keeping track of the different posts  \u2013 Unfortunately it doesn\u2019t seem like this debate is going anywhere beside nitpicking and trying to keep track of different arguments. I respect your point of view, but I fundamentally disagree with it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "None",
                        "None",
                        "None",
                        "None"
                    ],
                    "Sentiment": 4.416666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "24",
                    "likes": "0",
                    "time": "23/06/2021-12:05:45",
                    "content": "    matt:  Unfortunately it doesn\u2019t seem like this debate is going anywhere beside nitpicking and trying to keep track of different arguments. I respect your point of view, but I fundamentally disagree with it.   Alright.  I respect your point of view as well.  Since we\u2019re not collaborating effectively on a modified proposal, I guess EIP 3074 really is a take it or leave it proposition. We\u2019ll leave it for the community to decide whether to accept it as-is, despite the security issues I pointed out.  If it doesn\u2019t get included we can get back to it and propose something with a different risk profile. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/d10r",
                    "index": "25",
                    "likes": "1",
                    "time": "24/06/2021-16:45:25",
                    "content": " I\u2019m not convinced that enshrining single-use transaction-like packages is the way to go  In case you\u2019re worried about the UX of that: consider that wallets could provide per-tx signatures for specific purposes in the background without bothering the user. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "26",
                    "likes": "1",
                    "time": "24/06/2021-22:47:03",
                    "content": "I\u2019ve been thinking about this thread a bit, and I\u2019ve read up a bit on the types of vulnerabilities that @yoavw has highlighted, and how he\u2019s compared it to setuid. The thing is, at the heart of the matter I think we agree: Accounts should delegate the minimum possible authority outside of themselves. The disagreement comes from \u201cat what layer should we allow EOAs to delegate their authority?\u201d If the only use of delegation were batching and MetaTransactions, then I think yoav\u2019s simpler proposal would be sufficient. But I believe that delegation is fundamental to secure composition, and my interest in 3074 goes far beyond those two use cases. 3074 provides the minimum foundation for a general-purpose delegation framework for EOAs. Yes, it\u2019s dangerous because an initial delegation to a bad invoker can be catastrophic. But, if the invoker is very well audited, and is designed to allow finer-grained additional delegation, we could compose chains of delegations where each link can gain no additional authority. This is a pattern that I\u2019ve been looking out for and have described as ethereum object capabilities. By providing accounts an initial capability to delegate, we provide a fundamental tool that can be used to enable fine-grained delegations of any sort, and I think this can start to look much more like yoav\u2019s ideal security environment, where additional processes more frequently are truly only getting the capabilities they require. It may feel counter-productive, or ironic that in order to allow an EOA to delegate the minimum possible authority, they must first be able to delegate any authority, but I think this is basically a result of the EOA\u2019s inability to delegate any authority at the protocol level today. Under the current simplified proposal, any time we want an extra delegation-related feature for accounts, we would need to go through the process of getting it accepted at the base layer of the blockchain. Alternatively, by providing the two very simple opcodes of 3074, we are able to provide any type of delegation in the future on top of the platform, without additional consensus changes. I think Micah said it very well,     MicahZoltu:  Don\u2019t solve a problem on a lower layer that can be solved by a higher layer, especially when the solution involves restricting possibilities.   ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.517241379310345
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "27",
                    "likes": "1",
                    "time": "24/06/2021-23:50:55",
                    "content": "    danfinlay:  and how he\u2019s compared it to setuid   Thanks, but I can\u2019t take credit for that, although I fully agree with this analogy.  I was just quoting @SamWilsn who correctly pointed out that EIP 3074 is setuid and not sudo.     danfinlay:  But, if the invoker is very well audited   Even if it is perfectly audited, there could be unforeseen risks.  Consider the cross-chain attack I demonstrated.  The invoker on the first chain was perfectly secure, but once the user moves assets across a bridge to the other chain, there\u2019s a malicious invoker waiting to attack.  The user never interacted with the invoker on the other chain.  That invoker didn\u2019t even exist at the time the user signed the message.  This particular vector can be fixed easily by including chainid in the signed message, but the point I was trying to make is that excluding anything from the signed message opens up vectors we may be missing.  There\u2019s little downside in including everything, and a potentially unlimited downside in excluding anything.     danfinlay:  we could compose chains of delegations where each link can gain no additional authority   I like this chain idea!  It\u2019s getting pretty close to capabilities in the Linux sense.  The only problem is that each single-capability-invoker is given full access by the user, and we rely on its implementation to restrict the actual action. My question is why can\u2019t we implement exactly that chain, using the method I suggested.  My suggestion is to require that the user (wallet) signs a list of AUTHCALLs rather than a single commit.  If the chain involves 5 operations by different invokers, then with EIP 3074 the user would be signing 5 different AUTHs, each of them with full access to another invoker.  My suggestion is to sign a specific AUTHCALL for each.  So if one of these invokers is buggy, it is still limited to the operation signed by the wallet.  We get exactly the same functionality, at the same cost, but with much lower risk. The UX also remains identical because the wallet would be aware of these 5 invokers and the AUTHCALLs they\u2019re going to make.  So a wallet that supports these operations could represent them as a single action for the user to see, and then sign a transaction with these 5 AUTHCALLs rather than 5 AUTHs. Am I missing something that would break the chained-invokers idea if we use my proposal?     danfinlay:  I think this can start to look much more like yoav\u2019s ideal security environment, where additional processes more frequently are truly only getting the capabilities they require.   Yes, I think this could be great.  We see things similarly.  The part that I\u2019m missing is why we need the full access AUTH to achieve this, rather than signing each of these AUTHCALLs.     danfinlay:  It may feel counter-productive, or ironic that in order to allow an EOA to delegate the minimum possible authority, they must first be able to delegate any authority   Right.  I think we can achieve the same without having to give up so much control over the EOA.  Just sign every operation instead of a single blank check.     danfinlay:  Under the current simplified proposal, any time we want an extra delegation-related feature for accounts, we would need to go through the process of getting it accepted at the base layer of the blockchain   You mean my proposal?  I wasn\u2019t proposing whitelisting the invokers.  Anyone would be able to deploy an invoker and the risk is much lower because an invoker in my proposal can only perform actions signed by the user.  Not through a commit to be interpreted by the invoker, but an actual AUTHCALL. The part that we\u2019ve been debating re whitelist is just the replay protection.  If the user has to sign the entire AUTHCALL and the protocol verifies this, then we are stuck with the current nonce implementation which is less friendly to batching.  We were debating whether replay protection should be implemented as separate contracts, and those would be whitelisted.  In practice I don\u2019t expect to see too many different replay protection schemes, but I do expect to see many different invokers.  My proposal doesn\u2019t hinder invoker innovation.  It just slows down replay-protection implementations. And even if we dropped the whitelist entirely, as I suggested in option 3, we still end up with better security than the current EIP.  A buggy invoker might lead to a replay, but it would never lead to performing actions the user never signed. What are the downsides of having the wallet sign things like to and calldata for each AUTHCALL? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.65160406885759
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "28",
                    "likes": "0",
                    "time": "25/06/2021-00:05:25",
                    "content": "    yoavw:  Consider the cross-chain attack I demonstrated. The invoker on the first chain was perfectly secure, but once the user moves assets across a bridge to the other chain, there\u2019s a malicious invoker waiting to attack.   I think cross-chain is worth considering, but is well accounted for by adding a chain_id parameter to the commitment within the invoker contract. Since it can be such a well documented best practice for an invoker, it seems like it can safely live in either place, but I actually don\u2019t feel very strongly about this. I used the \u201cmultiple-chain delegation\u201d as a hypothetical example (it might be nice to be able to delegate cross-chain permissions with a single signature), but it seems like a small enough change I really could go either way on the chain_id point.     yoavw:  My question is why can\u2019t we implement exactly that chain, using the method I suggested. My suggestion is to require that the user (wallet) signs a list of AUTHCALLs rather than a single commit. If the chain involves 5 operations by different invokers, then with EIP 3074 the user would be signing 5 different AUTHs, each of them with full access to another invoker. My suggestion is to sign a specific AUTHCALL for each. So if one of these invokers is buggy, it is still limited to the operation signed by the wallet. We get exactly the same functionality, at the same cost, but with much lower risk.       yoavw:  I think we can achieve the same without having to give up so much control over the EOA. Just sign every operation instead of a single blank check.   My impression is that if this were implemented in this way, these delegations would need to be redeemed in the order they are issued, which tightly couples issuer to redeemer. By allowing an invoker to implement arbitrary redemption logic, we can have \u201ccounterfactual\u201d, order-free capabilities being shared, that can be redeemed lazily (resulting in fewer on-chain transactions). Some delegations might be good for multiple calls.  DAIv2 style permit(): It allows issuing a token allowance with a single signature. The redeemer can then redeem/use their allowance in any number of transactions, as long as they don\u2019t exceed that limit. vote-delegation: I might trust another account to vote on a particular topic or a particular DAO on my behalf, any number of times, until revocation.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.631066156066157
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "29",
                    "likes": "0",
                    "time": "25/06/2021-01:22:06",
                    "content": "    danfinlay:  but is well accounted for by adding a chain_id parameter to the commitment within the invoker contract   I demonstrated why it isn\u2019t, with the contracts I deployed and linked earlier in this thread.  The commitment is only checked on the first chain.  The invoker on the second chain doesn\u2019t even look at the commitment, and just does whatever it wants with the user\u2019s AUTH.  The bad invoker on the second chain was deployed after the user already signed the auth on the first chain and was not aware of a future malicious invoker on another chain.  Therefore chain_id must be checked by the protocol itself, not by the invoker. But my chain_id example was just to demonstrate the point, that anything not covered by the protocol-level check may lead to unintended consequences.  The current version of the EIP missed that vector.  A fixed version that only adds chain_id might still miss other vectors that I haven\u2019t noticed in my preliminary audit.  But if we enforce all the fields at the protocol level, there are no cases to miss. Therefore I think anything should be covered directly by the signature unless there\u2019s a good reason against it.     danfinlay:  these delegations would need to be redeemed in the order they are issued   Why do they need to be ordered?  My proposal was to sign a list of call-hashes in AUTH, and then to have AUTHCALL refer to an index in that list.  The invoker would be able to trigger them in any order. But why wouldn\u2019t the wallet arrange them in the expected order?  It knows what\u2019s going to happen in the transaction, and could sign a list in the right order.     danfinlay:   DAIv2 style permit(): It allows issuing a token allowance with a single signature. The redeemer can then redeem/use their allowance in any number of transactions, as long as they don\u2019t exceed that limit.    The user can create an allowance that will last for any number of transactions, without having to repeat it every time.  When the allowance runs out, the user needs to create a new allowance.  It keeps the user in control.  If the user wants to only sign one allowance message and have it last forever, then sign a max allowance.  If the user signs a smaller allowance, it means that the user wishes to stay in control of spending, so the invoker should respect that anyway and let the user sign the next allowance.  No need to sign an open check for the invoker to auto-renew the allowance.     danfinlay:   vote-delegation: I might trust another account to vote on a particular topic or a particular DAO on my behalf, any number of times, until revocation.    I think this kind of functionality belongs in smart contracts, not invokers.  Most voting contracts explicitly support delegation (e.g. Uniswap style governers).  When the user signs such delegation, it\u2019s explicit and the user is in control.  By making it easy for invokers to vote directly without the user signing a delegation, we\u2019re opening the network to attacks like the governance-hijacking I described in my first post.  This scenario is exactly the one I\u2019m trying to prevent with my proposal. I think invokers shouldn\u2019t replace smart contracts.  They should add functionality that is hard to achieve with smart contracts due to EOA limitations.  Vote-delegation and allowance-management don\u2019t seem to fall in that category. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.4934309876170335
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "30",
                    "likes": "0",
                    "time": "25/06/2021-02:48:04",
                    "content": "    yoavw:  The invoker on the second chain doesn\u2019t even look at the commitment, and just does whatever it wants with the user\u2019s AUTH. The bad invoker on the second chain was deployed after the user already signed the auth on the first chain and was not aware of a future malicious invoker on another chain. Therefore chain_id must be checked by the protocol itself, not by the invoker.   This requires a user to delegate to an invoker that can be published at the same address with arbitrarily different code. That is worth avoiding, but is not unavoidable. Invokers can be published in a way where the code is statically committed to, using CREATE2, and lacking a SELFDESTRUCT op code. Those could be enforced at the wallet level.     yoavw:  The user can create an allowance that will last for any number of transactions, without having to repeat it every time. When the allowance runs out, the user needs to create a new allowance.   I think you\u2019re talking about using the token\u2019s own allowance function. I guess using a token allowance wasn\u2019t an ideal example, since ERC-20 token contracts do provide this kind of delegation for themselves, but they do not provide it in a recursively chainable form. On the other hand, if an allowance invoker were made, it could allow counterfactual allowances to not only be performed on tokens that never wrote a permit() method, but those allowances could themselves be delegated, allowing recursive allowance graphs, which could form webs of trust with credit, all without publishing a single contract. The fact that some smart contracts implement delegation for some of their functions is nice, but with a standard delegation framework, contract authors could ignore delegation as a feature, get it for free for all functions, and users could benefit from having those benefits on all contracts. This simplifies secure contract development (since you aren\u2019t asking each developer to re-implement a safe delegation contract).     yoavw:  Most voting contracts explicitly support delegation (e.g. Uniswap style governers). When the user signs such delegation, it\u2019s explicit and the user is in control.   It would be no different if delegation invokers were well vetted and integrated as an optional user action into wallets. The user would always have explicit control over anything they did. I\u2019m not sure how you\u2019re imagining invokers working, but it seems like you\u2019re imagining some YOLO step that none of us are proposing.     yoavw:  By making it easy for invokers to vote directly without the user signing a delegation, we\u2019re opening the network to attacks like the governance-hijacking I described in my first post. This scenario is exactly the one I\u2019m trying to prevent with my proposal.   Your initial example relies on a malicious dex performing a long-con where it deploys its own batching invoker, relies on wallets adding it without scrutiny, long-cons many users into adding it to their wallets, and performs malicious behavior that would\u2019ve been obviously possible to any single person who\u2019d reviewed it. This seems to miss the repeated point that invokers should not be trusted by wallets carelessly. Your scenario requires wallets that are allowing installing invokers with basically no review or warning process for helping users identify dangers, even from an easily-identified malicious contract. Those dangers could be mostly eliminated with just some basic diligent assurances:  Most wallets only ever integrate invokers they\u2019ve vetted as if it were their own internal code. Any wallet that allows adding arbitrary invokers needs to at least warn the user that this contract could be stealing all of their funds (and yes, users should learn to respect such warnings). Ideally it would also require a verified contract source code, and would include an audit-warning system, for notifying users of known malicious contracts.      yoavw:  I think invokers shouldn\u2019t replace smart contracts. They should add functionality that is hard to achieve with smart contracts due to EOA limitations. Vote-delegation and allowance-management don\u2019t seem to fall in that category.   I think in a permissionless ecosystem we should embrace tools that allow us to safely innovate. When I see a tool for generalized delegation, I see enormous potential. Allowances and vote delegation are easy examples to describe, but the actual applications are basically all authority related functions. Anything with an onlyOwner would be made more dynamic with an option to delegate. I feel a little weird that I\u2019m about to provide more examples in defense of \u201cdelegation\u201d as a useful tool, because to me it\u2019s perhaps the most obviously useful tool, but I will list more examples that come to mind:  Ability to assign the target of an ENS entry could be shared with an arbitrary group, designated counterfactually. (This could be like sharing the ability to update a website) Ability to freeze a contract (in case of a security threat being discovered) Ability to propose an expense to a DAO (web of trust for proposals) Ability to issue a NFT as part of a collection (artist collectives) Ability to make a move in a game (crowd-sourced gaming) Ability to accept a bounty (web of trust for certified contractors) Ability to buy an exclusive item, like an event ticket (a referral fee could be added as part of the delegation, sometimes called incentive trees)  And yes, delegation can and should live at the smart contract account layer, but that is no reason to ban it from the EOA layer as well. It\u2019s a generally useful tool for composition, and a permissionless ecosystem thrives when composition is cheap and safe. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.799967532467533
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "31",
                    "likes": "0",
                    "time": "25/06/2021-13:52:15",
                    "content": "    danfinlay:  Those could be enforced at the wallet level.   To stop this particular attack because I already highlighted it.  We don\u2019t know how many others exist.  The problem is, if an attack vector is discovered and fixed in a wallet at some point in the future, all EOAs that used the wallet and the invoker in the past are still compromised by it. Suppose we didn\u2019t know about the attack vector I described, and didn\u2019t enforce the CREATE2-only rule, and users already used invokers on different chains.  And then I publish about it and all the wallets add this check.  Any user who previously used an invoker that was created by CREATE is potentially compromised and needs to move all assets immediately, on all chains.  In some cases this won\u2019t even be possible, e.g. with locked tokens. One of the major issues with EIP 3074 is that it\u2019s impossible to fix things in hindsight.  Past vulnerabilities will continue to haunt users, long after they\u2019re fixed.  This could have been prevented by checking everything rather than just a commit.     danfinlay:  On the other hand, if an allowance invoker were made, it could allow counterfactual allowances to not only be performed on tokens that never wrote a permit() method, but those allowances could themselves be delegated, allowing recursive allowance graphs, which could form webs of trust with credit, all without publishing a single contract.   The same could be achieved with the user signing the allowance, since the allowance itself persists so no need to also persist the capability to increase it from an invoker.  An invoker (whether based on EIP 3074 or on my proposal) doesn\u2019t need the token to support permit().  The user signs an allowance (once), entrusting the contract to withdraw from the desired token.  From then on, things like gas abstraction can rely on that allowance.  The invoker can check the cost of the user transaction and withdraw from the allowance, without needing to reestablish the allowance.  If the allowance runs out because the user limited it, then the user needs to sign a new one as part of the next transaction.  Still no need to give the invoker the power to renew the allowance without the user\u2019s consent.  And the allowance could also be delegated by the invoker as well, still without being able to increase it.     danfinlay:  This simplifies secure contract development (since you aren\u2019t asking each developer to re-implement a safe delegation contract).   With the trade-off of adding a much riskier construct.  I\u2019d rather see each contract implement its own delegation, and if the contract is buggy it will have an adverse effect on that contract, than see a single buggy invoker that compromises all contracts at once.  Privilege separation limits the potential damage of each bug.  The current AUTH removes this separation and puts all the power in a single contract, hoping that it is completely safe.  The proverbial putting all the eggs in one basket.     danfinlay:  It would be no different if delegation invokers were well vetted and integrated as an optional user action into wallets. The user would always have explicit control over anything they did. I\u2019m not sure how you\u2019re imagining invokers working, but it seems like you\u2019re imagining some YOLO step that none of us are proposing.   I\u2019m not imagining a YOLO invoker.  My concern is a buggy/malicious contract that slips through the audits.  Things slip through audits all the time, but their consequences are usually limited.  A buggy invoker would compromise everything at once.  Any EOA that ever used it, every contract that gives any of these EOAs power (ownership, voting, etc). So I guess in a way I would consider any transaction to an invoker an act of YOLO.  It assumes that the invoker is perfect and trusts it with all assets, now and in the future.     danfinlay:  Your initial example relies on a malicious dex performing a long-con where it deploys its own batching invoker, relies on wallets adding it without scrutiny,   Or with scrutiny that misses an intentional bug.  It\u2019s really hard to find intentional bugs and many of them can lurk in trusted code for years despite many audits.  Never assume that any code is 100% bug free, especially if there\u2019s an incentive for the developer to introduce a bug.     danfinlay:  Your scenario requires wallets that are allowing installing invokers with basically no review   I do assume a review.  I just assume that the reviewers will miss some bugs, as they often do.  The consequences of missing an invoker bug are far worse than the consequences in any other contract.  A bug in a widely used invoker would make TheDAO look like a minor incident.     danfinlay:  And yes, delegation can and should live at the smart contract account layer, but that is no reason to ban it from the EOA layer as well. It\u2019s a generally useful tool for composition, and a permissionless ecosystem thrives when composition is cheap and safe.   All the use cases in the list are possible to do without giving the invoker infinite power, by implementing these capabilities in contracts.  When we\u2019re considering adding something so risky, we should only consider use-cases that couldn\u2019t be supported by less risky means.  If the same innovation could be supported without the risk, then adding a riskier way to support them seems like a bad trade-off. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.363947510822511
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/JamesZaki",
                    "index": "32",
                    "likes": "0",
                    "time": "01/07/2021-04:46:43",
                    "content": "What a thread to catch up on. I previously looked into EIP 3074 as it was comparable to what I\u2019m implementing purely in smart contracts. It factors in the concerns being discussed here around invoker implementation/trust, and replay protection via chainid & nonce. So although not at the protocol level this might be a less-risky implementation of AA, albeit less elegant in some ways. Here the \u201cinvoker\u201d contract (VerificationGateway.sol) is responsible for generating the smart contract wallets given a public key and corresponding signed data (BLS sig scheme). A user\u2019s BLSwallet contract can make a generic .call with arbitrary data only if called from its invoker (see action). The contract wallet is also responsible for incrementing its nonce. A user must sign the chainId and the wallet contract\u2019s nonce with the call data (amongst other things). This signed message can then be passed to the invoker to then action the corresponding signer\u2019s BLSWallet. Anyone (eg aggregator) can submit these signed messages to the invoker contract, and they are incentivised by a token reward. The amount to pay is part of the message signed for and is transferred by the invoker when making the wallet call. There will also be a demo to construct, sign, and submit a dapp\u2019s smart contract calls (individually or batched), and it might be some time before we see such things implemented in wallet plugins/apps/hardware. ",
                    "links": [
                        "https://github.com/jzaki/bls-wallet/blob/main/contracts/BLSWallet.sol#L43",
                        "https://github.com/jzaki/bls-wallet/blob/main/contracts/VerificationGateway.sol#L261",
                        "https://github.com/jzaki/aggregator"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.329034391534392
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "33",
                    "likes": "0",
                    "time": "01/07/2021-10:27:12",
                    "content": "    yoavw:  When we\u2019re considering adding something so risky, we should only consider use-cases that couldn\u2019t be supported by less risky means. If the same innovation could be supported without the risk, then adding a riskier way to support them seems like a bad trade-off.   My position on this as well. Though I do not have as much patience as you do to keep arguing  I feel like there is a fundamental change in what it means to give a signature. But arguments usually involve lots of use cases that I need to get into, and I get the feeling that the \u201cburden of proof\u201d is the reverse of what it should be. I also suggested an alternative, which may be similar to yours (multi-signature transaction type), but I do not have time to prepare an EIP properly, so I effectively lose the arguments because of that  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.802083333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "34",
                    "likes": "1",
                    "time": "01/07/2021-10:55:07",
                    "content": "I am of the opinion that the 3074 authors have put forth a herculean effort to address all arguments.  At this point, I do think the burden falls to others to construct a complete and sound counter-argument.  Without that, then any proposal could be shot down by just someone saying \u201cI\u2019m not convinced\u201d (perhaps without even reading through/understanding everything), and that would rapidly lead to stagnation. I suspect the root cause of disagreement with you is similar to others, which is whether the EVM language should be a collection of powerful primitives that others can build things on (some of which will be safe, some of which will not be safe), or if the EVM consists of higher level more limited power primitives that are designed to protect users.  3074 introduces a new primitive that someone can use incorrectly, but it also is an incredibly flexible primitive that opens a lot of doors for people to leverage in safe ways. Fundamentally, just like today you should not be signing arbitrary transactions, and you also MUST trust your wallet tooling with your private keys.  It is the wallet\u2019s job to protect users from signing things that are bad for the user, not the EVM\u2019s job.  The EVM\u2019s job is to give people useful primitives to build interesting things. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.07204986371653
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/matt",
                    "index": "35",
                    "likes": "0",
                    "time": "01/07/2021-13:30:34",
                    "content": " I get the feeling that the \u201cburden of proof\u201d is the reverse of what it should be  We have had two security (1, 2) audits of the specification and have discussed the EIP at length with many developers at all different level of the stack. We have yet to find any security issues with EIP-3074 itself, only philosophical disagreements about how expressive the EVM should be and how the EIP fits into the longer term picture of the protocol. I\u2019m not aware of a succinct proof-of-safety for EIPs yet, so unfortunately there is some burden for those against the change to engage in the conversation. If there is something you feel like hasn\u2019t been addressed, we would be happy to try addressing it  ",
                    "links": [
                        "https://docs.google.com/document/d/1itvPn7BhZ9N8h27d1Ig5C86_FZpyG5_cdpsuPJYmb-o/edit"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.921875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "36",
                    "likes": "0",
                    "time": "01/07/2021-16:45:24",
                    "content": "    matt:  only philosophical disagreements about how expressive the EVM should be and how the EIP fits into the longer term picture of the protocol.   I do not really think this is the philosophical disagreement, but rather security assumption, that, once given up, cannot be taken back, without disallowing the introduced opcodes later. And I do appreciate all the work you guys did when engaging with concerns, kudos to you. I believe no amount of explanations can make this proposal more secure without fundamental change (removal of perpetual irrevocable delegation). And for both security audits, the issue that concerns me was taken out of scope, the auditors decided either intentionally or un-intentionally to avoid this issue, by saying: \u201cEIP recommends users to do X to avoid problems\u201d, or not looking into this aspect at all. But anyway, I already gave up on this, to be honest. Cannot be involved into everything  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.181818181818182
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "37",
                    "likes": "0",
                    "time": "06/07/2021-23:30:38",
                    "content": "    AlexeyAkhunov:  My position on this as well. Though I do not have as much patience as you do to keep arguing    Hard to blame you.  I think everyone lost patience at some point.     AlexeyAkhunov:  I get the feeling that the \u201cburden of proof\u201d is the reverse of what it should be.   Exactly.  When adding something so risky, to achieve things that could be achieved with less risk, the burden of proof should be on the proposer.  I don\u2019t feel this has been met.     MicahZoltu:  I am of the opinion that the 3074 authors have put forth a herculean effort to address all arguments. At this point, I do think the burden falls to others to construct a complete and sound counter-argument. Without that, then any proposal could be shot down by just someone saying \u201cI\u2019m not convinced\u201d (perhaps without even reading through/understanding everything), and that would rapidly lead to stagnation.   I believe I did provide such counter-argument and brought sufficient evidence.  I don\u2019t think you could reasonably blame me for just saying \u201cI\u2019m not convinced\u201d without supporting my stance.  I spent many hours on this discussion, on demonstrating the problems, deploying contracts, participating in side discussions about it, etc.  Arguably, others in this discussion are pulling the \u201cI\u2019m not convinced\u201d card by saying that it\u2019s just a philosophical disagreement rather than a technical problem that should be resolved before proceeding.  It\u2019s basically \u201cagree to disagree\u201d, but we all \u201clive\u201d in the same Ethereum so we have to agree eventually.     MicahZoltu:  I suspect the root cause of disagreement with you is similar to others, which is whether the EVM language should be a collection of powerful primitives that others can build things on (some of which will be safe, some of which will not be safe), or if the EVM consists of higher level more limited power primitives that are designed to protect users. 3074 introduces a new primitive that someone can use incorrectly, but it also is an incredibly flexible primitive that opens a lot of doors for people to leverage in safe ways.   I think you described this argument well in one of your earlier posts, when you compared it to low-level languages that don\u2019t implement any protection.  And you\u2019re right - low level languages shouldn\u2019t put restrictions, and should make anything possible as long as the hardware allows it. However\u2026 nobody uses low languages like C to develop financial systems that hold billions of dollars.  We write the kernel in C (and recently a bit of Rust), but when coding complex logic that handles things like finance, we don\u2019t need capabilities such as executing code from heap/stack or implement self-modifying code, so we drop these capabilities in favor of a more restricted VM like JVM, with memory protection and strong separation between code and data.  It doesn\u2019t allow us to do certain cool things that we can do with C/C++ (and I love trampoline functions and lazy linkage as much as the next guy) but it helps us build secure systems when dealing with complex business logic.  Low level languages definitely have their place (and it\u2019s where I feel most at home, being a hacker and a kernel/hypervisor developer), but I don\u2019t think EVM is the right place for such powerful low level primitives.  Security should be top of mind here.     MicahZoltu:  It is the wallet\u2019s job to protect users from signing things that are bad for the user, not the EVM\u2019s job.   With EIP 3074 the wallet can\u2019t really do that.  You can only protect users from threats you currently know about, but the user\u2019s signature can be abused at any later time, after the threat becomes known.  For example, the cross-chain attack I mentioned would not be mitigated by a wallet maintainer who hasn\u2019t thought of that, and there\u2019s nothing in the EIP about requiring that invokers are created using CREATE2.  Now that I demonstrated this attack, wallets will stop users from interacting with CREATEd invokers, but what if I had brought it up only a few months after the EIP was merged in?  Wallets would upgrade and stop interacting with such invokers, but anyone who previously signed an AUTH to such invoker is screwed already.  An attacker could exploit past signatures even after the wallets are upgraded to mitigate that specific attack.  And this attack is just one example.  The point is that any future attack could make everyone vulnerable and the wallet would be powerless to help.     matt:  We have yet to find any security issues with EIP-3074 itself, only philosophical disagreements about how expressive the EVM should be and how the EIP fits into the longer term picture of the protocol.   I believe I did demonstrate attacks that the audits ignored, and that cannot be mitigated by EIP 3074 as-is.     matt:  If there is something you feel like hasn\u2019t been addressed, we would be happy to try addressing it   I think the issues haven\u2019t been addressed but we seem to disagree on that. And as for the burden of proof, since we\u2019re talking about adding an opcode that is riskier than anything added before, I think the burden of proof is on the suggester to show why the required use-cases cannot be achieved by less risky means.     AlexeyAkhunov:  I do not really think this is the philosophical disagreement, but rather security assumption, that, once given up, cannot be taken back, without disallowing the introduced opcodes later. And I do appreciate all the work you guys did when engaging with concerns, kudos to you. I believe no amount of explanations can make this proposal more secure without fundamental change (removal of perpetual irrevocable delegation).   Kudos, I couldn\u2019t have put it better myself.     AlexeyAkhunov:  And for both security audits, the issue that concerns me was taken out of scope, the auditors decided either intentionally or un-intentionally to avoid this issue, by saying: \u201cEIP recommends users to do X to avoid problems\u201d, or not looking into this aspect at all.   I was also wondering about that when I saw the audits.  The EIP gives users plenty of rope to hang themselves, no way to undo the damage, and the audits just warn users to try not to hang themselves. Users implicitly entrust us with protecting their assets.  We should keep that in mind when developing the protocol.  Ethereum is not about just the developers.  Users matter too.     AlexeyAkhunov:  But anyway, I already gave up on this, to be honest. Cannot be involved into everything   I understand you, but I hope you don\u2019t give up.  I also can\u2019t find the time to be involved in most of what\u2019s going on, but when something so risky is being considered, I feel we must voice our concern. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.6257084615518345
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/matt",
                    "index": "38",
                    "likes": "0",
                    "time": "07/07/2021-00:52:26",
                    "content": "    yoavw:  I believe I did demonstrate attacks that the audits ignored, and that cannot be mitigated by EIP 3074 as-is.   As I\u2019ve explained before, in order for EIP-3074 to be used safely the following must be done:  Implement and deploy an invoker safely. This means following invoker best practices, audits, and formal verification. You found an edgecase not yet included in the best practices \u2013 invokers deployed by CREATE were malleable on other chains. The solution is to not trust invokers deployed with CREATE. It is not a security issue of EIP-3074, just an unsafe use of the primitives. Wallets must verify for themselves that the invoker follows best practices and is safe. They may need to do their own auditing / formal verification if they aren\u2019t convinced. If they do a good job here, the invoker can be considered safe. If they make a mistake, their users are at risk. But this threat model is the same as them shipping any update to their wallet. Actively malicious wallets are no more dangerous under EIP-3074 than now. Users should only be allowed to sign EIP-3074 messages to invokers explicitly whitelisted by the wallet. This means they cannot sign authorizations to actively malicious invokers.  If you can show that under these assumptions that EIP-3074 is exploitable, then there is a safety issue. If you have to change the assumptions, then you disagree philosophically with the EIP.     yoavw:  And as for the burden of proof, since we\u2019re talking about adding an opcode that is riskier than anything added before, I think the burden of proof is on the suggester to show why the required use-cases cannot be achieved by less risky means.   The EIP explains in the rationale section. I also explained in ACD 116 why the your proposed mechanisms were less flexible than EIP-3074. As a reminder, here are a few use cases:  social recovery - I want to delegate control of my EOA to a multisig of my friends. Every proposal that requires calldata be signed over up front is inadequate to solve this problem, because I don\u2019t know what assets I\u2019ll have when I lose my EOA. cold wallet EOA - suppose I have a cold wallet, but want to interact with some of my cold wallet assets with my hot wallet (say with permission to change some ENS attributes). This requires malleability of the signature, because the cold wallet will sign one message saying \u201cthis hot wallet can do these things as me\u201d and then the invoker will verify that messages coming from my hot wallet only do certain things. specialized invokers - Some actions are very common, like approve-call. It would be more gas efficient allow a user to sign over just the approve-call invoker with their call and have that signature be used implicitly to authorize the approve.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.475385154061625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "39",
                    "likes": "0",
                    "time": "07/07/2021-03:05:55",
                    "content": "    matt:   Implement and deploy an invoker safely. This means following invoker best practices, audits, and formal verification. You found an edgecase not yet included in the best practices \u2013 invokers deployed by CREATE were malleable on other chains. The solution is to not trust invokers deployed with CREATE. It is not a security issue of EIP-3074, just an unsafe use of the primitives.    The point is not that I found an edgecase not yet included in the best practices, but that someone else will find another one in a year or two, and EIP-3074 makes users vulnerable to any future discoveries.  If the best practices two years from now differ in any way from the ones we have today, then the difference between them opens an attack on any user who signed an AUTH during these two years.  In the example I demonstrated, users get robbed using a signature they gave a year earlier, using a wallet that implemented the best practices at the time they signed it.  When the best practices are updated, the user may be powerless to mitigate the attack.     matt:   Wallets must verify for themselves that the invoker follows best practices and is safe. They may need to do their own auditing / formal verification if they aren\u2019t convinced. If they do a good job here, the invoker can be considered safe. If they make a mistake, their users are at risk. But this threat model is the same as them shipping any update to their wallet. Actively malicious wallets are no more dangerous under EIP-3074 than now.    Users will follow current best practices but will get exploited when the best practices change if they used the wallet at any earlier time.     matt:   Users should only be allowed to sign EIP-3074 messages to invokers explicitly whitelisted by the wallet. This means they cannot sign authorizations to actively malicious invokers.    You implicitly assume currently known malicious invokers.  What about whitelisted ones that will have well-hidden intentional bugs, to be discovered at some point in the future (e.g. when the author exploits the bug for the first time)?  The invoker will be removed from the whitelist immediately but it doesn\u2019t matter because the user already signed the AUTH.  You seem to assume that wallet maintainers will be able to perform the perfect audit on every 3rd party invoker.  That is a strong assumption.     matt:  If you can show that under these assumptions that EIP-3074 is exploitable, then there is a safety issue. If you have to change the assumptions, then you disagree philosophically with the EIP.   It is exploitable under these assumptions, because the best best practices you can use are the ones currently known, whereas the vulnerability lies in the ones that will become known in the future.  If the best practices change at any point in the future, then yes - AUTH messages signed before the best practices changed are exploitable and therefore EIP 3074 is exploitable.     matt:   social recovery - I want to delegate control of my EOA to a multisig of my friends. Every proposal that requires calldata be signed over up front is inadequate to solve this problem, because I don\u2019t know what assets I\u2019ll have when I lose my EOA.    Sounds like you\u2019re trying to replace smart contracts with invokers.  A user could have social recovery by using a wallet that supports that, such as Argent.  Switching from an EOA to a contract wallet in-place is a nice hack, but comes with a security price-tag.  Users could get the same functionality without the security price, by explicitly moving their assets to a smart contract wallet.  We don\u2019t need to change the consensus for that.     matt:   cold wallet EOA - suppose I have a cold wallet, but want to interact with some of my cold wallet assets with my hot wallet (say with permission to change some ENS attributes). This requires malleability of the signature, because the cold wallet will sign one message saying \u201cthis hot wallet can do these things as me\u201d and then the invoker will verify that messages coming from my hot wallet only do certain things.    If you own an ENS name and want someone else to be able to change certain ENS attributes, transfer the ENS name to a contract that accepts any operation from your EOA, and specific attribute changes from another EOA.  No need for a new opcode.  Contracts can already do that.  The price of moving the ENS name to another contract is much smaller than the price we\u2019ll be paying in security by adding this opcode.     matt:   specialized invokers - Some actions are very common, like approve-call. It would be more gas efficient allow a user to sign over just the approve-call invoker with their call and have that signature be used implicitly to authorize the approve.    Why is that not possible with my proposal or a similar one, where the user signs a list of calls?  The wallet will know that the invoker is performing both the approve and the call, so it will put them in a list, sign that list, and send the signature to the invoker.  No need for a blank check because everything is known in advance. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.211559987631416
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/matt",
                    "index": "40",
                    "likes": "0",
                    "time": "07/07/2021-04:00:48",
                    "content": "    yoavw:  The point is not that I found an edgecase not yet included in the best practices, but that someone else will find another one in a year or two, and EIP-3074 makes users vulnerable to any future discoveries.   This is not a security issue of EIP-3074, but rather a philosophical disagreement. I trust that we can develop safe contracts. We have many contracts that are considered safe such as the Uniswap contracts, Gnosis safe, Argent wallets, etc. If you don\u2019t trust those, don\u2019t use them. If you don\u2019t trust EIP-3074, don\u2019t use it.     yoavw:  What about whitelisted ones that will have well-hidden intentional bugs, to be discovered at some point in the future?   What happens if Gnosis Safe hides a bug deep down in their smart contract only to call in at some far future date? The point of smart contracts is for them to be trustless and publicly auditable. We can write safe contracts. What criteria wallets require before using an invoker is an important, but different matter than the EIP itself. I have described a framework in which this can be done safely.     yoavw:  Switching from an EOA to a contract wallet in-place is a nice hack   This is the long-term vision of Ethereum. I am proposing that EIP-3074 can help this effort while improving usability drastically.     yoavw:  If you own an ENS name and want someone else to be able to change certain ENS attributes, transfer the ENS name to a contract that accepts any operation from your EOA, and specific attribute changes from another EOA.   It\u2019s not about the specifics, it\u2019s about the class of things EIP-3074 allows. Transaction malleability allows EOA to make delegations off-chain. This is extremely powerful. Your example requires another contract be deployed. My proposal costs the user nothing.     yoavw:      matt:   specialized invokers - Some actions are very common, like approve-call. It would be more gas efficient allow a user to sign over just the approve-call invoker with their call and have that signature be used implicitly to authorize the approve.    Why is that not possible with my proposal or a similar one, where the user signs a list of calls? The wallet will know that the invoker is performing both the approve and the call, so it will put them in a list, sign that list, and send the signature to the invoker. No need for a blank check because everything is known in advance.   I see, yes in that case this one is okay. ",
                    "links": [
                        "https://ethereum-magicians.org/t/validation-focused-smart-contract-wallets/6603"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.085328798185941
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "41",
                    "likes": "0",
                    "time": "11/07/2021-21:45:29",
                    "content": "    matt:  This is not a security issue of EIP-3074, but rather a philosophical disagreement. I trust that we can develop safe contracts. We have many contracts that are considered safe such as the Uniswap contracts, Gnosis safe, Argent wallets, etc. If you don\u2019t trust those, don\u2019t use them. If you don\u2019t trust EIP-3074, don\u2019t use it.   If it\u2019s a philosophical disagreement then it\u2019s a pretty fundamental one.  Should we make it easy for users to take risks where even if they follow all the current best practices at any given time, they may be vulnerable due to not being able to fix their past mistakes?  In most other cases, users can remain safe by following best practices.  With EIP 3074 they can\u2019t, because the best practices aren\u2019t necessarily known at the time they expose themselves to the risk. You\u2019re right, I don\u2019t need to use 3074 and I might not.  And despite not being a professional auditor, I\u2019m probably a bit more qualified than the average user to assess the risk of using an invoker.  But we\u2019re not here to defend ourselves.  We\u2019re here for the users.     matt:  What happens if Gnosis Safe hides a bug deep down in their smart contract only to call in at some far future date? The point of smart contracts is for them to be trustless and publicly auditable.   With Gnosis Safe, users only take a specific risk, associated with the contract itself.  With EIP 3074 invokers, users take a risk that the best practices are incomplete and will change in the future.  If we miss anything in the first iteration, then by the time we realize it, all past users are already at risk. Some users may not even realize it, because they may no longer be users of that invoker and they don\u2019t realize they\u2019re essentially holding their assets in it.  If a Gnosis Safe bug is discovered, some users will get hit, but many others will learn about it and move their funds asap.  But if the best practices of selecting invokers is changed, how will users know that they need to move all their assets immediately due to some past AUTH they signed a couple of years ago?     matt:  This is the long-term vision of Ethereum. I am proposing that EIP-3074 can help this effort while improving usability drastically.   There\u2019s an important difference.  Vitalik\u2019s proposal is to replace all EOAs with a simple contract that emulates the behavior of the current EOA, and with an upgrade option.  Users may explicitly upgrade their EOA to use a contract wallet, and since it\u2019ll be done via a transaction rather than a signed AUTH message, it won\u2019t be replayable on other chains so it will only affect the user\u2019s account on the intended chain.  If a user wants to start using Gnosis Safe, for example, it\u2019ll be possible to upgrade an existing EOA to Gnosis Safe at the user\u2019s choice.  And if the user later decides to switch to Argent, then the user is no longer exposed to Gnosis Safe.  There is no lasting effect and the user is free to choose at any given moment. Will users perceive the act of signing an AUTH to an invoker as migrating their account to that invoker on all chains, now and in the future?  And will they understand that they can only add contracts to their wallets but never remove or replace them?     matt:  It\u2019s not about the specifics, it\u2019s about the class of things EIP-3074 allows. Transaction malleability allows EOA to make delegations off-chain. This is extremely powerful. Your example requires another contract be deployed. My proposal costs the user nothing.   There\u2019s a reason why users use smart contracts rather than delegating all their power to someone else.  It is also cheaper to give all your ETH to a centralized exchange and just trade there, but we like staying in control.  When I send an asset to a contract, I implicitly assume that the potential damage is limited to the asset I\u2019m currently sending to that contract.  EIP 3074 makes it impossible to assume that.  So you\u2019re right, this is extremely powerful.  Also too powerful, and we can get the same results with just the cost of deploying a contract when we need one. ",
                    "links": [
                        "https://ethereum-magicians.org/t/validation-focused-smart-contract-wallets/6603"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.955751250271798
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/matt",
                    "index": "42",
                    "likes": "0",
                    "time": "12/07/2021-05:31:51",
                    "content": "    yoavw:  With Gnosis Safe, users only take a specific risk, associated with the contract itself.   If a Gnosis Safe is used as a primary account, the risk profile is equivalent to an EOA signing to an invoker. A bug in either could be exploited to take over the user\u2019s entire account.     yoavw:  Users may explicitly upgrade their EOA to use a contract wallet   Users may explicitly sign a message to allow additional functionality of their wallet. It is opt-in though, just like deploying a smart contract wallet.     yoavw:  If a user wants to start using Gnosis Safe, for example, it\u2019ll be possible to upgrade an existing EOA to Gnosis Safe at the user\u2019s choice. And if the user later decides to switch to Argent, then the user is no longer exposed to Gnosis Safe   I recommend reading my post Validation Focused Smart Contract Wallets, as I\u2019ve addressed how EIP-3074 is future-compatible with a world where users can revoke invokers, change wallets, etc. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.260204081632653
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "43",
                    "likes": "0",
                    "time": "18/07/2021-22:56:01",
                    "content": "    matt:  If a Gnosis Safe is used as a primary account, the risk profile is equivalent to an EOA signing to an invoker. A bug in either could be exploited to take over the user\u2019s entire account.   Except that if the user then decides to switch from Gnosis Safe to Metamask, then the bug exposure disappears.  With EIP 3074 the user may sign any number of invokers (whitelisted by the wallet if that\u2019s how the wallet works), and has no way to \u201cremove\u201d them.     matt:  Users may explicitly sign a message to allow additional functionality of their wallet. It is opt-in though, just like deploying a smart contract wallet.   But with support for multiple invokers (roughly equivalent to adding modules to a Gnosis Safe wallet), and with no way to opt-out after opting in.     matt:  I recommend reading my post Validation Focused Smart Contract Wallets, as I\u2019ve addressed how EIP-3074 is future-compatible with a world where users can revoke invokers, change wallets, etc.   I read it, and I really like the idea of using EOF and adding a validate section.  Once users have an ability to blacklist an invoker, it becomes much safer to use.  And this section keeps things clean and easier to verify. I like the validation focused wallets but EIP 3074 doesn\u2019t mandate that, and there may be other contract wallets that don\u2019t work the same way.  It would be safer if the protocol ensures that the user has a way to opt-out of any invoker, not just with contracts that implement an opt-out method. If we did it in the opposite order, implementing EOF and validate section first, then forking to convert all EOAs, and only then introduce EIP 3074, then it would at least allow any user to change the validate section to blacklist unwanted invokers.  That would solve a lot of the risks associated with EIP 3074. A couple of things that stood out to me when I read it:  When converting all EOAs, you suggested that the default validate will just check the signature.  Don\u2019t we lose replay protection then, without a nonce check?  What stops someone from replaying all the user\u2019s past transactions after this fork?  Unless I misunderstood the way it works, I think the fork will have to also expose the account nonce to EVM.  Even if the replay protection mechanism changes in the future, the contract will be able to prevent replays of pre-fork transactions. Without including chainid in the AUTH signature, the validate section won\u2019t save the user from cross-chain attacks.  User may authorize a honest-looking invoker on one chain, not realizing the need to blacklist that invoker on all other chains.  Regardless of EIP 3074, it\u2019s a good idea to add this infrastructure (EOF+validate).  And then we may be able to add EIP 3074 safely after the EOAs are converted. Have fun at ethcc.  Too bad I can\u2019t be there myself, I was hoping to meet in person. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.78615520282187
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/matt",
                    "index": "44",
                    "likes": "0",
                    "time": "19/07/2021-07:39:16",
                    "content": "    yoavw:      matt:  If a Gnosis Safe is used as a primary account, the risk profile is equivalent to an EOA signing to an invoker. A bug in either could be exploited to take over the user\u2019s entire account.   Except that if the user then decides to switch from Gnosis Safe to Metamask, then the bug exposure disappears. With EIP 3074 the user may sign any number of invokers (whitelisted by the wallet if that\u2019s how the wallet works), and has no way to \u201cremove\u201d them.   Not sure how that is an equivalent comparison \u2013 you can switch from an EOA that signed an EIP-3074 message to an EOA that hasn\u2019t, then you also remove the bug exposure. This is equally as costly as switching from a Gnosis Safe to an EOA.     yoavw:  you suggested that the default validate will just check the signature. Don\u2019t we lose replay protection then, without a nonce check?   You\u2019re correct, there must be nonce check.     yoavw:  Without including chainid in the AUTH signature, the validate section won\u2019t save the user from cross-chain attacks. User may authorize a honest-looking invoker on one chain, not realizing the need to blacklist that invoker on all other chains.   Yes, agreed. I think chainid will probably be added to the EIP in the near future, as there have been no reasonable use cases without it presented.     yoavw:  Have fun at ethcc. Too bad I can\u2019t be there myself, I was hoping to meet in person.   Ah too bad  another conference then! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0892857142857135
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "45",
                    "likes": "0",
                    "time": "19/07/2021-08:42:55",
                    "content": "    matt:  Not sure how that is an equivalent comparison \u2013 you can switch from an EOA that signed an EIP-3074 message to an EOA that hasn\u2019t, then you also remove the bug exposure. This is equally as costly as switching from a Gnosis Safe to an EOA.   I\u2019m less concerned about the cost than about awareness.  Users know what wallet they use, so if a vulnerability is discovered they are likely to switch.  And if they switched regardless, before a vulnerability has been discovered, they don\u2019t need to care about the security of a wallet they no longer use. With invokers it\u2019s different.  Users must keep track of any invoker they ever used, even just once.  And if one of them is deemed unsafe at some point, move everything to a new EOA.  Keeping track of the wallet you use seems much easier than keeping track of all past invokers. Users won\u2019t do it, so it becomes the responsibility of the wallet maintainer to keep track and warn the user to switch EOA immediately if a previously-used invoker is found to be buggy or malicious.  If I were a wallet maintainer, I wouldn\u2019t want to be responsible for tracking the security of any 3rd party invoker I whitelisted, and tracking which user has signed such AUTH.  I don\u2019t know how I\u2019d be able to reach all these users because they may be inactive for months and are still immediately vulnerable due to this past AUTH. It might lead to wallets refusing to whitelist any 3rd party invoker, and only using their own.  That would diminish the value of EIP 3074 much more than restricting the invoker to signed transactions, and actually prevent may use cases. Another concern with needing to switch EOA due to a bug in any of the invokers previously used, is that sometimes you just can\u2019t switch because you hold a non-transferrable asset.  For example, suppose I hold tokens I received from various projects with a vesting contract.  I can\u2019t change the recipient in the vesting contract so I need to wait a few years for full vesting. I have the same concern with Gnosis Safe but at least my exposure is limited to one contract, and it\u2019s a proxy so I can upgrade the implementation to fix the bug in-place.  If instead I used multiple invokers in the past, and then a bug is discovered in just one of them, I lose all my unvested tokens.     matt:  Ah too bad  another conference then!   Hopefully devcon. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.993424504788141
                }
            ]
        }
    ],
    "group_index": "1361"
}