{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/web3-login-permissions/3583",
            "title": "Web3 Login Permissions ",
            "index": 3583,
            "category": [
                "Wallets"
            ],
            "tags": [
                "usability",
                "security"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "1",
                    "likes": "7",
                    "time": "26/08/2019-17:23:56",
                    "content": "Hi all, at MetaMask we\u2019ve been working on a new feature proposal for web3 wallets, aimed at  increasing usability while maintaining coherent security. You can read about our motivations in more detail in this blog post. The proposal below is a syndication of this EIP branch submitted as this EIP issue.  eip: TBD title: Wallet Permissions System author: Dan Finlay (@danfinlay), Erik Marks (@rekmarks) discussions-to: TBD status: Work in progress (WIP) type: Standard Track category: Interface created: 2019-08-22 requires: 1474  permission system.png2826\u00d7973 239 KB  Simple Summary A proposed standard interface for restricting and permitting access to security-sensitive methods within a restricted web3 context like a website or \u201cdapp\u201d. Abstract Web3 JavaScript wallet browsers may implement wallet_getPermissions and wallet_requestPermissions. This provides a standard interface for requesting permissions and checking a domain\u2019s current permissions status. Motivation Web3 Wallets are built around the responsibility of mediating the interactions between untrusted applications and a user\u2019s keys on their computer, getting appropriate consent from the user. Today web3 browsers like MetaMask always prompt on a per-action basis. This provides security at the cost of substantial user friction. We believe that a single permissions request can achieve the same level of security with vastly improved UX. The pattern of permissions requests is common around the web, from login with Facebook, Twitter, Github, and even Apple, making it a very familiar pattern.   e0d20c0faec92acec3e591c957612fd482d9d01a.jpeg584\u00d7554 53.1 KB  Many web3 applications today begin their sessions with a series of repetitive requests:  Reveal your wallet address to this site. Switch to a preferred network. Sign a cryptographic challenge. Grant a token allowance to our contract. Send a transaction to our contract.  Many of these (and possibly all), and many more (like decryption), could be generalized into a set of human-readable permissions prompts on the original sign-in screen, and additional permissions could be requested only as needed. On the user\u2019s end, each of these permissions could be individually rejected (unchecked), or even attenuated, or adjusted to meet the user\u2019s terms (for example, a sign-in request could have a user-added expiration date, and a token allowance could be adjusted by the user when it is requested), making the web3 login a sort of user-revisable terms of use. Specification This proposal adds two new methods to a wallet\u2019s web3 provider API:  wallet_getPermissions wallet_requestPermissions  The wallet_getPermissions method is used for getting an array of current permissions (empty by default), while the wallet_requestPermissions method is used for an application to request additional permissions. These two methods are used to restrict a few hypothetical \u201crestricted methods\u201d. The first such method we would suggest should be included as part of the standard is eth_accounts. In this framework, the permission for a user to reveal their accounts would look like this: const response = await provider.send({   method: 'wallet_requestPermissions',   params: [{     'eth_accounts': {},   }] })  If this request was rejected, it would throw an error with a code value equal to 4001, per EIP 1193 errors, which the MetaMask team has canonized in a module eth-json-rpc-errors. If the request is accepted by the user, then subsequent requests to eth_accounts will succeed, and return an accounts array as usual. A call to wallet_getPermissions will then return a permissions schema object that describes the current permission. const response = await provider.send({   method: 'wallet_getPermissions' })  Would return a value something like this: [   {     parentCapability: 'eth_accounts',     caveats: [       {         type: 'filterResponse',         value: [\"0x0c54fccd2e384b4bb6f2e405bf5cbc15a017aafb\"]       }     ]   } ]  The term parentCapability comes from the ocap-ld spec, which these permissions objects are based on. You can see above how internally the user-selected account is transformed into a caveat, which is a restriction on the response values, in this case ensuring the page can only be notified of approved accounts. This also means this permissions system is forward-extensible to support logging into a page with multiple accounts. Rationale While the current model of getting user consent on a per-action basis has high security, there are huge usability gains to be had bo getting more general user consent which can cover broad categories of usage, which can be expressed in a more human-readable way. This pattern has a variety of benefits to offer different functions within a web3 wallet. The eth_sendTransaction method itself could be a restricted method (requested by default with the provider.enable() method), and the user could at sign-in time decide whether they wanted to require confirmations, approve all transactions, or only approve transactions to a certain contract, or up to a certain token limit, for example. By restricting this method by default, wallets could prevent sites from spamming the user with popups. If eth_call were a restricted method, then random websites would not be able to drain a user\u2019s subscription to a hosted provider, making it easier to protect services like Infura against DDoS attacks. On-chain actions could be represented as a permission under this model, for example, the permission to send an allowance-setting transaction to a specific token address is virtually equialent to the approval of that transaction, except the site could choose to only invoke the transaction when it was needed. This could allow a standard interface for applications to request permissions which may require different actions depending on different types of accounts (hot wallets, hardware wallets, cold wallets, contract accounts). The requestPermissions method could be expanded to include other options related to the requested permissions, for example, sites could request accounts with specific abilities. For example, a website like an exchange that requires signTypedData_v3 (which is not supported by some hardware wallets), might want to specify that requirement, maybe like this: provider.send({   method: 'requestPermissions',   params: [     {       'eth_accounts': {         requiredMethods: ['signTypedData_v3']       }     }   ] })  That type of API will also be up for discussion on The MetaMask repository. This would allow the wallet to limit the user\u2019s options to valid ones, and allows dapps to ensure selected accounts are compatible with their service, while preserving the user\u2019s privacy regarding how they are storing their keys. Implementation We have a branch of MetaMask available now which adds these methods via an rpc-engine middleware called json-rpc-capabilities-middleware (or often RpcCap internally, for short). The latest build of this branch of MetaMask can be downloaded from the draft pull request (look for the latest post by @MetaMaskBot). A guide to adding a custom build of MetaMask to Chrome can be found here. This branch of MetaMask can be used with this sample site (source), which uses a couple sample permissions for demonstration purposes:   readYourProfile: We have bundled this build with an imaginary concept of a local \u201cprofile\u201d, a simple POJO. Eventually this could be extended to instead expose the user\u2019s 3box profile.  writeToYourProfile: This permission allows the requesting app to freely update/edit the user\u2019s profile.  sendEther: A permission allowing the sending of transactions.   0*JE9gDZR7fqo2Ewfw.gif1247\u00d7853  It is notable that this branch is the first version of MetaMask that allows you to be connected to each site with a different account, which persists on that site, along with any other permissions granted to the site. You can get more detailed API and type information on the RpcCap repository\u2019s readme. New hypothetical and proposed permissions can be easily added to the restrictedMethods hash in the MetaMask permissions controller. Copyright Copyright and related rights waived via CC0. ",
                    "links": [
                        "https://github.com/danfinlay/EIPs/blob/WalletPermissions/EIPS/eip-PermissionsSystem.md",
                        "https://github.com/ethereum/EIPs/issues/2255",
                        "https://ethereum-magicians.org/uploads/default/original/2X/f/f7b2f29144e062e330125526167bc3fa359cd7aa.png",
                        "https://ethereum-magicians.org/uploads/default/original/2X/e/e0d20c0faec92acec3e591c957612fd482d9d01a.jpeg",
                        "https://eips.ethereum.org/EIPS/eip-1193",
                        "https://github.com/metamask/eth-json-rpc-errors",
                        "https://w3c-ccg.github.io/ocap-ld/",
                        "https://github.com/MetaMask/json-rpc-capabilities-middleware/blob/master/src/%40types/ocap-ld.d.ts#L28-L33",
                        "https://github.com/MetaMask/metamask-extension/issues/6994",
                        "https://github.com/MetaMask/metamask-extension/tree/LoginPerSite",
                        "https://github.com/MetaMask/json-rpc-engine",
                        "https://github.com/MetaMask/json-rpc-capabilities-middleware",
                        "https://github.com/MetaMask/metamask-extension/pull/7004",
                        "https://github.com/MetaMask/metamask-extension/blob/develop/docs/add-to-chrome.md",
                        "https://metamask.github.io/permissions-adventure/",
                        "https://github.com/metamask/permissions-adventure",
                        "https://en.wikipedia.org/wiki/Plain_old_Java_object",
                        "https://3box.io/",
                        "https://miro.medium.com/max/1400/0*JE9gDZR7fqo2Ewfw.gif",
                        "https://github.com/MetaMask/json-rpc-capabilities-middleware#rpc-methods",
                        "https://github.com/MetaMask/metamask-extension/blob/774d931cb9f16a8f2df8c6deee1dd553b40d5ad5/app/scripts/controllers/permissions.js#L187",
                        "https://creativecommons.org/publicdomain/zero/1.0/",
                        "https://ethereum-magicians.org/t/eip-2253-add-wallet-getaddressbook-json-rpc-method/3592/6"
                    ],
                    "GPT-summary": null,
                    "GPT-proposal-categories": null,
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.188056226719018
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "2",
                    "likes": "0",
                    "time": "26/08/2019-18:34:46",
                    "content": "@wighawag @pedrouid @boris @beltran @Ethernian @ligi @izqui ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/boris",
                    "index": "3",
                    "likes": "2",
                    "time": "26/08/2019-21:16:21",
                    "content": "This is great, thanks Dan. Can we pull out the types of permissions and put them in a repo so we can agree and evolve them, as well as define vendor / dapp specific permissions? Are these what OAuth2 calls \u201cscopes\u201d? I think we can get to some Web3 wide permissions, and then enable per dapp / wallet custom ones. Pinging @expede as she plans out our identity work. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "4",
                    "likes": "1",
                    "time": "26/08/2019-22:35:50",
                    "content": " Can we pull out the types of permissions and put them in a repo so we can agree and evolve them, as well as define vendor / dapp specific permissions?  That\u2019s a great idea! Starting a repo here, hopefully we can grow it into something nice.    GitHub    MetaMask/wallet-permissions-spec A repo for describing the permissions exposed by the web3 wallet protocol. - MetaMask/wallet-permissions-spec        Are these what OAuth2 calls \u201cscopes\u201d?  These permissions are basically equivalent to OAuth2 Scopes. However, the language of \u201cscope\u201d seems to suggest that a permission has some broad implications, like the github:repo:write scope, which includes a variety of permissions bundled under one label. Taking inspiration from object capabilities, we\u2019re calling them permissions here because we aspire to make the individual items coherent enough that they can result in informed consent when a brief description is read by the user. ",
                    "links": [
                        "https://github.com/MetaMask/wallet-permissions-spec",
                        "https://oauth.net/2/scope/"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.201388888888889
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "5",
                    "likes": "1",
                    "time": "26/08/2019-23:19:54",
                    "content": "I am unsure whether I like the permission idea in general and the permission \u201csend the transaction on your behalf\u201d in particular. Users may be so careless giving permissions\u2026 I have a bad feeling re-implementing the usual permission paradigm once more. The way how are you solving the trade-off  \u201cUX vs Security\u201d by trading UX for Security is much different how I see it. I need more time to think about it. I\u2019ll write then. BTW, thank you for mentioning me. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.854166666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "6",
                    "likes": "2",
                    "time": "27/08/2019-00:03:51",
                    "content": " I am unsure whether I like the permission idea in general and the permission \u201csend the transaction on your behalf\u201d in particular. Users may be so careless giving permissions\u2026 I have a bad feeling re-implementing the usual permission paradigm once more.  I agree there are scary permissions we could add, and sending transactions is among the top, and so I\u2019m not actually including any transaction sending permission as part of this proposal. That said, I will still defend the possibility of that permission, because I think it\u2019s an important point. Even today\u2019s \u201cprompt on every transaction\u201d model relies on users mostly trusting the sites they visit, as most transactions are of unknown types, and are hard for wallets to represent to users. For that reason, I think a properly designed permissions system will do a few things to improve the situation:  Wallets should make dangerous permissions look dangerous. This isn\u2019t an excuse to get users to click blindly. This is a time to rebuild the user\u2019s sense of responsibility. Wallets should expose permissions that are meaningful to users. A token allowance is meaningful, but a hex blob is not. If we can identify the terms that convey the true risk a user is taking, I believe we can allow the risks a user takes to be much more comprehensible to them, which allows them to participate in informed consent. We cannot stop users from being reckless, but we can empower them to be careful with fewer steps. Wallets should allow users to attenuate permissions (add caveats), or reduce their impact when possible. An app may request a login, but the user may say \u201cJust for the next 30 minutes\u201d.  I imagine you might be thinking about your Dapplet proposal as an alternative security measure, but I think it actually could work better together: While we want to render transactions more coherently, there is a hard question about who you would trust to design your transaction approvals, so why not make \u201cpermission to render confirmations\u201d a permission? In Dapplets, you suggest a registry, and that the registry could have auditors, and I would suggest that this has moved the goal post, and now the concern is \u201cwho are the auditors?\u201d. Rather than prescribe an imperfect solution, we could also just ask the user if they trust a given source for information. I wish I could keep users safe by restricting functionality, but ultimately users will do extreme things to use applications if it isn\u2019t easy. They\u2019ll just trust the site to make a wallet for them, and they\u2019ll fund it, or paste in a seed phrase. Rather than refuse to implement potentially dangerous APIs, I think it\u2019s important for wallet developers to ask what APIs allow users to take the risks they want to make, as coherently as possible? ",
                    "links": [
                        "https://ethereum-magicians.org/t/dapplets-rethinking-dapp-architecture-for-better-adoption-and-security/2799",
                        "https://en.m.wikipedia.org/wiki/Moving_the_goalposts"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.286458333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rekmarks",
                    "index": "7",
                    "likes": "2",
                    "time": "27/08/2019-01:10:43",
                    "content": "    Ethernian:  Users may be so careless giving permissions\u2026 I have a bad feeling re-implementing the usual permission paradigm once more. \u2026 The way how are you solving the trade-off \u201cUX vs Security\u201d by trading UX for Security is much different how I see it.   I want to add that we do not believe that we are \u201ctrading UX for security\u201d in this framework. As we state in the proposal:  We believe that a single permissions request can achieve the same level of security with vastly improved UX.  Speaking for myself, regarding security, when we adopt this framework, the following statement will remain true:  Dapps cannot take any action on the user\u2019s behalf without the user\u2019s explicit permission  I maintain that we can implement this framework such that the following is also true:  The user is extremely unlikely to grant permissions that enable dapps to take actions counter to the user\u2019s intentions  I believe we can accomplish this by:  Disallowing \u201cunlimited\u201d permissions for sensitive methods such as eth_sendTransaction  For instance, enforcing some kind of user-specified spending or usage limit.   Letting the user maintain existing behavior, with confirmations for every transaction, however small.  Perhaps we even maintain existing behavior for eth_sendTransaction by default.   Ensuring that permissions are human-readable through rigorous user research.  To accomplish this, our design team is deeply involved in determining how we present this feature to users.    ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.935374149659864
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pedrouid",
                    "index": "8",
                    "likes": "2",
                    "time": "27/08/2019-09:36:05",
                    "content": "I love everything about this! This aligns very well with what we wanted to do with \u201cAutomatic Authentication Signature\u201d proposal and also with \u201cWalletConnect Session Permissions\u201d. This design is even better which would be compatible with any web3/ethereum provider  Pinging @androolloyd who\u2019s been asking me for ages to do something like this as part of Web3Connect  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.208333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "9",
                    "likes": "2",
                    "time": "27/08/2019-11:29:00",
                    "content": "Thanks @danfinlay for the mention, Great proposal! I like its simplicity and extensibility I share @Ethernian\u2019s concerns though about making it easy for an application to get the ability to send tx at will without further thoughts on this. Even if this is only a potential permission. While I actually think it make sense to let application send tx at will, we need to differentiate between fully decentralised application, whose front-end code cannot be changed (ipfs hash) and the one that can be updated at will or as a result of being attacked (DNS / ENS based) The proposal need to spec out exactly what/who these permissions are given to. In several of my post here and on my blog (https://medium.com/@wighawag), I mentioned about the document\u2019s origin and how not all are created equal, how an ENS name should only be used a convenience (to point to an ipfs hash) and not as the canonical origin, etc\u2026 Ideally such origin should always be the content itself. ipfs and swarm provide this mechanism and an ENS/ DNS name should simply be used as a redirection mechanism : they should not be used as origins themselves. Obviously in the current context, we can\u2019t entirely block such website. But we could forbid giving certain permission to them. a permission to send any kind of tx could indeed be given safely to a website hosted on IPFS (but without any mixed content (similar to how browser deal with http content in a website served over https) The content of the website could have been audited / reviewed / formally verified and I see no reason to limit their capabilities if users agree too. That\u2019s exactly what i have been pushing for quite some time now : https://medium.com/@wighawag/3-proposals-for-making-web3-a-better-experience-974f97765700 And your proposal is a lot better than recording such permission on the smart contract themselves (as I was proposing) On the other hand, such permission should not be given if the origin is a DNS domain pointing to a backend url without hash. Similary this permission should not be given to an ENS name, instead it should be given to the ipfs hash the ENS name points to (this way if the ENS name owner change the content, the user are protected) Alternatively, if this could be possible, the web3 browser could generate an hash of the content and linked content to create the origin itself. DNS would then be simply used as a redirection mechanism. But this would not work for any application that request data dynamically from non-hashed based data source. Regarding the \u201ceth_accounts\u201d request, as I proposed in 1102 proposal, Giving permissions to eth_accounts should return a signed request so that the application can be sure the wallet is indeed in possession of the private key without having to make yet another request. ",
                    "links": [
                        "https://medium.com/@wighawag/3-proposals-for-making-web3-a-better-experience-974f97765700"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.687409812409813
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "10",
                    "likes": "1",
                    "time": "27/08/2019-14:41:24",
                    "content": "    danfinlay:  I\u2019m not actually including any transaction sending permission as part of this proposal. That said, I will still defend the possibility of that permission, because I think it\u2019s an important point.   If we will put reasonable constraints on permissions, that could be ok. Although I would put possible UseCases in focus (like gas payments) to check the applicability of the permission paradigm to it.     danfinlay:  Wallets should make dangerous permissions look dangerous \u2026   I am not sure, wallet will be able to identify \u201cdangerous permissions\u201d in generic manner because the value of the permitted transaction may be external to the blockchain (like a transfer of a real-world asset).     danfinlay:  I imagine you might be thinking about your Dapplet proposal as an alternative security measure, but I think it actually could work better together:   I am thinking about a convergence of both, not opposition. More details will follow.     rekmarks:  Dapps cannot take any action on the user\u2019s behalf without the user\u2019s explicit permission   This is exact that I am concerning about and not able understand currently: If some transaction get signed because of some permission is active, than for the transaction itself the user confirmation is implicit (implied) and not the explicit one. Right? I see the security risk increasing here (because this implication may be correct or not) and do not understand how you don\u2019t. One more concern: This protocol assumes bidirectional communication changing its direction many times. For high security wallets like AirGap utilizing two separate uni-directional channels (Camera + Display) it will not be easy to implement it, ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.479142857142857
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/loredanacirstea",
                    "index": "11",
                    "likes": "3",
                    "time": "27/08/2019-16:09:28",
                    "content": "I see a difference in: 1) Method permissions  Each method must have a unique identifier - in our case, this is the method name.  2) Method argument type check and validation  Each argument type should be defined in the global scope and must have a unique identifier, so they can be reused across methods, with a custom label (instantiation name). Then, validation rules can also be reused in wallets, web3 libs etc. And custom type UIs can also be reused.  Example 1) eth_sendTransaction permission: {   method: 'wallet_requestPermissions',   params: [{     method: 'eth_sendTransaction',   }] }  2) eth_sendTransaction permission + argument validation: First, eth_sendTransaction has the following interface: {     type: 'function',     label: 'eth_sendTransaction',     inputs: [         {             type: 'address',             label: 'from'         },         {             type: 'address',             label: 'to'         },         {             type: 'bytes',             label: 'data'         },     ],     optionalInputs: [         {             type: 'uint256',             label: 'gas'         },         {             type: 'uint256',             label: 'gasPrice'         },         {             type: 'uint256',             label: 'value'         },         {             type: 'uint256',             label: 'nonce'         }     ],     outputs: [         {             type: 'bytes32',             label: 'transactionHash'         },     ] }   If we have standardized interface types, we can have automatic type validation rules & UI components for each method argument on the Wallet UI. So, the JSON-RPC method can look something like this: (no need to define types, because they are known by both web3 lib & wallet) {   method: 'wallet_requestPermissions',   params: [{     method: 'eth_sendTransaction',     params: [         {             name: 'from',             required: true,             customizable: true,             selection: ['0x0001'],         },         {             name: 'to',             required: true,             customizable: false,             selection: ['0x0003', '0x0004'],         },         {             name: 'gas',             required: true,             customizable: false,             selection: [0, 2000000],         },         {             name: 'gasPrice',             required: true,             customizable: true,             selection: [1, 5],         },         {             name: 'value',             required: true,             customizable: true,             selection: [0, 100000000000],         },         {             name: 'data',             required: true,             customizable: false,         },         {             name: 'nonce',  // can be used for expiration of permissions             required: false,             customizable: true,             selection: [5, 10],         },     ]   }] }  Where:   name: argument name inside the method  required: true if without it, the entire permission fails.  customizable: the user can change type validation rules (increase a range, select another account etc.)  selection: the argument value range / selection list (depends on each type; the wallet will show the appropriate UI for the type)  Note: Permissions on data (e.g. how many tokens to approve, etc.) are tricky right now. If the above general mechanism (or similar) will be considered, I have some ideas about how to tackle the data problem in a general way, if people are interested. Conclusion I am suggesting:  general permissions + argument validation based on types for any web3 method; not just on handpicked ones a dApp should expose all web3 methods that it will use (calls & transactions) the wallet should be able to show the user all the web3 methods that the dApp uses/has used (it can be in the Advanced section, because this can be overwhelming); transparency + the above Infura DDoS example  Very good topic. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.558403361344538
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "12",
                    "likes": "2",
                    "time": "27/08/2019-17:24:59",
                    "content": " The proposal need to spec out exactly what/who these permissions are given to.  Excellent point, I am surprised I didn\u2019t include this. Initially, as MetaMask can connect to normal DNS websites, I would use the same origin identifier, which should include a prefix of the protocol (i.e. https://dapps.metamask.io, ens://danfinlay.eth, or ipfs://IPFSHASH). I do agree that we could use this opportunity to push developers towards more decentralized protocols, so at MetaMask we are improving the origin detection of our IPFS resolution. That said, I think loading over an eth address or ENS name would be a powerful tool, because it allows the creation of on-chain update logic. I can even see the possible benefits of locking permissions to the hash of a page, so that any page update requires a re-authentication. That\u2019s a big usability tradeoff, but has some pretty great security benefits.  Alternatively, if this could be possible, the web3 browser could generate an hash of the content and linked content to create the origin itself. DNS would then be simply used as a redirection mechanism. But this would not work for any application that request data dynamically from non-hashed based data source.  Agreed, I\u2019m not sure it\u2019s even possible for us to dynamically check the hash of a page that is loaded, we\u2019ll have to check that out. Some of these goals are very ideal, but may be less practical in the short term, where we\u2019re still building largely on web 2.0 infrastructure.  Regarding the \u201ceth_accounts\u201d request, as I proposed in 1102 proposal, Giving permissions to eth_accounts should return a signed request so that the application can be sure the wallet is indeed in possession of the private key without having to make yet another request.  I don\u2019t think all applications require cryptographic proof of key holding, nor do all accounts have a single key that controls them (contract accounts would be unable to sign in under this model!). We\u2019re currently working on a proposal to integrate your Automatic Authentication Signature proposal into an additional, optional permission that a dapp could request at its discretion, for when it truly needs to verify a key\u2019s possession. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.68123973727422
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "13",
                    "likes": "1",
                    "time": "27/08/2019-17:33:16",
                    "content": "    Ethernian:  I would put possible UseCases in focus (like gas payments) to check the applicability of the permission paradigm to it.   Could you expand on this example use case?     Ethernian:  I am not sure, wallet will be able to identify \u201cdangerous permissions\u201d in generic manner because the value of the permitted transaction may be external to the blockchain (like a transfer of a real-world asset).   I don\u2019t think we need to do it generically: Some permissions (like sendTransaction) are clearly security critical, and probably far too open-ended for most normal usage, and so it should be rendered with an extreme warning. Only if the requested permission is constrained to an extent that we can coherently render it should we laxen our warning. For example, an allowance of a known asset type.     Ethernian:  If some transaction get signed because of some permission is active, than for the transaction itself the user confirmation is implicit (implied) and not the explicit one. Right? I see the security risk increasing here (because this implication may be correct or not) and do not understand how you don\u2019t.   Just to re-ground the discussion, this proposal at large is not presenting any \u201cfreely send transactions\u201d permission, so it might be best to separate that into a future hypothetical discussion, so we don\u2019t throw out this entire platform just because it could be extended in a dangerous way.     Ethernian:  One more concern: This protocol assumes bidirectional communication changing its direction many times. For high security wallets like AirGap utilizing two separate uni-directional channels (Camera + Display) it will not be easy to implement it,   This is fair. Signing in with different types of wallets will have different features, so Dapps may need to do some feature detection, and some dapps may only be able to work in some contexts. If an application requires streaming communication (for decryption, for example), it might mean that either it requires a web3 browser or that the wallet phone stays on during the connection. I think this is an important consideration, and maybe we should add a permissions-feature-detecting API also, so Dapps could ask what permissions are even available. Or maybe feature-detection could be implicit, wherein a response to wallet_requestPermissions returns only approved (and available) permissions, which also improves user privacy by never exposing a list of available APIs. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.827364864864864
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "14",
                    "likes": "1",
                    "time": "27/08/2019-18:09:54",
                    "content": "    danfinlay:   I would put possible UseCases in focus (like gas payments) to check the applicability of the permission paradigm to it.  Could you expand on this example use case?   Sorry for using uncommon terms. I used \u201cgas payments\u201d for per-Tx micro payments for tool and infrastructure usage made in protocol tokens or other non-ETH assets. It could be a per Tx micro payment for using MetaMask, WalletConnect etc. These properties are:  micro payments, maybe paychannel or other meta Tx. related to main Tx  I can imagine a permission for this Use Case. But note, that this permission is use case specific and not generic. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.12037037037037
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "15",
                    "likes": "2",
                    "time": "27/08/2019-18:35:32",
                    "content": "Hi @loredanacirstea, thanks for reading! I like the idea of strongly-typing the method parameters, but am unclear by what API the wallet would make these available. Maybe that belongs in an additional method? Or should the inputs be returned as part of the wallet_getPermissions response? I think the required, customizable parameters are excellent ideas, and is similar to a use case suggested just yesterday by @tomhschmidt. The selection parameter could be encoded as a type of caveat, which I think gives us a more open-ended model for defining the constraints on a permission. One difference in your proposed examples and mine are the use of an array vs an object for defining the requested permissions. My reasoning had been that if permissions have unique names, then no array (or label key) is needed, we can iterate unique keys. Is there a particular benefit you see to submitting the requested permissions as an array? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.703703703703704
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "16",
                    "likes": "1",
                    "time": "27/08/2019-20:40:30",
                    "content": "One method that would benefit from a permissions system like this would be encryption/decryption, like @topealabi proposed with EIP 1024. At the time, I had some concerns about how to securely expose such a method, but I think this permissions framework gives us a pretty prescriptive path for adding such a method. ",
                    "links": [
                        "https://ethereum-magicians.org/t/the-ux-of-eip-1024-encrypt-decrypt/1243"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.8125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "17",
                    "likes": "0",
                    "time": "27/08/2019-20:53:31",
                    "content": "    wighawag:  On the other hand, such permission should not be given if the origin is a DNS domain pointing to a backend url without hash. Similary this permission should not be given to an ENS name, instead it should be given to the ipfs hash the ENS name points to (this way if the ENS name owner change the content, the user are protected)   Maybe this could be a login option: - Log me out after X minutes. - Log me out if this site is updated.  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.6875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/loredanacirstea",
                    "index": "18",
                    "likes": "1",
                    "time": "28/08/2019-12:43:46",
                    "content": "@danfinlay,  I like the idea of strongly-typing the method parameters, but am unclear by what API the wallet would make these available. Maybe that belongs in an additional method? Or should the inputs be returned as part of the wallet_getPermissions response?  These types should not be controlled by an implementation, but agreed on as a standard and kept in a globally available scope. Libraries for transforming them into language-specific types can be built. I suggest using such a system. For the purpose of defining immutable types that are reused across standards, I started dType.  The selection parameter could be encoded as a type of caveat, which I think gives us a more open-ended model for defining the constraints on a permission.  I don\u2019t have anything against this.  One difference in your proposed examples and mine are the use of an array vs an object for defining the requested permissions.  An object with keys is good, for the reasons that you mention. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.666666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "19",
                    "likes": "1",
                    "time": "28/08/2019-13:20:08",
                    "content": "    danfinlay:  I can even see the possible benefits of locking permissions to the hash of a page, so that any page update requires a re-authentication. That\u2019s a big usability tradeoff, but has some pretty great security benefits.   That\u2019s exactly where I think this should go. Giving permissions (at least the dangerous one like eth_sendTransaction) to anything else could come with a BIG warning to the users but I actually believe we should not even let such applications request it. This is too much risk for the users and too much responsibility for the application owner.     danfinlay:  Maybe this could be a login option: - Log me out after X minutes. - Log me out if this site is updated.    if this was the default and any different permission requests was acompagnied with a big warning, this could be an option. At the same time, it is easy to imagine users starting to accept such permission request blindly. I think as stated aboive some permissions should simply never be allowed on origin that do not encode the full content. Also if the result of a change was simply being logged out, the user might think they have been logged out for other reason (time based for example). As such we will still need to differentiate between the 2 so users are aware that the content change and that they might be better off waiting before trusting the new content.     danfinlay:  I don\u2019t think all applications require cryptographic proof of key holding, nor do all accounts have a single key that controls them (contract accounts would be unable to sign in under this model!). We\u2019re currently working on a proposal to integrate your Automatic Authentication Signature proposal into an additional, optional permission that a dapp could request at its discretion, for when it truly needs to verify a key\u2019s possession.   Ok, having automatic signature as a permission would work but I still feel that giving the application access to the ethereum address without proving key ownership is potentially misleading. Obviously for application that only display content associated to an address, there is no need to verify the address is indeed own by that wallet. But at the same time, what would be the risk to let application know that the wallet own the private key by giving out a signed message ? Actually thinking about it, maybe it is privacy ? Like if wallet allow any user to display themselves as any address, they could potentially be able to see their data without necessarely giving out their address. But I guess some statistical analysis would reveal it in the end (how much time they spend on a specific address?) Any other reasons ? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.356590458152958
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "20",
                    "likes": "1",
                    "time": "28/08/2019-19:55:02",
                    "content": "    wighawag:  But at the same time, what would be the risk to let application know that the wallet own the private key by giving out a signed message ? Actually thinking about it, maybe it is privacy ? Like if wallet allow any user to display themselves as any address, they could potentially be able to see their data without necessarely giving out their address. But I guess some statistical analysis would reveal it in the end (how much time they spend on a specific address?) Any other reasons ?    Supporting contract accounts, which may not have a single signer empowered to represent them. Support viewing pages in \u201cread-only\u201d mode, maybe viewing from the \u201cperspective\u201d of a cold wallet, with an offline signer. Privacy, plausible deniability, that all makes sense to me.  I don\u2019t think it makes sense to require a feature that is not required for all use cases, and since some use cases cannot provide signatures, I would not want to make them a requirement, especially when adding the feature as an extra permission is so trivially easy. I would instead ask, is there a good reason that all accounts must sign when connecting to an application?     loredanacirstea:  These types should not be controlled by an implementation, but agreed on as a standard and kept in a globally available scope. Libraries for transforming them into language-specific types can be built. I suggest using such a system. For the purpose of defining immutable types that are reused across standards, I started dType.   Maybe we could encode the ethereum provider as a dType. I\u2019ll look closer at that soon! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.69672619047619
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "21",
                    "likes": "1",
                    "time": "28/08/2019-20:23:28",
                    "content": "    danfinlay:  I don\u2019t think it makes sense to require a feature that is not required for all use cases, and since some use cases cannot provide signatures, I would not want to make them a requirement, especially when adding the feature as an extra permission is so trivially easy. I would instead ask, is there a good reason that all accounts must sign when connecting to an application?   You are right! I now agree that the best way is to make auto signature (or maybe simply a single signature challenge) another permission for those that need it ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.727891156462585
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "22",
                    "likes": "1",
                    "time": "29/08/2019-21:09:51",
                    "content": "I\u2019ve cross posted this to the EIP repository:   github.com/ethereum/eips      Issue: EIP-xxx: Web3 Wallet Permissions  \t \topened by danfinlay \ton 2019-08-28 \t \t \t  Opening an issue for discussion before opening a pull request, for Web3 Wallet Permissions. Discussion has started at ethereum magicians Reposting the body...         ",
                    "links": [
                        "https://github.com/danfinlay",
                        "https://github.com/ethereum/eips/issues/2255",
                        "https://github.com/danfinlay",
                        "https://github.com/ethereum/eips/issues/2255"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "23",
                    "likes": "3",
                    "time": "30/08/2019-00:18:33",
                    "content": "I don\u2019t feel like the dapp should be involved in the process of deciding whether the signer auto-signs or not.  In fact, I think the dapp should not know whether the signer is auto-signing or not (though, this is difficult to prevent due to timing attacks). I\u2019m a big fan of a dapp requesting permissions from a user, including the ability to prompt for signing.  I\u2019m not a fan of the dapp being able to request auto-signing, but I am a big fan of users being able to enable auto-signing. One can imagine a dapp requesting signing permission from the signer, and then the signer popping up a dialog that asks the user if they want to allow the dapp to prompt for signing.  The dialog would have an option the user could optionally select (off by default) that would auto-sign transactions from that dapp. I think if you have a permission for \u201cauto-sign\u201d, every dapp that needs to sign things would ask for it, because there is no reason not to ask for it.  If every dapp asks for a thing, why is it part of a protocol?  On the topic of constraining permissions, I am a big fan of pushing forward on the IPFS front, or other mechanisms for detecting page changes.  I would be in favor of saying that these permissions only work in cases where we can guarantee that a page hasn\u2019t changed compared to when the permission was granted.  You could have things like, \u201cwe noticed this page has changed since you last granted permissions, would you like to grant the same permissions as before\u201d when you have information like domain name to identify similar pages. The place where this is problematic is when you have a page that is receiving dynamic data from an external source.  Do you only hash the root page?  The root page plus all JS?  What about GET requests that mutate the page?  For permissions like send_token and similar, should the dapp be able request constraints on those?  For example, send_token: DAI,REP,MKR vs send_token: * which would cause the prompt to list the tokens the dapp wants to be able to send instead of prompting for the ability to send any token. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.38157894736842
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "24",
                    "likes": "0",
                    "time": "03/09/2019-20:44:07",
                    "content": "    MicahZoltu:  I don\u2019t feel like the dapp should be involved in the process of deciding whether the signer auto-signs or not. In fact, I think the dapp should not know whether the signer is auto-signing or not (though, this is difficult to prevent due to timing attacks).   This is fine, and makes sense, but I\u2019d like to point out it is slightly outside the scope of this proposal. This proposal does not include an auto-signing permission, just presents one as a hypothetical permission. For that discussion, it might be more useful to take the concerns to the app keys proposal, for example. That said, there are several hypothetical signing permissions that have been presented in this thread, so I would suggest people make sure they specify which they are referring to:  A domain-locked app key  A domain-locked permission to sign challenges within a constrained EIP-712 domain A domain-locked permission to send transactions (possibly with limitations on gas, recipient, etc).  I felt like you touched on a few of those as if they were a common permission. For example, re: item 3 above, \u201cdon\u2019t ask for confirmations on this domain\u201d could easily be added to the normal transaction confirmation window, and the site would never need to know that it was granted this privilege. But that\u2019s a little distinct from the timing-attacks issue you raised, which seems more related to item 2 above, and should be addressed in any auto-sign proposal.     MicahZoltu:  You could have things like, \u201cwe noticed this page has changed since you last granted permissions, would you like to grant the same permissions as before\u201d when you have information like domain name to identify similar pages. The place where this is problematic is when you have a page that is receiving dynamic data from an external source. Do you only hash the root page? The root page plus all JS? What about GET requests that mutate the page?   I think that warning is a very nice idea, and is a good compromise between the \u201csupport the web as it is\u201d and \u201conly support the most secure options\u201d camps. Long term it would be great to be able to make any fetch or ajax calls explicit permissions themselves, and so by default sites would have no special permissions besides rendering themselves on screen. In the meanwhile, for the sake of allowing the best we can provide today, we probably don\u2019t have a huge choice but to support normal http and https loaded sites, along with all the default browser APIs, but as more permissions are proposed, maybe we should seriously limit some permissions to some more secure transport types, or at least present warnings of the concerns with those lower-security types. I\u2019d hate to not be able to use http for local development, for example, but I can tolerate a warning in development, even one that might scare away users in production.     MicahZoltu:  For permissions like send_token and similar, should the dapp be able request constraints on those? For example, send_token: DAI,REP,MKR vs send_token: * which would cause the prompt to list the tokens the dapp wants to be able to send instead of prompting for the ability to send any token.   I think we should support dapp-provided constraints, because dapps know what they require to operate. Users should be able to customize the approved parameters within those constraints, or reject the entire request. There are lots of examples of this, like when signing into a site, it may know it requires an allowance of up to $5 to begin viewing, and it can specify that, but you can still specify over their minimum request if you want. We\u2019ve also had requests from developers to be able to specify valid gas values for a transaction, because some smart contracts use gas price and gas limit to encode additional data, and so they need to be able to constrain those values. ",
                    "links": [
                        "https://ethereum-magicians.org/t/eip-erc-app-keys-application-specific-wallet-accounts/2742"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.908025085034013
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "25",
                    "likes": "0",
                    "time": "04/09/2019-00:41:54",
                    "content": "    danfinlay:  We\u2019ve also had requests from developers to be able to specify valid gas values for a transaction, because some smart contracts use gas price and gas limit to encode additional data, and so they need to be able to constrain those values.   I\u2019m pretty against supporting this sort of thing in any way.  At best, it is an attempt to exploit inappropriate gas pricing of operations.  It is a strategy that is also likely to break as gas costs change over time (see Istanbul and Constantinople).  There may be other legitimate reasons to allow dapps to specify gas amounts and gas prices, but so far the only reasons I have seen are really terrible reasons that should not be supported by signing tools and should be actively discouraged by the development community. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.648313492063492
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "26",
                    "likes": "0",
                    "time": "04/09/2019-05:38:33",
                    "content": "    MicahZoltu:  r the only reasons I have seen are really terrible reasons that should not be supported by signing tools and should be actively discouraged by the development community.   One was so that a market with limited-time order offers could mandate minimum gas prices, to help ensure the buy orders would be mined soon enough to be successful. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.763888888888889
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "27",
                    "likes": "0",
                    "time": "04/09/2019-07:11:49",
                    "content": "That decision should not be up to the dapp, that is a decision for signing tool.  The user should tell the signing tool how time sensitive the transaction is and the signing tool should then set gas price accordingly. I could see an argument that the dapp should tell the signing tool the time sensitivity of the transaction directly, so the signing tool can set gas prices appropriately, but I don\u2019t think that setting the gas price is the dapp is the right solution to that problem. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.232142857142858
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "28",
                    "likes": "0",
                    "time": "04/09/2019-22:21:43",
                    "content": "    MicahZoltu:  That decision should not be up to the dapp, that is a decision for signing tool.   You should take that here:     EIP-2250: Gas Price Range Wallet Ring       Wouldn\u2019t it make sense to decouple this entirely from a given transaction?  If you want to include a transaction in a given number of blocks, and assume that the next n blocks will look roughly the same as the last n blocks, then you should be able to provide (gas, n) to an RPC method and receive gas price in return.  It would then be up to the wallet to provide this to the user, worry about if it fell within the acceptable bounds the user has specified, etc.      ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/danfinlay",
                    "index": "29",
                    "likes": "0",
                    "time": "01/10/2019-18:38:41",
                    "content": "This proposal has been submitted as EIP 2255, a very symmetrical EIP.   github.com/ethereum/EIPs       EIP 2255: Web3 Wallet Permissions System     by danfinlay   on 06:21PM - 30 Sep 19 UTC   10 commits   changed 2 files   with 155 additions   and 0 deletions.        ",
                    "links": [
                        "https://github.com/danfinlay",
                        "https://github.com/ethereum/EIPs/pull/2302",
                        "https://github.com/danfinlay",
                        "https://github.com/ethereum/EIPs/pull/2302"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kdenhartog",
                    "index": "30",
                    "likes": "0",
                    "time": "15/09/2022-01:31:48",
                    "content": "@coryhardman had a good suggestion here: https://github.com/ethereum/EIPs/pull/5593#discussion_r966492680 Seems like it\u2019s better related to this EIP instead. What do others think? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/agostbiro",
                    "index": "31",
                    "likes": "0",
                    "time": "09/03/2023-11:10:03",
                    "content": "I\u2019m wondering, what\u2019s the status of this EIP? I see that the GitHub - MetaMask/wallet-permissions-spec: A repo for describing the permissions exposed by the web3 wallet protocol. repo has been archived. Is there a follow up to that? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                }
            ]
        }
    ],
    "group_index": "906"
}