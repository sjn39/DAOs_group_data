{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/erc-1077-and-erc-1078-the-magic-of-executable-signed-messages-to-login-and-do-actions/351",
            "title": "ERC-1077 and ERC-1078: The magic of executable signed messages to login and do actions ",
            "index": 351,
            "category": [
                "EIPs"
            ],
            "tags": [
                "ux",
                "meta-transactions"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "1",
                    "likes": "8",
                    "time": "14/05/2018-15:21:37",
                    "content": "These are two ERCs that I talked about on my talk at UX Unconf:    github.com/ethereum/EIPs       ERC: Executable Signed Messages refunded by the contract     by alexvandesande   on 03:16PM - 14 May 18 UTC   7 commits   changed 1 files   with 190 additions   and 0 deletions.          github.com/ethereum/EIPs       ERC: log in / signup using ENS subdomains     by alexvandesande   on 03:17PM - 14 May 18 UTC   9 commits   changed 1 files   with 121 additions   and 0 deletions.        Would love to get feedback. Let\u2019s have this page for general feedback on all proposals, but I suggest making EIP specific feedback direclrty as GitHub comments so that I can address them line by line and change if needed ",
                    "links": [
                        "https://github.com/alexvandesande",
                        "https://github.com/ethereum/EIPs/pull/1077",
                        "https://github.com/alexvandesande",
                        "https://github.com/ethereum/EIPs/pull/1077",
                        "https://github.com/ethereum/EIPs/pull/1078",
                        "https://github.com/alexvandesande",
                        "https://github.com/ethereum/EIPs/pull/1078",
                        "https://github.com/alexvandesande",
                        "https://github.com/ethereum/EIPs/pull/1078",
                        "https://ethereum-magicians.org/t/default-accounts-for-dapps/904/9"
                    ],
                    "GPT-summary": "The author of the post introduces two ERCs and provides links to their GitHub pages. They express a desire for feedback on the proposals and suggest that specific feedback be given as GitHub comments. The post does not contain any entirely positive or negative feedback on the proposals, but rather invites others to provide feedback.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Identity and reputation systems",
                        "Interoperability and Scalability",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.3125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ricburton",
                    "index": "2",
                    "likes": "3",
                    "time": "14/05/2018-17:46:59",
                    "content": "Can we learn something from the way the Gnosis Safe is implemented?    GitHub    gnosis/safe-contracts Gnosis Safe allows secure management of blockchain assets.  - gnosis/safe-contracts      ",
                    "links": [
                        "https://github.com/gnosis/safe-contracts"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 7.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "3",
                    "likes": "2",
                    "time": "14/05/2018-18:41:02",
                    "content": "Also, uport:  uPort Meta transactions uPort safe Identities  Going to add these to examples ",
                    "links": [
                        "https://github.com/uport-project/uport-identity/blob/develop/docs/txRelay.md"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/boris",
                    "index": "4",
                    "likes": "0",
                    "time": "15/05/2018-02:21:15",
                    "content": "As I said in the room, I don\u2019t see log in / signup using ENS subdomains being any easier than the implementation of OpenID. The big issue in practice that training users that they could re-use their login proved very hard. Some users hosted their own OpenID on their own domain. But was essentially a small niche / expert usage only. Mastodon uses a similar scheme, user@mastodonserver.domain. It\u2019s a very similar use case \u2013 one mastodon network ID can be used to login to any other network \u2013 if that network allows signups and hasn\u2019t blacklisted the other ID. We might learn from their experiences. I also see this described flow going to one user owned contract? So there would be extreme correlation of activities. @alexvandesande do you have any thoughts on this issue? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.089015151515151
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "5",
                    "likes": "2",
                    "time": "15/05/2018-13:04:02",
                    "content": " The big issue in practice that training users that they could re-use their login proved very hard.  That\u2019s an interesting UX challenge, but I would say that it would be better than the current scheme, which is very user unfriendly. I would say that in order to train users, we should treat the identity like your email. Users are used on using emails as their login, but they usually have to signup or login a new one, which is usually the bad experience of accidentally clicking on the wrong link and then it tells you you can\u2019t login because you already have signed up, and then you have to click signup, type your email again and then type a few wrong passwords a few times, until you click forgot password, check your email, see no email was there, check spam messages, check email again, check facebook and forget about it. Instead, the right interface would be to whenever the user types a name, check if it exists and then use that to give them the option to create a new one or connect to the existing one. And the big difference is that you don\u2019t need to run your own server, all is on the blockchain. Also, even if you use an app to create an identity and ens login, you are its owner and you can later always register your own name and attach it to it.  I also see this described flow going to one user owned contract? So there would be extreme correlation of activities. @alexvandesande do you have any thoughts on this issue?  I agree privacy is an open issue we need to think about more solutions. I would imagine that we could for instance, allow the identity to, instead of listing the keys directly, they could list a merkle hash of a list of keys, and then use one of  these keys to move funds in a private coin, therefore enabling privacy. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.090854978354979
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/boris",
                    "index": "6",
                    "likes": "1",
                    "time": "15/05/2018-14:23:08",
                    "content": "    alexvandesande:  I would say that in order to train users, we should treat the identity like your email.   Again, this was exactly how OpenID was suggested. An identifier that looks a bit like email but isn\u2019t email. Let\u2019s just say that I\u2019m not confident that ENS subdomains is a usable solution. I don\u2019t think it\u2019s a bad idea, but I don\u2019t think it\u2019s THE solution that should suck up a lot of energy. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal"
                    ],
                    "Sentiment": 3.8333333333333335
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "7",
                    "likes": "0",
                    "time": "17/05/2018-15:15:55",
                    "content": "RE 1077 - why not make the signing standard EIP191 compatible? The multipurpose nature of the nonce field seems like a bad idea to me, too. Either pick a new timestamp-based scheme or stick with nonces; trying to overload one field for two purposes seems like unnecessary complexity. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 3.795454545454546
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "8",
                    "likes": "0",
                    "time": "17/05/2018-18:32:21",
                    "content": " RE 1077 - why not make the signing standard EIP191 compatible?  EIP191 is a general signing standard for any data. This proposes a specific set for Executable messages. It should be compatible with 191 as a subset of the more general scheme. (**edit: after re-reading and understanding 191, I will update my ERC to be compatible)  The multipurpose nature of the nonce field seems like a bad idea to me, too. Either pick a new timestamp-based scheme or stick with nonces; trying to overload one field for two purposes seems like unnecessary complexity.  Fair criticism. I find it useful for some smaller cases: specially because if you signing things that can only be executed in the future, then you cannot sign any new transactions, which might be bad for all sorts of state channel applications. But maybe this is only useful in specific use cases: another more general solution would be to treat \u201cnonce 0\u201d as a flag to ignore nonces and just save the hash of the TX as \u201cexecuted\u201d and to add the timestamp permission elsewhere in another layer as part of a more general permission scheme. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.381222943722944
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cwgoes",
                    "index": "9",
                    "likes": "1",
                    "time": "28/05/2018-16:16:28",
                    "content": "Executable signed messages are definitely a step in the right direction, but I think we can further generalize this concept. I think a prototypical Ethereum user doesn\u2019t really want to think about individual transactions at all - rather, they want to think about sets of authorized and unauthorized state transitions. Some examples:  I would like to transfer 1 Ether to my friend to pay for dinner, once, now. I would like to transfer 100 DAI to my son next Tuesday, only if his account balance is below 10 DAI, as allowance for dinner with his friends. I would like to authorize my phone to spend Ether from my main account, but only up to 2 Ether per week, in case it gets stolen. I would like to authorize CryptoKitties to transfer 0.1 Ether per month from my account for a \u201cCryptoKitty-of-the-month\u201d promotion, until I cancel this subscription. I would like to only allow transfers of more than 5 Ether if I authorize the transfer from both my laptop and my phone.  Of these, (1) can be done with an Ethereum transaction (or an executable signed message). (2), (3), (4), and (5) require writing custom contracts and complex key management (and are thus beyond the reach of ordinary users). Not only do I want to separate the notion of transaction \u201csigner\u201d from transaction \u201cdeployer\u201d, I want to separate the notion of \u201ctransaction\u201d from \u201cstate transitions\u201d - I want the ability to, with one signature, authorize an arbitrary, possibly infinite, set of well-specified state transitions. This can be done by allowing a user to specify some function v (for \u201cvalidate\u201d), which can authorize or reject transactions on the basis of chain state, transaction details, signee(s), and current time. For each of these examples, this function would do roughly the following:  Check the amount, signature, and a nonce/hash for replay protection. Check the timestamp, my son\u2019s account balance, and a nonce/hash for replay protection. Check the signee (key from my phone), a nonce/hash for replay protection, and the running counter for the amount spent this week. Check the destination, amount, and a timestamp for subscription logic (incremented by \u201ca month\u201d each call, so CryptoKitties can charge me no more than once per month). Check the signees (keys from both laptop and phone).  I think we can expand the range of options accessible to the general userbase (with well-constructed application-layer GUI support) by allowing users to sign new versions of an arbitrary, settable transaction validation function (which can itself authorize executable signed messages). A user\u2019s account contract would then have the following function: execute(   address to,   address from,   uint256 value,   bytes data,   uint nonce,   uint gasPrice,   uint gasLimit,   address gasToken,   bytes messageSignatures,   bytes validationBytecode,   uint validationTimestamp   )  execute will need to do the following:  Check that the user has signed keccak256(validationBytecode, validationTimestamp), check that validationTimestamp is strictly greater than any previously stored validationTimestamp, and store validationTimestamp. Lazily deploy a new validation contract (only if there was no previous contract for this version of validationBytecode, could even use a global registry).  DELEGATECALL into the validation contract, providing all the other parameters of execute.  The validation contract can then check transaction amount, destination, signee(s), gas, nonce/timestamp, etc. before executing the transaction, and can confirm any desired invariants after executing a transaction (such as that the contract\u2019s token balance changed by no more than a certain amount). This model is quite generic; for example, it can replace all the existing ERC20/ERC721 \u201capprove\u201d-style logic, and has the advantage (over \u201capprove\u201d) of placing all the approval information in one place (no need to track all contracts you\u2019ve ever approved), allowing custom approval logic (such as only allowing transferFrom to be called by contract A with a destination of contract B), and allowing approve and transferFrom to be executed in the same transaction. Definitely requires some fine-tuning, but hopefully the idea is clear enough, let me know what you think. May be better suited for a separate EIP or discussion elsewhere. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.130839646464647
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "10",
                    "likes": "2",
                    "time": "28/05/2018-16:50:01",
                    "content": "Thanks for the contribution @cwgoes! I completely agree with you that we need a broader more generic authorization scheme, but I would propose that this should be done on a key-basis, not per transaction. I like the idea of validationBytecode, but maybe it should be per account. Let\u2019s see the CryptoKitty-of-the-month, example:  User creates a \u201cKitty of the month\u201d subscription and shares his public keys I authorize that account to have access to my wallet contract, but I give it a validationAddress, which is a contract with a standard interface that returns an integer between 0 and, say 1M. Every month, user Kitty will sign a transaction to buy the Kitty of the month and then send it to the wallet. For every signature, the wallet will give the details of the transaction to the validation contract, and it will return a number of 0 to 1M The wallet sums all the returned amounts and if it doesn\u2019t amount to 1 million or more, then it will revert  So each logic is now contained in a reusable contract and it allows all sorts of schemes:   I would like to transfer 1 Ether to my friend to pay for dinner, once, now. Your phone has an authorization key that enables it to transfer up to 1 ether per week, so it allows it to be done with a single signed key  I would like to transfer 100 DAI to my son next Tuesday, only if his account balance is below 10 DAI, as allowance for dinner with his friends. Your son has an account that can request more allowance automatically, and it checks if it is own balance (if your son is smart he would make sure that this would be the case by transferring the money out!)  I would like to authorize my phone to spend Ether from my main account, but only up to 2 Ether per week, in case it gets stolen. same case as 1.  I would like to authorize CryptoKitties to transfer 0.1 Ether per month from my account for a \u201cCryptoKitty-of-the-month\u201d promotion, until I cancel this subscription. Cryptokitty of the month user has authorization to do a single transaction per month only for the purchase of kitties, with a limit  I would like to only allow transfers of more than 5 Ether if I authorize the transfer from both my laptop and my phone. Same as 1, but if it goes over the limit the validation contract returns 500k, therefore requiring more than one signature  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.862619047619048
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/worldlyjohn",
                    "index": "11",
                    "likes": "1",
                    "time": "29/05/2018-22:03:15",
                    "content": " Again, this was exactly how OpenID was suggested. An identifier that looks a bit like email but isn\u2019t email. Let\u2019s just say that I\u2019m not confident that ENS subdomains is a usable solution.  I don\u2019t think OpenID failed because it was a single identity for the user.  IMO it failed because there was no incentive for websites to adopt this (no users) and no reason for users to adopt (no websites). Facebook Connect won because publishers (websites) received more information (birthday, gender, etc) on top of email that they would have received if they built their own Auth.  And Users adopted this because it was less friction to click a button and \u201cautofill\u201d then create and remember yet another username/pw combination. Times have changed, but they also haven\u2019t.  I\u2019d urge anyone thinking about developing SSO/self sovereign identity to think about incentives/motivations for both users and websites to adopt this. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.201058201058201
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/cwgoes",
                    "index": "12",
                    "likes": "0",
                    "time": "03/06/2018-20:55:33",
                    "content": "Thanks @alexvandesande! I agree that splitting up groups of transaction authorizations into separate contracts makes sense, it allows easier management on the part of the user and doesn\u2019t require redeploying one large \u201cvalidation function\u201d contract every time the user wants to change their authorizations. Moreover, it should be the case that these validation contracts can be shared between users, so a single contract can handle a \u201cCryptoKitty of the month\u201d subscription for all subscribers. I don\u2019t quite understand the 500K / 1M return integer. Is that a way for the validation contract to tell the account contract whether or not a transaction is valid? Why not just use a boolean, or perhaps a list of keys which need to have signed the transaction? With grouped authorization contracts as I understand them, the examples could work like the following: User starts out with an account contract, which exposes an execute function as above, but with the additional parameter of address validationAddress. In addition to the checks listed above, when execute is called, the account contract checks that the calling contract (msg.sender) was granted permission by the user to use the specified validationAddress (in many cases, msg.sender can be anyone, but the validationAddress needs to have been explicitly authorized).   I would like to transfer 1 Ether to my friend to pay for dinner, once, now. I\u2019ve previously created a \u201cphone validation contract\u201d, and authorized my phone\u2019s public key to use this validation contract. The phone signs a message to transfer 1 Ether, the phone validation contract checks that the transfer amount is less than or equal to 1, and the transaction clears.  I would like to transfer 100 DAI to my son next Tuesday, only if his account balance is below 10 DAI, as allowance for dinner with his friends. I\u2019ve previously created an \u201callowance validation contract\u201d and authorized my son\u2019s public key to use this validation contract. My son signs a message to pay himself allowance, and the \u201callowance validation contract\u201d checks that the amount is correct and that he hasn\u2019t already withdrawn allowance this week.  I would like to authorize my phone to spend Ether from my main account, but only up to 2 Ether per week, in case it gets stolen. Same case as 1.  I would like to authorize CryptoKitties to transfer 0.1 Ether per month from my account for a \u201cCryptoKitty-of-the-month\u201d promotion, until I cancel this subscription. I authorize the existing \u201cCryptoKitty-of-the-month\u201d public key to use the \u201cCryptoKitty-of-the-month validation contract\u201d, which checks that the amount is correct, that I\u2019m only charged once per month, and that I get my CryptoKitty.  I would like to only allow transfers of more than 5 Ether if I authorize the transfer from both my laptop and my phone. I authorize a multisig validation contract, which can send any transaction but requires signatures from both my laptop and phone public keys (messageSignatures are forwarded to the validation contract).  Is that in line with your model, or did you have something different in mind? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.224914965986395
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "13",
                    "likes": "0",
                    "time": "04/06/2018-13:48:40",
                    "content": "    cwgoes:  I don\u2019t quite understand the 500K / 1M return integer. Is that a way for the validation contract to tell the account contract whether or not a transaction is valid? Why not just use a boolean, or perhaps a list of keys which need to have signed the transaction?   It should not just return a boolean of either a transaction is valid or not, because there are many cases in which what you want is actually \u201cthis transaction requires an additional confirmation from another transaction\u201d. So, for instance, my son can make any purchase up to $100 monthly, but anything up to $250 he needs also my (or my wife\u2019s) approval, and anything over $500 he needs both mom and dad to approve. A boolean, would not suffice there. Or the example you mentioned which for some transactions you need both the laptop and phone to approve. Returning an integer is therefore more flexible, because then you can have more flexibility: if a transaction requires 4 approvals, each transaction contributes 25% of the sum. Maybe there\u2019s a \u201cmaster key\u201d that is worth 2 votes, etc. ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 6.799999999999999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pet3rpan",
                    "index": "14",
                    "likes": "1",
                    "time": "11/06/2018-23:30:43",
                    "content": "We might need a central identity contract manager etc. like a portal to accept claims add keys etc. similar to my crypto wallet except the fund management. You can then add another field to the delegate call signed data (ERC191) and add the dapp\u2019s authenticated siganture, dapp title and dapp website. Delegated call     (         byte(0x19),         byte(0),         from,         to,         value,         dataHash,         nonce,         gasPrice,         gasLimit,         gasToken,         callPrefix,         operationType,         extraHash         ++ dappSignature,         ++dappwWebsite,         ++dappTitle,     );  DappSignature - Something to authenticate the dapp itself, maybe even use something as central certification authority? If you have these incorporated into the ERC191 delegate call then in the front end identity manager you could potentially monitor the activity of the contract in a more user friendly way vs. strings of hexidecimals You could even then set warnings, black lists, white lists for authenticated dapps? Ideas The itunes of dapps  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.442708333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pranay01",
                    "index": "15",
                    "likes": "0",
                    "time": "12/09/2018-16:49:29",
                    "content": "@alexvandesande Does this scheme mean that a new identity contract is created for each user or that same identity contract can be used for multiple users? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.779829545454545
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "16",
                    "likes": "0",
                    "time": "12/09/2018-17:27:22",
                    "content": "Each user gets an identity contract (there are cheap ways to do that) which is shared by all apps. But the same identity address can own multiple ens username and a user can choose to own more identities. ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 6.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pranay01",
                    "index": "17",
                    "likes": "0",
                    "time": "13/09/2018-02:45:49",
                    "content": "To clarify, by \u201cuser\u201d do you mean a person in meat space or just a public/private key?  and a user can choose to own more identities  By this do you mean a \u201cuser\u201d in meat space can have multiple private keys? Or you mean that a public key (which defines a user) can be associated with multiple identity contracts? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.073863636363636
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "18",
                    "likes": "0",
                    "time": "13/09/2018-12:53:43",
                    "content": "Any meatspace person or entity can create multiple identities contracts (but they only need one). An identity contract can interact with any number of apps (no need to be one app one account). An identity contract can hold multiple names (but each name can only point to one identity contract back) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pranay01",
                    "index": "19",
                    "likes": "1",
                    "time": "28/09/2018-06:02:11",
                    "content": "Got it. Another question, since the private keys send signed transactions to relayers (which are centralised entities), can\u2019t relayer do arbitrary things with this transaction. For example, send this to a contract which is not  an identity contract, etc? Also, what type of orgs/entities will host these relayers. Can the relayers have any business model (like in case of Dharma relayers) or we expect well respected institutions like EthFoundation etc. to host these relayers. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 4.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "20",
                    "likes": "0",
                    "time": "28/09/2018-12:19:49",
                    "content": " Another question, since the private keys send signed transactions to relayers (which are centralised entities), can\u2019t relayer do arbitrary things with this transaction.  No. The identity will only execute things that are signed by approved keys, so the relayer cannot force the identity to do anything. The only power the relayer has is to refuse service to the user, but that is avoidable because the user can in theory simply use another relayer.  For example, send this to a contract which is not an identity contract, etc?  Not sure I understand: are you saying that an arbitrary unrelated contract could accept these transactions signed by other people? The message signed includes the identity address, so the identity will only accept messages that were signed to itself. Of course, you can always build another contract that ignores this and accepts signed messages meant for others, but I don\u2019t see why someone would do it. ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 4.680555555555555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pranay01",
                    "index": "21",
                    "likes": "0",
                    "time": "29/09/2018-02:37:43",
                    "content": "Yes, I was thinking of the scenario where the message is relayed to another contract which accepts the message, but its effectively a denial of service - as  you have pointed out. So, for this mechanism to work, there needs to be a market for relayers ( basically you should be able to chose another, if one is denying service). For that to happen, relayers should be incentivised in some way, right? So, a commission based model or do expect some other mechanism to incentivise them? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.575892857142858
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "22",
                    "likes": "0",
                    "time": "01/10/2018-11:56:19",
                    "content": "relayers are incentivized. They\u2019re paid in tokens or ether by the user ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Amxx",
                    "index": "23",
                    "likes": "0",
                    "time": "16/01/2019-11:10:06",
                    "content": "I believe there is a typo in section 2a. The think the identity is to support ERC725 and not ERC720 has stated. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/NoahMarconi",
                    "index": "24",
                    "likes": "0",
                    "time": "10/05/2019-17:32:46",
                    "content": "How set are you on the argument names? I\u2019m working on a use case for Native Metatransactions and the to and from argument names have a different meaning (opposite meaning in fact). For identity contracts like your reference implementation, from makes sense to be address(this) but for native metatransactions from is really the target contract and to is really the signer. Are you open to more specific names such as signer and targetContract? This would be a step toward having the standard cover both identity contracts as well as native metatransactions (e.g. a token with built in signed message meta transfer) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/NoahMarconi",
                    "index": "25",
                    "likes": "0",
                    "time": "11/05/2019-16:59:39",
                    "content": "The more I think about this, I think a bigger change is needed to be compatible with native transactions. For native metatransactions your to is always address(this), which is also true for from. Who is signing is no longer an internally stored value/array and needs to be passed as an argument. Don\u2019t want to unnecessarily introduce yet another EIP. Do you think there\u2019s a path forward to make 1077 suit the native meta transaction use case? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.45
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wighawag",
                    "index": "26",
                    "likes": "0",
                    "time": "14/05/2019-14:46:42",
                    "content": "Hi @NoahMarconi I came to the same conclusion: 1077 is not currently compatible with native meta transaction, see my comments here I thus created a new EIP for native meta transaction : https://github.com/ethereum/EIPs/issues/1776 Feel free to give feedback there. ",
                    "links": [
                        "https://github.com/ethereum/EIPs/issues/1776"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.670454545454545
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Dobrokhvalov",
                    "index": "27",
                    "likes": "1",
                    "time": "10/07/2019-16:27:23",
                    "content": "    alexvandesande:  ERC: Executable Signed Messages refunded by the contract   Hey guys, I believe chainId param should be added in order to avoid replay attack on different chains. With the addition of CREATE2 opcode it\u2019s possible and even desirable to have the same identity contract address on different chains. This allows replaying transactions on other chains. e.g. sending a transaction on xDai chain will allow draining ETH on Mainnet from the same identity address. In order to prevent it, I believe chainId should be added to executeSigned params and identity contract should check that chainId is correct before executing a transaction. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.895833333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/3esmit",
                    "index": "28",
                    "likes": "0",
                    "time": "09/01/2020-02:48:31",
                    "content": "Hey @alexvandesande and everyone, I am updating the EIP-1077. See here https://github.com/ethereum/EIPs/pull/2454 ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                }
            ]
        }
    ],
    "group_index": "887"
}