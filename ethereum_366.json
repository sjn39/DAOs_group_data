{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-8000-expirable-transaction-with-block-number-deadline/13058",
            "title": "EIP-8000: Expirable Transaction with Block Number Deadline ",
            "index": 13058,
            "category": [
                "EIPs",
                "Core EIPs"
            ],
            "tags": [
                "consensus-layer",
                "gas"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/hiddenintheworld",
                    "index": "1",
                    "likes": "0",
                    "time": "26/02/2023-13:15:37",
                    "content": " Abstract We propose the introduction of a time-based transaction expiration mechanism in Ethereum. The mechanism would allow users to set an expiration block number for their transactions, after which the transaction would expire and be removed from the mempool. This would give users more control over their transactions and reduce unnecessary network traffic caused by failed transactions. The expiration block number would be a parameter that users could set while creating their transactions. If the transaction is not included in a block before the expiration block number, it would expire, and the gas used for the transaction would be refunded to the sender\u2019s account. This would ensure that users are not charged for transactions that are not processed and also reduce the load on the network. This EIP proposes the introduction of a new transaction type, based on EIP-1559, with a new format: 0x02 || rlp([chain_id, nonce, expiration_block_number, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s]). This new transaction type includes an expiration block number, which can be set by the sender. A transaction will only be valid if the current block number is less than or equal to the expiration block number. The transaction specifies the expiration block number as the deadline for when the transaction is valid. If the expiration block number is reached, the transaction will fail, and no gas fee will be paid.  Motivation Ethereum has had a significant number of failed transactions, leaving users with no option but to replace transactions with a higher gas fee and 21000 gas limit transaction (ETH native transaction). This process is inefficient, and there is no way for a transaction to timeout and not be mined once it is sent to the mempool.   Lack of flexbility for user: It can be incredibly frustrating to be unable to cancel an unnecessary transaction, especially when using platforms like Uniswap to swap tokens or when buying NFTs.  Network traffic with useless transaction meant to fail: In the absence of a transaction expiration mechanism, these failed transactions can remain in the mempool for extended periods of time, leading to unnecessary network traffic. Furthermore, these failed transactions can create network congestion and make it more difficult for other transactions to be processed in a timely manner.  This proposal aims to provide a solution to this inefficiency. With the introduction of an expiration block number, transactions can expire if they are not mined within a specific period, providing users with more flexibility to cancel  Specification Transaction is only valid if the expiration_block_number is greater than or equal to the current block number, the transaction is considered expired and cannot be included in the block otherwise. Block validity is defined in the reference implementation below. The NUMBER (0x43) opcode REPRESENT the block.number as defined in the reference implementation below. As of FORK_BLOCK_NUMBER, a new EIP-2718 transaction is introduced with TransactionType 2. The EIP-2718 TransactionPayload for this transaction is rlp([chain_id, nonce, expiration_block_number, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s]). The signature_y_parity, signature_r, signature_s elements of this transaction represent a secp256k1 signature over keccak256(0x02 || rlp([chain_id, nonce, expiration_block_number, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list])). The EIP-2718 ReceiptPayload for this transaction is rlp([status, cumulative_transaction_gas_used, logs_bloom, logs]). Note: // is integer division, round down. from typing import Union, Dict, Sequence, List, Tuple, Literal from dataclasses import dataclass, field from abc import ABC, abstractmethod  @dataclass class TransactionLegacy: \tsigner_nonce: int = 0 \tgas_price: int = 0 \tgas_limit: int = 0 \tdestination: int = 0 \tamount: int = 0 \tpayload: bytes = bytes() \tv: int = 0 \tr: int = 0 \ts: int = 0  @dataclass class Transaction2930Payload:     chain_id: int = 0     signer_nonce: int = 0     gas_price: int = 0     gas_limit: int = 0     destination: int = 0     amount: int = 0     payload: bytes = bytes()     access_list: List[Tuple[int, List[int]]] = field(default_factory=list)     signature_y_parity: bool = False     signature_r: int = 0     signature_s: int = 0  @dataclass class Transaction2930Envelope: \ttype: Literal[1] = 1 \tpayload: Transaction2930Payload = Transaction2930Payload()  @dataclass class Transaction8000Payload:     chain_id: int = 0     signer_nonce: int = 0     expiration_block_number: int = 0     max_priority_fee_per_gas: int = 0     max_fee_per_gas: int = 0     gas_limit: int = 0     destination: int = 0     amount: int = 0     payload: bytes = bytes()     access_list: List[Tuple[int, List[int]]] = field(default_factory=list)     signature_y_parity: bool = False     signature_r: int = 0     signature_s: int = 0  @dataclass class Transaction8000Envelope: \ttype: Literal[2] = 2 \tpayload: Transaction8000Payload = Transaction8000Payload()  Transaction2718 = Union[Transaction8000Envelope, Transaction2930Envelope]  Transaction = Union[TransactionLegacy, Transaction2718]  @dataclass class NormalizedTransaction:     signer_address: int = 0     signer_nonce: int = 0     expiration_block_number: int = 0     max_priority_fee_per_gas: int = 0     max_fee_per_gas: int = 0     gas_limit: int = 0     destination: int = 0     amount: int = 0     payload: bytes = bytes()     access_list: List[Tuple[int, List[int]]] = field(default_factory=list)  @dataclass class Block: \tparent_hash: int = 0 \tuncle_hashes: Sequence[int] = field(default_factory=list) \tauthor: int = 0 \tstate_root: int = 0 \ttransaction_root: int = 0 \ttransaction_receipt_root: int = 0 \tlogs_bloom: int = 0 \tdifficulty: int = 0 \tnumber: int = 0 \tgas_limit: int = 0 # note the gas_limit is the gas_target * ELASTICITY_MULTIPLIER \tgas_used: int = 0 \ttimestamp: int = 0 \textra_data: bytes = bytes() \tproof_of_work: int = 0 \tnonce: int = 0 \tbase_fee_per_gas: int = 0  @dataclass class Account: \taddress: int = 0 \tnonce: int = 0 \tbalance: int = 0 \tstorage_root: int = 0 \tcode_hash: int = 0  INITIAL_BASE_FEE = 1000000000 INITIAL_FORK_BLOCK_NUMBER = 10 # TBD BASE_FEE_MAX_CHANGE_DENOMINATOR = 8 ELASTICITY_MULTIPLIER = 2  class World(ABC): \tdef validate_block(self, block: Block) -> None: \t\tparent_gas_target = self.parent(block).gas_limit // ELASTICITY_MULTIPLIER \t\tparent_gas_limit = self.parent(block).gas_limit  \t\t# on the fork block, don't account for the ELASTICITY_MULTIPLIER to avoid \t\t# unduly halving the gas target. \t\tif INITIAL_FORK_BLOCK_NUMBER == block.number: \t\t\tparent_gas_target = self.parent(block).gas_limit \t\t\tparent_gas_limit = self.parent(block).gas_limit * ELASTICITY_MULTIPLIER   \t\tparent_base_fee_per_gas = self.parent(block).base_fee_per_gas \t\tparent_gas_used = self.parent(block).gas_used \t\ttransactions = self.transactions(block)                  \t\t# check if the block used too much gas \t\tassert block.gas_used <= block.gas_limit, 'invalid block: too much gas used'  \t\t# check if the block changed the gas limit too much \t\tassert block.gas_limit < parent_gas_limit + parent_gas_limit // 1024, 'invalid block: gas limit increased too much' \t\tassert block.gas_limit > parent_gas_limit - parent_gas_limit // 1024, 'invalid block: gas limit decreased too much'  \t\t# check if the gas limit is at least the minimum gas limit \t\tassert block.gas_limit >= 5000  \t\t# check if the base fee is correct \t\tif INITIAL_FORK_BLOCK_NUMBER == block.number: \t\t\texpected_base_fee_per_gas = INITIAL_BASE_FEE \t\telif parent_gas_used == parent_gas_target: \t\t\texpected_base_fee_per_gas = parent_base_fee_per_gas \t\telif parent_gas_used > parent_gas_target: \t\t\tgas_used_delta = parent_gas_used - parent_gas_target \t\t\tbase_fee_per_gas_delta = max(parent_base_fee_per_gas * gas_used_delta // parent_gas_target // BASE_FEE_MAX_CHANGE_DENOMINATOR, 1) \t\t\texpected_base_fee_per_gas = parent_base_fee_per_gas + base_fee_per_gas_delta \t\telse: \t\t\tgas_used_delta = parent_gas_target - parent_gas_used \t\t\tbase_fee_per_gas_delta = parent_base_fee_per_gas * gas_used_delta // parent_gas_target // BASE_FEE_MAX_CHANGE_DENOMINATOR \t\t\texpected_base_fee_per_gas = parent_base_fee_per_gas - base_fee_per_gas_delta \t\tassert expected_base_fee_per_gas == block.base_fee_per_gas, 'invalid block: base fee not correct'  \t\t# execute transactions and do gas accounting \t\tcumulative_transaction_gas_used = 0 \t\tfor unnormalized_transaction in transactions: \t\t\t# Note: this validates transaction signature and chain ID which must happen before we normalize below since normalized transactions don't include signature or chain ID \t\t\tsigner_address = self.validate_and_recover_signer_address(unnormalized_transaction) \t\t\ttransaction = self.normalize_transaction(unnormalized_transaction, signer_address)  \t\t\tsigner = self.account(signer_address)  \t\t\tsigner.balance -= transaction.amount \t\t\tassert signer.balance >= 0, 'invalid transaction: signer does not have enough ETH to cover attached value' \t\t\t# the signer must be able to afford the transaction \t\t\tassert signer.balance >= transaction.gas_limit * transaction.max_fee_per_gas                          # ensure that the transaction has not expired                         assert transaction.expiration_block_number >= block.number  \t\t\t# ensure that the user was willing to at least pay the base fee \t\t\tassert transaction.max_fee_per_gas >= block.base_fee_per_gas  \t\t\t# Prevent impossibly large numbers \t\t\tassert transaction.max_fee_per_gas < 2**256 \t\t\t# Prevent impossibly large numbers \t\t\tassert transaction.max_priority_fee_per_gas < 2**256 \t\t\t# The total must be the larger of the two \t\t\tassert transaction.max_fee_per_gas >= transaction.max_priority_fee_per_gas  \t\t\t# priority fee is capped because the base fee is filled first \t\t\tpriority_fee_per_gas = min(transaction.max_priority_fee_per_gas, transaction.max_fee_per_gas - block.base_fee_per_gas) \t\t\t# signer pays both the priority fee and the base fee \t\t\teffective_gas_price = priority_fee_per_gas + block.base_fee_per_gas \t\t\tsigner.balance -= transaction.gas_limit * effective_gas_price \t\t\tassert signer.balance >= 0, 'invalid transaction: signer does not have enough ETH to cover gas' \t\t\tgas_used = self.execute_transaction(transaction, effective_gas_price) \t\t\tgas_refund = transaction.gas_limit - gas_used \t\t\tcumulative_transaction_gas_used += gas_used \t\t\t# signer gets refunded for unused gas \t\t\tsigner.balance += gas_refund * effective_gas_price \t\t\t# miner only receives the priority fee; note that the base fee is not given to anyone (it is burned) \t\t\tself.account(block.author).balance += gas_used * priority_fee_per_gas  \t\t# check if the block spent too much gas transactions \t\tassert cumulative_transaction_gas_used == block.gas_used, 'invalid block: gas_used does not equal total gas used in all transactions'  \t\t# TODO: verify account balances match block's account balances (via state root comparison) \t\t# TODO: validate the rest of the block  \tdef normalize_transaction(self, transaction: Transaction, signer_address: int) -> NormalizedTransaction: \t\t# legacy transactions \t\tif isinstance(transaction, TransactionLegacy): \t\t\treturn NormalizedTransaction( \t\t\t\tsigner_address = signer_address, \t\t\t\tsigner_nonce = transaction.signer_nonce, \t\t\t\texpiration_block_number = transaction.expiration_block_number, \t\t\t\tgas_limit = transaction.gas_limit, \t\t\t\tmax_priority_fee_per_gas = transaction.gas_price, \t\t\t\tmax_fee_per_gas = transaction.gas_price, \t\t\t\tdestination = transaction.destination, \t\t\t\tamount = transaction.amount, \t\t\t\tpayload = transaction.payload, \t\t\t\taccess_list = [], \t\t\t) \t\t# 2930 transactions \t\telif isinstance(transaction, Transaction2930Envelope): \t\t\treturn NormalizedTransaction( \t\t\t\tsigner_address = signer_address, \t\t\t\tsigner_nonce = transaction.payload.signer_nonce, \t\t\t\texpiration_block_number = transaction.expiration_block_number, \t\t\t\tgas_limit = transaction.payload.gas_limit, \t\t\t\tmax_priority_fee_per_gas = transaction.payload.gas_price, \t\t\t\tmax_fee_per_gas = transaction.payload.gas_price, \t\t\t\tdestination = transaction.payload.destination, \t\t\t\tamount = transaction.payload.amount, \t\t\t\tpayload = transaction.payload.payload, \t\t\t\taccess_list = transaction.payload.access_list, \t\t\t) \t\t# 8000 transactions \t\telif isinstance(transaction, Transaction8000Envelope): \t\t\treturn NormalizedTransaction( \t\t\t\tsigner_address = signer_address, \t\t\t\tsigner_nonce = transaction.payload.signer_nonce, \t\t\t\texpiration_block_number = transaction.expiration_block_number, \t\t\t\tgas_limit = transaction.payload.gas_limit, \t\t\t\tmax_priority_fee_per_gas = transaction.payload.max_priority_fee_per_gas, \t\t\t\tmax_fee_per_gas = transaction.payload.max_fee_per_gas, \t\t\t\tdestination = transaction.payload.destination, \t\t\t\tamount = transaction.payload.amount, \t\t\t\tpayload = transaction.payload.payload, \t\t\t\taccess_list = transaction.payload.access_list, \t\t\t) \t\telse: \t\t\traise Exception('invalid transaction: unexpected number of items')  \t@abstractmethod \tdef parent(self, block: Block) -> Block: pass  \t@abstractmethod \tdef block_hash(self, block: Block) -> int: pass  \t@abstractmethod \tdef transactions(self, block: Block) -> Sequence[Transaction]: pass  \t@abstractmethod \tdef execute_transaction(self, transaction: NormalizedTransaction, effective_gas_price: int) -> int: pass  \t@abstractmethod \tdef validate_and_recover_signer_address(self, transaction: Transaction) -> int: pass  \t@abstractmethod \tdef account(self, address: int) -> Account: pass   Backwards Compatibility This proposal is backwards compatible with existing Ethereum transactions to EIP-1559 . It is an optional feature that is only included in transactions that utilize the new format specified in this EIP.  Security Considerations  Potentially be exploited by malicious actors The introduction of an expiration block number feature could potentially be exploited by malicious actors to attempt to invalidate transactions that are still valid. However, this risk is mitigated by setting a minimum block number limit on the expiration block number, which will ensure that transactions remain valid for a reasonable amount of time.  Nodes gatekeeping Additionally, nodes on the Ethereum network can enforce a maximum block number limit for expiration block numbers to further reduce the risk of exploitation, the mempool could also drop all transactions that have expired.  Copyright Copyright and related rights waived via [CC0]. ",
                    "links": [],
                    "GPT-summary": "The proposal suggests introducing a time-based transaction expiration mechanism in Ethereum to allow users to set an expiration block number for their transactions. This would give users more control over their transactions and reduce unnecessary network traffic caused by failed transactions. The proposal explains the motivation behind the proposal, the specification of the proposed transaction type, and the security considerations. The proposal also includes code examples and data structures. A 3rd party could give constructive criticism, ask questions, or audit and review the proposal.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Privacy, Security and risk management",
                        "Interoperability and Scalability",
                        "Token economics",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None"
                    ],
                    "Sentiment": 4.545044492544493
                }
            ]
        }
    ],
    "group_index": "366"
}