{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://gov.gitcoin.co/t/refactoring-gitcoin-dao-whats-in-a-name/12679",
            "title": "Refactoring Gitcoin DAO: What's in a name? ",
            "index": 12679,
            "category": [
                "\\xf0\\x9f\\xa7\\x99 \\xf0\\x9f\\xa7\\x99\\xe2\\x80\\x8d\\xe2\\x99\\x80\\xef\\xb8\\x8f Ideas and Open Discussion"
            ],
            "tags": [
                "NONE"
            ],
            "content": [
                {
                    "author_link": "https://gov.gitcoin.co/u/kevin.olsen",
                    "index": "#1",
                    "likes": "4",
                    "time": "26/01/2023-12:41:39",
                    "content": "In my attempts to bring the \u201cDAO insider\u201d work that I\u2019m apart of into more public spaces, I felt it would help to step back and offer up a post on how I think about problems. I hope it\u2019s of value to someone.  Background So, a bit of context on my background and my approach to solving issues, what I mean by refactoring, and how I see names as the high-value place to start addressing change in our DAO. In the arc of my career, I\u2019ve spent a lot of time in and around code, but not just coding or programming specifically, but software design and software engineering. There are some concepts from these disciplines that I have internalized deeply enough that it\u2019s hard sometimes to tell where those beliefs come from. This pops up in funny non-coding places for me these days, namely: names. I hate things that are named wrong. I find acronyms or names that force you to translate their meaning every time you use them not just irritating but alarming. Like literally, when I hear a badly named thing, an alarm goes off in my head. This is not a subtweet at the branding work. I think that process stands and brands are a bit of a different animal. But this alarm has been useful, and I\u2019ve tried to pay attention to it. It comes from the years I\u2019ve spent trying to organize software and systems, and I want to try and explain the importance of names in the hope that my recommendations to rename things can be seen for what they are: an attempt at good systems design.  Does all code crumble? I\u2019m going to walk this back to the beginning. At first, every programmer starts out just learning to code. Just building stuff that works is the hard thing. But at some point, you encounter the next hard problem: codebases get big, they begin to get buggy, they\u2019re hard to work in, and eventually, they start to crumble. It feels like a fact of nature: code slowly rots. It\u2019s in encountering this \u201cfact\u201d that a fine distinction between just coding and something else emerges. This next thing is software engineering. I think the Xooglers that wrote the book Software Engineering at Google own the best definition in the section Programming Over Time:  We propose that \u2018software engineering\u2019 encompasses not just the act of writing code, but all of the tools and processes an organization uses to build and maintain that code over time [\u2026] Software engineering can be thought of as programming integrated over time.\u201d Software Engineering at Google  And now, as someone thinking about coding in terms of software engineering (including the processes and tooling), you see there are some projects where this \u201cfact\u201d you saw early in your career doesn\u2019t hold up - there are cleaner, healthier codebases that don\u2019t slowly crumble. You start wanting to build lasting things, things that scale, things that don\u2019t break down slowly over time. And in this part of your journey, you\u2019ll encounter a number of techniques: automated testing,  test driven design, clean code, CI/CD, domain driven design, etc. Each of these contributes tools to let you build maintainable systems, not just at a code level, but at a human-to-human level, at a level where the organization of your work supports the maintainability of the systems you build. Let\u2019s zoom in on two turning points where naming things emerged as clear benefits to building maintainable systems  Cleaner Code  \u201cAny fool can write code that a computer can understand. Good programmers write code that humans can understand\u201d \u2014 Martin fowler  Clean code was something I encountered fairly early on, and it\u2019s a bit too big to get into, but one of the core parts of this is to write your code in a way that lowers the cognitive load of those that have to read it, or extend it later. Clean Code - Reveal your intent:  var d: Int // elapsed time in days a name that requires a comment does not reveal it\u2019s intent var elapsedTimeInDays: Int the name of a variable should tell us the significance of what that variable contains Clean Code - Naming - by Uncle Bob - part 3 | Bogdan Poplauschi  Kevin, hold it, why do I care. I don\u2019t code. You don\u2019t need to code, relax. What this example shows is that the code itself now captures the meaning that the programmer was trying to express with the comment. When that var d gets used later on, potentially dozens of lines of code later it won\u2019t have that comment next to it, and the semantic meaning is lost. The programmer will just be seeing that d in some new context and have to remember, \u2018oh yeah, that means elapsed time in days\u2019. The clean code approach is to give that d a meaning, reveal the intent of that variable by naming it elapsedTimeInDays so when the programmer encounters it many lines later, away from any comment or explanation of what that variable is, they can reason about it in line, no mental lookup or translation necessary. So really good names in your code is great and we should all do it. Glad we all agree. Moving ON!  Building a Ubiquitous Language Now that your code is clean and intention-revealing, you\u2019ll notice that you are still doing these mental lookups and translations in conversations with colleagues and in meetings with stakeholders. You\u2019ll realize you\u2019re constantly translating concepts from your non-engineering colleagues (business, design, product) into concepts in your codebase. If you inherit a legacy codebase or stick around a project long enough, these concepts can drift very far apart! This higher-order problem is core to Eric Evan\u2019s Domain Driven Design: Tackling Complexity in the Heart of Software  (great title) in a concept he repeats (ad nauseam) called Ubiquitous Language. Ubiquitous Language is the creation and maintenance of a shared vocabulary end to end - from the customer to the codebase. For those that were in the event storm as we kicked off the build-out of the Grants Stack / Allo protocol, this ubiquitous language was part of what @lthrift and I were trying to establish. But this is also meant to be a living practice:  Domain experts should object to terms or structures that are awkward or inadequate to convey domain understanding; developers should watch for ambiguity or inconsistency that will trip up design._ \u2013 Eric Evans  Framed in the negative, Evans\u2018s ideas on what we should avoid:   The lack of a common language, generating \u201ctranslations\u201d, which is bad for the Domain Model, and causes the creation of wrong Domain Models. Team members using terms differently without realizing it, for lack of a common language. Communication without using Ubiquitous Language, even if it exists. Creation of abstraction by the technical team for the construction of the Domain Model, which is not understood by domain experts. Technical team disregarding the participation of domain experts in the Domain Model, considering it too abstract for domain experts. But it is necessary that domain experts participate, because who can validate the Domain Model that was built? Developing the ubiquitous language - DDD - The Domain Driven Design   Got it, so we all use the same vocabulary to describe our system and we\u2019re all good! Yes. AND we make this a continuous process to check that our vocabulary matches reality and that we update our vocabulary every time our model, our strategy, and our macro context change. Everytime our Domain changes.  Refactoring the DAO  In computer programming and software design, code refactoring is the process of restructuring existing computer code\u2014changing the factoring\u2014without changing its external behavior. Refactoring is intended to improve the design, structure, and/or implementation of the software (its non-functional attributes), while preserving its functionality. Potential advantages of refactoring may include improved [\u2026] readability and reduced complexity; these can improve [\u2026] maintainability and create a simpler, cleaner, or more expressive internal architecture or object model to improve extensibility. - Code refactoring - Wikipedia  At the point I\u2019m at in my software engineering journey, I see how software, codebases, teams, and organizations are all helped tremendously by good naming. As I think about and suggest refactorings to the DAO, naming is the low-hanging fruit. Because naming our work badly manifests in the accumulating friction from many repeated low-level translations, mistranslations, and misuse we incur when mapping other team\u2019s concepts onto our work. It is a tax we all pay daily to get things done: as we onboard new contributors, as stewards and workstream leads struggle to understand each other\u2019s budgets, in the anxiety our DAO Community expresses on the forum. We need to reduce this mental burden. This is at the core of my recommendations: How can we reveal intent in a name that everyone can use as they navigate the complex and abstract structures of these human and software systems we are building? I see the solution in clean names mapping the work being done to the budgets we are funding.  These are the slim workstreams as I see them. It\u2019s my belief the fear of a sprawling and unmaintainable DAO would largely be solved with clear, intent revealing workstream names. I\u2019ve formed this belief about the importance of naming over the years from my experiences with software engineering (in the broadest possible definition), and I\u2019m basing quite a lot of my recommendations on these beliefs. I hope this post helps elucidate at least some of my process and may even help to introduce a tool into the systems design work we do here in organizing and running our DAO. ",
                    "links": [
                        "https://bpoplauschi.github.io/2021/01/30/Clean-Code-Naming-by-Uncle-Bob-part-3.html",
                        "https://a.co/d/1JXcj1b",
                        "https://thedomaindrivendesign.io/developing-the-ubiquitous-language/",
                        "https://en.wikipedia.org/wiki/Code_refactoring"
                    ],
                    "GPT-summary": null,
                    "GPT-proposal-categories": null,
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.2867433735854785
                },
                {
                    "author_link": "https://gov.gitcoin.co/u/owocki",
                    "index": "#2",
                    "likes": "1",
                    "time": "26/01/2023-15:26:33",
                    "content": "Thanks for the post and the background context/why behind it.     kevin.olsen:  I see the solution in clean names mapping the work being done to the budgets we are funding. These are the slim workstreams as I see them. It\u2019s my belief the fear of a sprawling and unmaintainable DAO would largely be solved with clear, intent revealing workstream names.   Is there any work scheduled to define the work at Gitcoin in this way?  Has anyone taken a stab at naming workstreams in this way? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.480952380952381
                },
                {
                    "author_link": "https://gov.gitcoin.co/u/kevin.olsen",
                    "index": "#3",
                    "likes": "1",
                    "time": "26/01/2023-15:30:47",
                    "content": "Thanks man. This was definitely present in my support of the GPC\u2019s decision to split up into Passport and Allo Protocol. That said, I don\u2019t think there\u2019s been a holistic effort yet to map all the work done in the DAO to the right names. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.80952380952381
                },
                {
                    "author_link": "https://gov.gitcoin.co/u/birdsoar",
                    "index": "#4",
                    "likes": "1",
                    "time": "27/01/2023-02:11:52",
                    "content": "Thank you for writing this, it\u2019s been awhile since I considered the principles of code. Good to be reacquainted.     kevin.olsen:  This is not a subtweet at the branding work. I think that process stands and brands are a bit of a different animal.   Thank you for calling this out!! My first thought was, \u201cOh no, he hates the name Allo.\u201d  In a general sense, I\u2019m in agreement that naming things as they are is the best approach. One of my first suggestions when joining Gitcoin was to rename workstreams in a way that describes our respective intents more clearly. I could also seeing this being of benefit to people in the workstreams. Beyond the social energy that comes with (thoughtful) new names, updating our names could be an opportunity to inspire a renewed sense of purpose. Looking forward to seeing this conversation develop. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.424873737373737
                }
            ]
        }
    ],
    "group_index": "309"
}