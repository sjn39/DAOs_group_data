{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-2565-big-integer-modular-exponentiation-eip-198-gas-cost/4150",
            "title": "EIP-2565: Big integer modular exponentiation (EIP-198) gas cost ",
            "index": 4150,
            "category": [
                "EIPs"
            ],
            "tags": [
                "gas",
                "eip-2565"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "1",
                    "likes": "0",
                    "time": "21/03/2020-15:52:55",
                    "content": " eip:  title: Big integer modular exponentiation (EIP-198) gas cost author: Kelly Olson (@ineffectualproperty), Sean Gulley (@sean-sn), Simon Peffers (@simonatsn), Justin Drake (@justindrake), Dankrad Feist (@dankrad) discussions-to: TBD status: Draft type: Standards Track category: Core created: 2020-03-20 Requires:   Simple Summary The EIP-198 \u2018big integer modular exponentiation\u2019, or ModExp, precompile is currently overpriced. Re-pricing this precompile will enable more cost efficient verification of RSA signatures, verifiable delay functions (VDFs), primality checks, and more. Abstract After benchmarking the ModExp precompile, we discovered that it is \u2018overpriced\u2019 relative to other precompiles. We also discovered that the current gas pricing formula could be improved to better estimate the computational complexity of various ModExp input variables. To improve the gas cost pricing for this precompile the following options are available:   Changing the value of the GQUADDIVISOR parameter in the ModExp pricing formula to bring its costs more in-line with other precompiles   Modifying the gas pricing formula to better reflect the computational complexity of ModExp operations   Improving the underlying libraries beneath the ModExp Precompile   Any combination of (1), (2), and (3)   We recommend Option (1) which provides a large practical improvement to gas estimation while keeping implementation complexity low. Options (2) and (3) could also be implemented and would further improve the gas pricing for a broader range of use cases. Additional data can be provided for options (2) and (3) as desired. Motivation Modular exponentiation is a foundational arithmetic operation for many cryptographic functions including signatures, VDFs, SNARKs, accumulators, and more. Unfortunately, the ModExp precompile is currently over-priced, making these operations inefficient and expensive. By reducing the cost of this precompile, these cryptographic functions become more practical, enabling improved security, stronger randomness (VDFs), and more. Specification The current gas pricing formula is defined in EIP-198. This formula divides a \u2018computational complexity\u2019 function by a \u2018gas conversion\u2019 parameter called \u2018GQUADDIVISOR\u2019 to arrive at a gas cost.  Recommended Option (1): Change value of GQUADDIVISOR GQUADDIVISOR is set to \u201820\u2019 per EIP-198. We recommend changing the value of this parameter to \u2018200\u2019. Option (2): Modify \u2018computational complexity\u2019 function A proposed \u2018complexity\u2019 function can be found at the following spreadsheet Code defining an improved complexity function can be provided as needed, but this option is not recommended at this time. Option (3): Replace libraries used by ModExp precompiles ModExp benchmarks for different libraries can be found at the following spreadsheet While alternative libraries can provide improved performance, this option is not recommended at this time. Rationale  Recommended Option (1): Change value of GQUADDIVISOR: Changing the value of this parameter from 20 to 200 will reduce the gas cost of this precompile by a factor of 10 with minimal implementation changes. With this change, the cost of the ModExp precompile will have a higher cost (gas/second) than other precompiles such as ECRecover.  1600\u00d7897 109 KB  Option (2): Modify \u2018computational complexity\u2019 formula A proposed \u2018complexity\u2019 function can be found at the following spreadsheet.  1224\u00d71526 84.9 KB  The new complexity function has a better fit vs. the execution time when compared to the current complexity function. This better fit is because the new complexity formula accounts for the use of binary exponentiation algorithms that are used by \u2018bigint\u2019 libraries for large exponents. You may also notice the regression line of the proposed complexity function bisects the test vector data points. This is because the run time varies depending on if the modulus is even or odd. While modifying the computational complexity formula can improve gas estimation at a medium implementation cost, we do not recommend it at this time. Option (3): Improving the ModExp precompile implementations  1600\u00d7607 275 KB  Replacing the underlying library can improve the performance of the ModExp precompile by 2x-4x for large exponents, but comes at a high implementation cost. We do not recommend this option at this time. Test Cases As no underlying algorithms are being changed, there are no additional test cases to specify. References EIP-198 Copyright Copyright and related rights waived via CC0. ",
                    "links": [
                        "https://docs.google.com/spreadsheets/d/1Fq3d3wUjGN0R_FX-VPj7TKhCK33ac--P4QXB9MPQ8iw/edit?usp=sharing",
                        "https://docs.google.com/spreadsheets/d/1Fq3d3wUjGN0R_FX-VPj7TKhCK33ac--P4QXB9MPQ8iw/edit?usp=sharing",
                        "https://ethereum-magicians.org/uploads/default/original/2X/6/674eb9fa0cbca92c5fd2c5396fff8d59b4c62308.png",
                        "https://docs.google.com/spreadsheets/d/1Fq3d3wUjGN0R_FX-VPj7TKhCK33ac--P4QXB9MPQ8iw/edit?usp=sharing",
                        "https://ethereum-magicians.org/uploads/default/original/2X/5/51674d9d1a927b63322983afe04b52e12343e837.png",
                        "https://ethereum-magicians.org/uploads/default/original/2X/0/0d2846ae1172149b8d7b55ca4bda8d81de1e5ba4.png",
                        "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-198.md",
                        "https://creativecommons.org/publicdomain/zero/1.0/"
                    ],
                    "GPT-summary": "The proposal suggests that the EIP-198 'big integer modular exponentiation' precompile is currently overpriced and provides options to improve the gas cost pricing for this precompile. The proposal recommends changing the value of the GQUADDIVISOR parameter in the ModExp pricing formula to bring its costs more in-line with other precompiles. The proposal also suggests modifying the gas pricing formula to better reflect the computational complexity of ModExp operations and improving the underlying libraries beneath the ModExp Precompile. The proposal provides data and rationale for each option and recommends Option (1) which provides a large practical improvement to gas estimation while keeping implementation complexity low.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Privacy, Security and risk management",
                        "Token economics",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.664991432178931
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "2",
                    "likes": "0",
                    "time": "31/03/2020-21:13:42",
                    "content": "This EIP has now been approved to be merged under \u2018draft\u2019 status here: https://github.com/ethereum/EIPs/pull/2565 Additional comments or feedback are appreciated. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "3",
                    "likes": "0",
                    "time": "08/09/2020-07:41:32",
                    "content": "So, afaiu, option 2 was accepted for YOLOv2 integration. Specification:  GQUADDIVISOR is set to 20 per EIP-198. We recommend changing the value of this parameter to 3 to account for the changes in the recommended \u2018computational complexity\u2019 formula above.  Think this is poorly specified. Changing it from 20 to 3 increases the gascost. So as I understand it, the spec should really say   Implement formula changes from Option 1. Change GQUADDIVISOR (defined as 20 in EIP-198) to 3.   ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.666666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "4",
                    "likes": "0",
                    "time": "08/09/2020-09:40:18",
                    "content": "The EIP is very vague in other respects aswell. For example, (but the same thing is in several places) - here\u2019s a snippet from option 1:  In addition to modifying the mult_complexity formula as above, we also recommend wrapping the entire function with a minimum gas price of 100 to ensure that a minimum amount of gas is used when the precompile is called e.g. max(100,floor(mult_complexity(x)/GQUADDIVISOR))  That\u2019s an example of where a vital point in the spec is almost an afterthought in a footnote placed after the test-vector link. The EIP should clearly assert the specification, and say  In addition to modifying the mult_complexity formula as above, the entire function is wrapped to guarantee a minimum gas price of 100 :     return max(100,floor(mult_complexity(x)/GQUADDIVISOR))`   But the example there doesn\u2019t match even so - because it omits the  * max(ADJUSTED_EXPONENT_LENGTH, 1) part from the original spec? The original 198 spec is floor(mult_complexity(max(length_of_MODULUS, length_of_BASE)) * max(ADJUSTED_EXPONENT_LENGTH, 1) / GQUADDIVISOR)   So shouldn\u2019t the example be x = max(length_of_MODULUS, length_of_BASE) y = floor(mult_complexity(x) * max(ADJUSTED_EXPONENT_LENGTH, 1) / GQUADDIVISOR)  return max(100, y)  ? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.072916666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "5",
                    "likes": "0",
                    "time": "08/09/2020-09:49:54",
                    "content": "For option 1, you link to a spreadsheet which contains the expected gas costs. However, for option 2, you link here, and I can\u2019t seem to find the reference gas costs for option 2. Could you please provide those too? Ideally, have an appendix on the form     testcase EIP-198 gas 2565 opt  1 gas 2565 opt 2 gas     modexp_nagydani_1_square 204 100 100    \u2026 Ah wait, this is a total mess. So the EIP says:  Recommended Option (1): Modify \u2018computational complexity\u2019 function and add minimum gas cost Recommended Option (2): Change value of GQUADDIVISOR GQUADDIVISOR is set to 20 per EIP-198. We recommend changing the value of this parameter to 3 to account for the changes in the recommended \u2018computational complexity\u2019 formula above.  But the description here, on this forum, says  Recommended Option (1): Change value of GQUADDIVISOR: GQUADDIVISOR is set to \u201820\u2019 per EIP-198. We recommend changing the value of this parameter to \u2018200\u2019. Option (2): Modify \u2018computational complexity\u2019 function  So,  the options are turned around,  and the GQUADDIVISOR new value is 3 on the EIP, and 200 here.  I have no idea what to make of this.  I guess we leave the formula as is, but modify GQUADDIVISOR to 200, and do we also skip adding a minimum gas cost?  Furthermore,  Option (3): Replace libraries used by ModExp precompiles  That option has no place in the EIP \u2013 it\u2019s a good recommendation to have if you\u2019re presenting material to the ACD, but there\u2019s no consensus change involved. IMO it should be removed from the EIP. ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-2565"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.0438311688311686
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "6",
                    "likes": "0",
                    "time": "08/09/2020-15:32:59",
                    "content": "Hi @holiman - thanks for the feedback. I saw some other similar suggested feedback from @MicahZoltu as well and will clarify the EIP to make it more spec-focused than proposal focused. I will incorporate your suggested changes as well and include an appendix with the updated test vectors and post back here once an updated PR is made in the next day or two. Thanks for the feedback. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.553571428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/tkstanczak",
                    "index": "7",
                    "likes": "0",
                    "time": "22/09/2020-23:02:35",
                    "content": "@holiman do you have a link to the test vectors? I have been asking for it for a while but the spreadsheet only seems to contain some data about the test vectors but not the exact values also - which libraries are considered fast enough to support it? the spreadsheet verifies Geth, gmp and OpenSSL. The gmp library is GPL licensed so we cannot use it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.5625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "8",
                    "likes": "0",
                    "time": "22/09/2020-23:23:48",
                    "content": "Hey @tkstanczak - my apologies as I have been slow to update the EIP as I\u2019ve been consumed with a few other things. I will update this post tomorrow with a link to the updated EIP along with the updated test vectors. As for libraries, most big integer libraries are of sufficient performance, though the Rust modular exponentiation is slow. OpenSSL is Apache2 licensed and I believe that GMP is now LGPL. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "3rd party giving additional information on proposal"
                    ],
                    "Sentiment": 4.645833333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "9",
                    "likes": "0",
                    "time": "23/09/2020-07:33:56",
                    "content": "Hi @holiman and @tkstanczak. The updated EIP is now available in this PR: https://github.com/ethereum/EIPs/pull/2892. It includes test vectors as suggested. @holiman I\u2019ve also created a prototype of the proposed changes to Geth here: https://gist.github.com/ineffectualproperty/9811fbe573eae600420c93336d379038 Please let me know if anything remains unclear or if you have any recommendations to improve it. ",
                    "links": [
                        "https://gist.github.com/ineffectualproperty/9811fbe573eae600420c93336d379038"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 7.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "10",
                    "likes": "0",
                    "time": "23/09/2020-07:39:08",
                    "content": "Updated EIP 09/23/20 Simple Summary The EIP-198 \u2018big integer modular exponentiation\u2019, or ModExp, precompile is currently overpriced. Re-pricing this precompile will enable more cost efficient verification of RSA signatures, verifiable delay functions (VDFs), primality checks, and more. Abstract After benchmarking the ModExp precompile, we discovered that it is \u2018overpriced\u2019 relative to other precompiles. We also discovered that the current gas pricing formula could be improved to better estimate the computational complexity of various ModExp input variables. To improve the gas cost pricing for this precompile, this EIP specifies:  A change to the mult_complexity formula to better reflect the computational complexity of ModExp operations A change to the value of the GQUADDIVISOR parameter in the ModExp pricing formula to bring its costs more in-line with other precompiles A minimum cost to call the precompile to prevent underpricing for small inputs  Motivation Modular exponentiation is a foundational arithmetic operation for many cryptographic functions including signatures, VDFs, SNARKs, accumulators, and more. Unfortunately, the ModExp precompile is currently over-priced, making these operations inefficient and expensive. By reducing the cost of this precompile, these cryptographic functions become more practical, enabling improved security, stronger randomness (VDFs), and more. Specification The current gas pricing formula is defined in EIP-198 as follows: floor(mult_complexity(max(length_of_MODULUS, length_of_BASE)) * max(ADJUSTED_EXPONENT_LENGTH, 1) / GQUADDIVISOR)  As of FORK_BLOCK_NUMBER make the following changes to the pricing formula for the ModExp precompile: 1: Modify the mult_complexity function The current complexity function, as defined in EIP-198 is as follow: def mult_complexity(x):     if x <= 64: return x ** 2     elif x <= 1024: return x ** 2 // 4 + 96 * x - 3072     else: return x ** 2 // 16 + 480 * x - 199680  where is x is max(length_of_MODULUS, length_of_BASE) This complexity formula was meant to approximate the difficulty of Karatsuba multiplication. However, we found a better approximation for modelling modular exponentiation. We recommend the following formula to better estimate the computational complexity for varying input values: def mult_complexity(x):     ceiling(x/8)^2  where is x is max(length_of_MODULUS, length_of_BASE). x is divided by 8 to account for the number of limbs in multiprecision arithmetic. 2. Change value of GQUADDIVISOR  GQUADDIVISOR is set to 20 per EIP-198. We recommend changing the value of this parameter to 3 to account for the changes in the recommended \u2018computational complexity\u2019 formula above. 3. Set a minimum price for calling the precompile We recommend wrapping the entire function with a minimum gas price of 200 to ensure that a minimum amount of gas is used when the precompile is called e.g. max(200,floor(mult_complexity(max(length_of_MODULUS, length_of_BASE)) * max(ADJUSTED_EXPONENT_LENGTH, 1) / GQUADDIVISOR)) Rationale 1. Modify \u2018computational complexity\u2019 formula to better reflect the computational complexity A comparison of the current \u2018complexity\u2019 function and the proposed function against the execution time can be seen below: 1224\u00d71526 84.9 KB The new complexity function has a better fit vs. the execution time when compared to the current complexity function. This better fit is because the new complexity formula accounts for the use of binary exponentiation algorithms that are used by \u2018bigint\u2019 libraries for large exponents. You may also notice the regression line of the proposed complexity function bisects the test vector data points. This is because the run time varies depending on if the modulus is even or odd. 2. Change the value of GQUADDIVISOR After changing the \u2018computational complexity\u2019 formula it is necessary to change QGUADDIVSOR to bring the gas costs inline with their runtime. We recommend changing the value from \u201820\u2019 to \u20183\u2019. With this change, the cost of the ModExp precompile will have a higher cost (gas/second) than other precompiles such as ECRecover. 1944\u00d71060 158 KB 3. Set a minimum gas cost to prevent abuse This prevents the precompile from underpricing small input values. Test Cases There are no changes to the underlying interface or arithmetic algorithms, so the existing test vectors can be reused. Below is a table with the updated test vectors:     Test Case EIP-198 Pricing New Pricing     modexp_nagydani_1_square 204 200   modexp_nagydani_1_qube 204 200   modexp_nagydani_1_pow0x10001 3276 341   modexp_nagydani_2_square 665 200   modexp_nagydani_2_qube 665 200   modexp_nagydani_2_pow0x10001 10649 1365   modexp_nagydani_3_square 1894 341   modexp_nagydani_3_qube 1894 341   modexp_nagydani_3_pow0x10001 30310 5461   modexp_nagydani_4_square 5580 1365   modexp_nagydani_4_qube 5580 1365   modexp_nagydani_4_pow0x10001 89292 21845   modexp_nagydani_5_square 17868 5461   modexp_nagydani_5_qube 17868 5461   modexp_nagydani_5_pow0x10001 285900 87381    Security Considerations The biggest security consideration for this EIP is creating a potential DoS vector by making ModExp operations too inexpensive relative to their computation time. Copyright Copyright and related rights waived via CC0. ",
                    "links": [
                        "https://ethereum-magicians.org/uploads/default/original/2X/5/5c96c90bfe966669e3a06da46ea7a00fd3cc2f77.png",
                        "https://creativecommons.org/publicdomain/zero/1.0/"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.635888771092853
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "11",
                    "likes": "0",
                    "time": "23/09/2020-10:43:57",
                    "content": "I\u2019m not getting the same numbers. Let\u2019s consider modexp_nagydani_pow0x10001: length_of_MODULUS = 64 length_of_BASE = 64 multComplexity(64) = 1 1 * max(16, 1) = 16 16 / 3 = 5 min(200,5) = 200     TestPrecompiledModExpEip2565/nagydani-1-pow0x10001-Gas=200: contracts_test.go:105: nagydani-1-pow0x10001: gas wrong, expected 341, got 200  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "12",
                    "likes": "0",
                    "time": "23/09/2020-16:01:35",
                    "content": "@holiman My apologies! I had a mix-up with bytes and bits. Could you please try the following update to represent the size of a limb in bytes (previously was 64 as I had incorrectly represented it in bits). def mult_complexity(x):     ceiling(x/8)^2  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.583333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "13",
                    "likes": "0",
                    "time": "24/09/2020-10:12:45",
                    "content": "Yep, now the numbers match up. I made a PR for geth: https://github.com/ethereum/go-ethereum/pull/21607 ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shemnon",
                    "index": "14",
                    "likes": "0",
                    "time": "02/10/2020-19:26:18",
                    "content": "Where can we get the new test vectors seen on the spreadsheet (v1->v52, or new test vector 1 through new test vector 52)? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.681818181818182
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "15",
                    "likes": "0",
                    "time": "06/10/2020-00:09:23",
                    "content": "Hey @shemnon - I\u2019m unfortunately unable to find the underlying values that were generated for the performance analysis as it looks like I only saved the lengths in the excel sheet at the time. This EIP does not propose the addition of any new test vectors, rather merely updates the calculated gas for the existing set of test vectors as shown above. You can find the most recent EIP updates here: https://github.com/ethereum/EIPs/pull/2892. The references to the Excel spreadsheet performance analysis have been removed at the request of the EIP repository maintainers. On last weeks ACD call it was suggested that Besu and Nethermind teams should run a benchmark to understand the performance of their ModExp libraries as Geth has done. If it possible to provide a benchmark for the 15 existing test vectors I\u2019d be happy to run them through the new pricing formula to ensure that pricing stays above ~15M gas/second and doesn\u2019t present any DoS risk for the Besu client. Please let me know if I can help answer any other questions. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.159902597402597
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "16",
                    "likes": "0",
                    "time": "06/10/2020-19:21:09",
                    "content": "An update has been pushed to the EIP based on feedback: https://github.com/ethereum/EIPs/pull/2892 A Python implementation has been added for clarity here: https://gist.github.com/ineffectualproperty/60e34f15c31850c5b60c8cf3a28cd423 ",
                    "links": [
                        "https://gist.github.com/ineffectualproperty/60e34f15c31850c5b60c8cf3a28cd423"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "17",
                    "likes": "0",
                    "time": "08/10/2020-05:05:38",
                    "content": "The EIP has been merged as last call and can be viewed here: https://eips.ethereum.org/EIPS/eip-2565 @shemnon and @tkstanczak it would be great if you could benchmark your existing ModExp precompile with the existing EIP-198 test vectors (https://raw.githubusercontent.com/ethereum/go-ethereum/master/core/vm/testdata/precompiles/modexp.json) to ensure that this repricing doesn\u2019t cause any gas issues for the Besu or Nethermind clients. If you post them here I can create a table with the gas/second using the proposed pricing scheme. The original EIP was run on a 4th gen Intel i7 but any modern laptop/desktop should be sufficient to run the benchmark. ",
                    "links": [
                        "https://raw.githubusercontent.com/ethereum/go-ethereum/master/core/vm/testdata/precompiles/modexp.json"
                    ],
                    "GPT-discussion-categories": [],
                    "Sentiment": 6.71875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "18",
                    "likes": "1",
                    "time": "08/10/2020-21:02:01",
                    "content": "Following up on an off-forum conversation with @timbeiko. The Besu team has now implemented the EIP-2565 gas pricing and is seeing the correct results for all test vectors. ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/poojaranjan",
                    "index": "19",
                    "likes": "0",
                    "time": "07/01/2021-20:04:08",
                    "content": "Peep an EIP-2565 with Kelly Olson ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "20",
                    "likes": "0",
                    "time": "08/03/2021-02:17:31",
                    "content": "Migrating discussion from https://github.com/ethereum/EIPs/pull/2892#issuecomment-792239908 to here: @tkstanczak   Hi, my intuition is that the complexity of the calculation is defined by the last 32 bits more than the first 32 bits, hence the more granular calculation there? (length -32) * 8 (ignoring zeros) + last_32_very detailed. Now I also think that maybe the author felt that the last n - 32 bits may be assumed to be filled and we do not care about bits set so much but for the first 32 bits it defines the number of iterations much more\u2026 Would be great to confirm with authors as the spec is not entirely clear here but it may have consequence for potential attacks? I have changed it on nethermind to match Geth\u2019s calculation (which may or may not be correct interpretation of the \u2018&\u2019 logic in the spec.   @holiman   I still think this EIP should be updated to be more clear about the formula. Both @tkstanczak, @karalabe and myself found it very hard to read, as opposed to the earlier phrasing from EIP-198.   @kelly   I can revert @MicahZoltu\u2019s suggested changes to the specification so that is consistent with EIP-198 in the next day or two which should hopefully clear up any confusion   ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.005208333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "21",
                    "likes": "0",
                    "time": "08/03/2021-02:23:40",
                    "content": "  Would be great to confirm with authors as the spec is not entirely clear here    @tkstanczak In what way is the spec not entirely clear?  It is written in Python and thus extremely precise.    I still think this EIP should be updated to be more clear about the formula.   @holiman Same question as above, additional feedback on what specifically you find unclear about the provided ~10 lines of python would be more valuable than \u201cI like the old one better\u201d.  Python is extremely specific, English is not.  A relevant comic to lighten the discussion: image650\u00d7613 146 KB ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.839285714285714
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/holiman",
                    "index": "22",
                    "likes": "0",
                    "time": "08/03/2021-07:39:17",
                    "content": "    MicahZoltu:  Same question as above, additional feedback on what specifically you find unclear about the provided ~10 lines of python would be more valuable than \u201cI like the old one better\u201d. Python is extremely specific, English is not.   Ok. let\u2019s compare.  ADJUSTED_EXPONENT_LENGTH is defined as follows. \u2026 If length_of_EXPONENT > 32, then return 8 * (length_of_EXPONENT - 32) plus the index of the highest bit in the first 32 bytes of EXPONENT  Versus  elif exponent_length > 32: iteration_count = (8 * (exponent_length - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)  These two examples describe the same thing. However:  The former can be read and it\u2019s clear what the intention is. It can be easily reasoned about. The latter is very hard to read and reason about. However, as you point out, it\u2019s a great reference implementation, since it can be executed and the reader can experiment with it: both to figure out what it\u2019s doing, and to verify against their own implementation.  But having to experiment with the python implementation to figure out how it behaves is not ideal, IMO.    Further: The latter implementation does not reuse the same definitions. It does not talk define ADJUSTED_EXPONENT_LENGTH, but instead calculate_iteration_count. The first point in the rationale says   Modify \u2018computational complexity\u2019 formula to better reflect the computational complexity\". \u2026 In the complexity formula defined in this EIP, x is divided by 8 to account for the number of limbs in multiprecision arithmetic\"   The second says  setting the QGUADDIVISOR to 3  And thirdly  Set a minimum gas cost to prevent abuse  All in all, three specific changes. But looking at the python implementation, it\u2019s very difficult to figure out that it\u2019s in fact only three specific changes that are made. Conclusion So my preferred specification change would be:  Use the original phrasing as much as possible, Add a \u201creference implementation\u201d section, where the current full python implementation can reside.  @tkstanczak If you can add the details on how you misinterpreted it, I think that would be a good as an example. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.4135101010101
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/tkstanczak",
                    "index": "23",
                    "likes": "0",
                    "time": "08/03/2021-12:21:10",
                    "content": "Hi, I interpreted this part incorrectly: exponent & (2**256 - 1)  I used bitwise and on the last 256 bits of exponents instead of the first 256 bits (this makes more sense to me when reading code like this - it is surprising for me that python uses the first bits. If Python uses the first 256 bits then I would only expect that if it was interpreting the number as a machine representation (then, probably little endian which would maybe make sense) So the spec in the format that @holiman suggested would allow me to avoid a failing test that I spent some time on searching the cause for. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.923611111111111
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "24",
                    "likes": "0",
                    "time": "09/03/2021-11:23:20",
                    "content": "    tkstanczak:  I used bitwise and on the last 256 bits of exponents instead of the first 256 bits (this makes more sense to me when reading code like this - it is surprising for me that python uses the first bits.   My understanding is that exponent & (2**256 - 1) should be the same as exponent % 2**256 (and in fact, in Python this appears to be the case).  This is why I think the python implementation is a better specification because \u201cfirst 32 bytes of EXPONENT\u201d is ill defined since \u201cfirst\u201d depends on endianness.  Hopefully @kelly can give us insight to make sure that the python implementation is currently correct. Also, we should probably have a test case for > 256-bit exponent. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.1
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "25",
                    "likes": "0",
                    "time": "09/03/2021-11:29:33",
                    "content": "    holiman:   ADJUSTED_EXPONENT_LENGTH is defined as follows. \u2026 If length_of_EXPONENT > 32, then return 8 * (length_of_EXPONENT - 32) plus the index of the highest bit in the first 32 bytes of EXPONENT  Versus  elif exponent_length > 32: iteration_count = (8 * (exponent_length - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)  These two examples describe the same thing. However:  The former can be read and it\u2019s clear what the intention is. It can be easily reasoned about. The latter is very hard to read and reason about. However, as you point out, it\u2019s a great reference implementation, since it can be executed and the reader can experiment with it: both to figure out what it\u2019s doing, and to verify against their own implementation.  But having to experiment with the python implementation to figure out how it behaves is not ideal, IMO.      I\u2019m not sure how to resolve our disagreement here since I find the python definition easier to read than the English definition, especially since \u201cfirst\u201d is ambiguous (see comments above).  However, that is certainly a subjective statement.     holiman:  All in all, three specific changes. But looking at the python implementation, it\u2019s very difficult to figure out that it\u2019s in fact only three specific changes that are made.   I believe this is our repeated debate rearing its ugly head again, where you want EIPs to be written for an audience of current client developers and I want EIPs written for future client developers.  It is a difference of whether an EIP is a \u201cdiff\u201d or it is a \u201cnew state of the world\u201d definition. Hypothetically, if the Ethereum client specification was in a GitHub repository like the PoS specification is in a GitHub repository, and instead of EIPs we just had PRs against the spec, would you generally favor such a system?  In that case, every \u201cEIP\u201d would just be a diff of the spec (in the form of a GitHub pull request or git diff). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.853690476190477
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kelly",
                    "index": "26",
                    "likes": "0",
                    "time": "10/03/2021-21:15:48",
                    "content": "Hey all, sorry for the delay in responding. To add some clarification, I believe that the current Python implementation is correct. One thing to note is that the \u2018calculate_iteration_count\u2019 which is under debate here is equivalent to \u2018adjusted_exponent_length\u2019 as specified in EIP-198, and no changes to this formula are suggested in this EIP (other than the naming change which was suggested). In fact, the original EIP-2565 called this equivalency out, and this was even noted directly in the Python implementation, but it was suggested that this note be removed (see outdated suggestions here: https://github.com/ethereum/EIPs/pull/2892#pullrequestreview-503780228). If it would be preferable we can revert to the previous version which builds on EIP-198. Please let me know if there is any other confusion or questions I can answer. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.473958333333333
                }
            ]
        }
    ],
    "group_index": "1031"
}