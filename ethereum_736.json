{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/erc-1066-ethereum-status-codes-esc/283",
            "title": "ERC-1066: Ethereum Status Codes (ESC) ",
            "index": 283,
            "category": [
                "EIPs"
            ],
            "tags": [
                "dx",
                "erc-1066"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "1",
                    "likes": "10",
                    "time": "05/05/2018-21:23:16",
                    "content": "Hi everyone  I\u2019ve submitted an EIP to bring status codes to the Ethereum ecosystem (link below). This proposal is purely about convention, requires no changes to the EVM, and is usable today. Further investigation is being done to potentially add these to the transaction status field, but that is out of scope of this EIP. ERC-1066 outlines a common set of Ethereum status codes (ESC) in the same vein as HTTP statuses or BEAM tagged tuples. This is a shared set of signals to allow smart contracts to react to situations autonomously, expose localized error messages to users, and so on. Feedback, discussion, and suggested statuses are all greatly appreciated   Links  ERC-1066  Helper library and examples (WIP)  ",
                    "links": [
                        "https://github.com/Finhaven/EthereumStatusCodes",
                        "https://ethereum-magicians.org/t/human-readable-machine-verifiable-transaction-requests/750/2",
                        "https://ethereum-magicians.org/t/update-on-erc-1066-status-codes-project/1334",
                        "https://ethereum-magicians.org/t/lightning-talk-ethereum-status-codes-erc-1066/770",
                        "https://ethereum-magicians.org/t/community-call-fission-codes-translations/1538",
                        "https://ethereum-magicians.org/t/rc-shout-message-hub/853/2",
                        "https://ethereum-magicians.org/t/dapplets-rethinking-dapp-architecture-for-better-adoption-and-security/2799/33"
                    ],
                    "GPT-summary": "The author has submitted an EIP to bring status codes to the Ethereum ecosystem. The proposal outlines a common set of Ethereum status codes (ESC) to allow smart contracts to react to situations autonomously and expose localized error messages to users. The author is asking for feedback, discussion, and suggested statuses.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Change to proposal pipeline",
                        "Community and engagement",
                        "None",
                        "None"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None"
                    ],
                    "Sentiment": 5.455357142857142
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chfast",
                    "index": "2",
                    "likes": "0",
                    "time": "18/05/2018-09:54:51",
                    "content": "Hi there, I understand the scope of this EIP is much bigger, but see the EVM status codes: https://github.com/ethereum/evmc/blob/master/include/evmc/evmc.h#L199. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "3",
                    "likes": "0",
                    "time": "23/05/2018-18:58:49",
                    "content": "Ah, good point! Will update that mention in the EIP; thanks! ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 7.8125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "4",
                    "likes": "0",
                    "time": "28/05/2018-15:38:12",
                    "content": "Solidity has support for revert with messages since 0.4.22, so I suppose the idea here would be to use these status codes on these error messages too, correct? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "5",
                    "likes": "2",
                    "time": "28/05/2018-17:09:39",
                    "content": "Status codes in this proposal are orthogonal to revert-with-message, and are fully compatible with them. Revert really ends the transaction, and status codes are meant primarily for communicating between contracts, in much the same way as an actor system would. As such, the scope extends far beyond just types of failure or reverting, and are ideally used to automate system flow and user feedback. Part of the design goal is to make these compatible with revert-with-message, including a message in the correct language, level of technical detail, and so on. Here is an example from the helper library of a function that will fail with a message when the status is not ok. Further work is being done to translate codes in on-chain registry to fail with an automated message based on the caller\u2019s preferences. Here is an example of some early work in that direction with English translations of codes. ",
                    "links": [
                        "https://github.com/Finhaven/EthereumStatusCodes/pull/16/files#diff-3f6431823099c7468ff4199ec78ed4a8R5"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.111111111111111
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "6",
                    "likes": "1",
                    "time": "29/05/2018-17:50:16",
                    "content": "Thanks for doing this @expede! I was looking at some default contracts in the ethereum.org and I already felt the need for a few error codes for very common situations, as I found myself overusing \u201cdisallowed\u201d and \u201cfailure\u201d for everything. I suggest adding:   Not enough balance: this can be used for sending tokens, checking allowances, buying stuff etc. Maybe 0x36? We have 0x10 Disallowed but I would like the errors to be more specific: User not authorized for functions that are onlyOwner, onlyMember and other generic auths, and Action not authorized for when the action itself, not the users, are forbidden. Maybe I would even be more specific and add a Not allowed at this time for actions that timestamp specific (can only be done before or after a given deadline).  Maybe I\u2019m being too specific, one could argue that all Disallowed erros always mean that user cannot do this action at this time and that asking for too much specificity will pollute the error table. But from the point of view of a user interface wallet that is warning the user that an action will not be permitted, it would be good to have a distinction to show the user why the action is returning an error: is it that you cannot to it, or is that you must wait? Maybe we should add sub-error-tables? 0x10 Disallowed 0x101 User not permitted 0x102 Action not permitted 0x103 Disallowed at this time  (Just noticed 0x15\tNo Longer Allowed. Maybe we also need a 0x16 Not Allowed Yet then?) Also\u2026 What should be the error code for integer overflow? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.391477272727273
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shrugs",
                    "index": "7",
                    "likes": "1",
                    "time": "12/06/2018-23:02:44",
                    "content": "Is including application-specific error contexts part of this EIP? i.e., adding \u201creasons\u201d to the status codes. I bring this up because in protocols like HTTP, status codes are used for informing clients of errors in a standard way so that that they can retry a request, disable a feature, require a login, etc. This EIP accomplishes that  . Generally, though, people also include information in the request body beyond the status code, to indicate application-specific things like Permission Denied: Upgrade your Account to Pro which the UI can then display to the user. Anyway that would be useful for contracts as well, primarily for compatibility between revert-with-reason, which people have already started adding english error messages to. revert-with-reason using english messages isn\u2019t a really great way of accomplishing this:  strings are expensive to store/transmit if a smaller identifier would suffice english, while the canonical language of the web, shouldn\u2019t really be expected   It\u2019d be cool if I could return an error context along with the status code, but also if that error context were compacted like: returns (byte status, bytes4 reasonId)  where reasonId is perhaps bytes4(keccak256(\"Account is not Pro\")). The mapping of reasonId->humanReadableReason can be managed within a single-address registry contract that anyone is free to add to (perhaps a custom ENS registry!). This gives everyone with access to Ethereum a way to resolve, off-chain, what the context of the error is and display it within things like truffle. If internationalization is desired, an off-chain service can be made (similar to the 4 byte directory) which tracks the mapping of reasonId to the error string. This would also be cool for revert with reason: require(thing, ) The reasonId could also be the first 3 bytes, so that it could be concatenated with the status byte to create a compact returns (bytes4 statusAndReason) syntax. smart contracts can just do byte(statusAndReason) to get their status code, and off-chain tools can easily splice to get the reason, and then perform the lookup on their own (a smart contract shouldn\u2019t really need to do any lookups on-chain for a reason string). Anyway, just looking for feedback on whether or not that approach is 1) worth discussion and 2) should be part of this EIP or another, later EIP ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.94824016563147
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "8",
                    "likes": "0",
                    "time": "20/06/2018-17:08:05",
                    "content": "Hi @shrugs, Yes, indeed both are part of the EIP! Glad to see that others are on the same wavelength. There are two distinct use cases for status codes:  Automation User feedback  Automation is pretty straightforward: we just need a lightweight code. User feedback is very broad, and should account for things like translation and varying levels of detail.  Custom Codes The 0xA* range is dedicated to application-specific codes for contract authors to define. This assumes that 16 codes is sufficient for application-specific codes. I don\u2019t think that I\u2019ve worked with a module that needs more than a handful, but hey, it could happen? I would expect this to be a code smell, though. In that case, the appropriate thing may be to do as you suggest: serialize a bunch of context or come up with a custom scheme of subcodes. (Imposing a design up front would lead to edge cases on this edge case, I think).  Human Readable Messages Status code translation contracts are currently being sourced in English, Polish, French, Japanese, and German. If you (or anyone you know) are able to translate to other languages, that would be very welcome! The ones in the repo are meant as a starting point, with ongoing, community-controlled voting on better/preferred translations that live in a smart contract. However, I  think that contract authors should have the choice to use alternate translations if they choose, and may point their application Context-specific information probably shouldn\u2019t be passed around in messages, but kept right at the message site (ex. revert with reason). There are edge cases where it\u2019s appropriate, and nothing is stopping people from doing that if the need arises. The messages that are going to come out of the translation table aren\u2019t sacred, and authors should feel free to append or otherwise alter them as needed.  ENS Ah, I hadn\u2019t considered giving them all ENS names! Great idea  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.263522727272727
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "9",
                    "likes": "0",
                    "time": "20/06/2018-17:38:52",
                    "content": "Hi @alexvandesande,  Permissions Ah, good idea on onlyOwner, &c! I hadn\u2019t considered these, but they\u2019re exceedingly common. Will add! There actually is a Not allowed Yet  An earlier draft even was called that verbatim, but we reprhrased it as 0x13 Awaiting Permission.  Sub-codes We\u2019ve explored this, and are not a fan. There\u2019s an infinite level of granularity, and the combinatoral complexity makes translation nearly impossible. It\u2019s a less-is-more case: by limiting ourselves (if 256 is \u201climited\u201d ), we can do more with each code. Situations that are deeply context-specific can come along something like one of the following: returns (byte status, string message)  // ex. (hex\"A0\", \"System went boom\")  returns(byte status, uint8 customSubcode) // ex. (hex\"10\", 1)  returns (byte status, uint8 requiredAuthLevel, address[] requestAuthFrom)  // ex. (hex\"10\", 4, [0x123f6..., 0x3c6ae...])   Integer Overflow First let me say that the fact that overflows are part of the EVM spec drives me crazy. I could rant all day about this, so I\u2019ll leave it at that   I suppose that it could be covered under 0x25 Out of Range, but perhaps there is a case for low-level codes to cover arithmetic errors to cover the same cases as SafeMath. I\u2019m of two minds on this one:  1. Status Codes are for Communication  Integer overflow is a bug and should never be allowed to occur in a contract. Codes are meant for communicating between contracts, or for user feedback, not debugging. It also may be a bit granular/lacks semantics. As an end user, I don\u2019t care that 0x66 Integer Overflow, I care that 0xA6 Namespace Full.  2. Overflows are Common Because of the way the EVM is designed, over- and underflows are sadly an easy mistake to make. Maybe communicating that there was an arithmetic error would have some internal utility? Translations here are better than not having them, for instance.  I\u2019ll be honest: working through the idea has pushed me back into the \u201cstatus codes are for communication\u201d camp. 0x66 Integer Overflow (or similar) isn\u2019t terribly helpful, and can probably be handled with a simple revert. A more semantically rich message would be more helpful to a user. Again, not to say that I\u2019m totally opposed to the idea, but I\u2019m just not convinced yet. I\u2019d love to hear any further thoughts that you have! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.452160493827161
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "10",
                    "likes": "0",
                    "time": "20/06/2018-17:40:28",
                    "content": " I should also mention that the implementation/helper library is moving here: https://github.com/expede/ethereum-status-codes. I will be updating the link in the EIP shortly. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alexvandesande",
                    "index": "11",
                    "likes": "0",
                    "time": "20/06/2018-18:03:39",
                    "content": "@expede I agree with your points and I take back my suggestion of subcodes and even for integer overflow (in there probably some \u201cinternal error\u201d/\u201cout of bounds\u201d would suffice) I maintain my request to have these errors:  Action not allowed / User not allowed / Not allowed yet / Not allowed anymore / Not enough balance  I understand \u201cwaiting permission\u201d as \u201cyour action was executed, we are just waiting for someone to give an ok\u201d, while \u201cnot allowed yet\u201d means \u201cyou can\u2019t do this now, please try again later\u201d. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/shrugs",
                    "index": "12",
                    "likes": "0",
                    "time": "21/06/2018-14:53:35",
                    "content": "Agreed that permission layer status codes would be useful. Primarily I think it\u2019d be really good to have them for informing users who are doing two-step transfers (where one side proposes a transfer and the other directly accepts it on-chain). Re: reason codes; awesome, sorry I didn\u2019t see that on the first read-through  I still think it would be valuable to have a registry to keep track of contract address \u2192 status code \u2192 english string just like that StatusCodeLocalization contract. 0x05.default.statuscodes.eth has a nice ring to it, and removes the need for the StatusCodeLocalization registry. The default namespace is so that we could also have alternative namespaces for contracts like 0x05.0xdeadbeef.statuscodes.eth and include those application specific error codes. Although now we need to deploy an ENS resolver, and that can get annoying pretty quickly. \u00af\\_(\u30c4)_/\u00af ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.895833333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gregc",
                    "index": "13",
                    "likes": "1",
                    "time": "22/09/2018-03:49:53",
                    "content": "A bit orthogonal, but might be relevant.   github.com/ethereum/EIPs      Issue: New  Opcode ASYNC_CALL  \t \topened by wanderer \ton 2016-06-19 \t \t \t  DESCRIPTION If block.number >= METROPOLIS_FORK_BLKNUM, then opcode 0xfa functions equivalently to a CALL, except it takes 6 arguments not including value, and...         ",
                    "links": [
                        "https://github.com/wanderer",
                        "https://github.com/ethereum/EIPs/issues/118",
                        "https://github.com/wanderer",
                        "https://github.com/ethereum/EIPs/issues/118"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal"
                    ],
                    "Sentiment": 6.34090909090909
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "14",
                    "likes": "0",
                    "time": "24/09/2018-01:22:54",
                    "content": "ASYNC_CALL is orthogonal, but totally compatible! I was very happy to see that proposal  Concurrency and asynchrony are inevitable IMO, and it\u2019s good to see progress in that direction  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "3rd party giving positive feedback on proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 7.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "15",
                    "likes": "0",
                    "time": "24/09/2018-21:45:19",
                    "content": "Unfortunately, I don\u2019t think this proposal hasn\u2019t progressed since 2016, @expede.  You\u2019d have to ask Martin whether he plans to move forward with it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving entirely negative feedback on proposal"
                    ],
                    "Sentiment": 2.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "16",
                    "likes": "1",
                    "time": "24/09/2018-22:34:52",
                    "content": "@gcolvin Okay good to know; thanks! My hands are pretty full with #erc-1066 and #erc-1444 at the moment, but I would love to champion these kinds of changes as soon as I have the bandwidth. I\u2019ll reach out to Martin  ",
                    "links": [
                        "https://ethereum-magicians.org/tag/erc-1444"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 7.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/gcolvin",
                    "index": "17",
                    "likes": "1",
                    "time": "11/10/2018-00:36:09",
                    "content": "@expede To note what little more I can remember so that I can finish forgetting it\u2026  Martin, Axic & I talked over ASYNC_CALL in Shanghai, after the discussion ended on EIP issue #118.  Our take was that under the Actor model there was no mechanism needed for contracts to wait for responses.  Rather, after an ASYNC_CALL the contract just runs to completion, and any responses come back as a ordinary message calls to the contract.  Linking up messages is an application level encoding issue.  I can\u2019t find it now, but Greg Meredith then joined the discussion online somewhere; he has a lot actual experience implementing Actor models.  He pointed out that we would need to ensure that messages got queued \u201cfairly\u201d in a precise sense.  Note that at present there is no true asynchrony; everything runs in lockstep.  That may change with sharding. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.1796875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/schemar",
                    "index": "18",
                    "likes": "0",
                    "time": "11/10/2018-08:52:37",
                    "content": "@expede great, love this EIP. Would it help to specify a whole range as application specific successes or failures? E.g. use 0xB* and 0xC* for app specific failures and successes, respectively? I am afraid that, right now, if an app needs multiple custom success or failure response codes, they could start using the currently unassigned codes, e.g. 0xA6 through 0xAC. Or even 0x16 through 0x1C  That could potentially lead to incompatibility or at least confusion if there will be official meanings assigned to these codes later on. Or for some apps 0xAA could be a success while for others it is regarded a failure. Having an \u201cofficially always empty\u201d range of success and failure codes prevents apps from requiring multiple return values (e.g. official code plus app specific code). We do not have the luxury of a response body to go into detail, like HTTP does. The drawback is that the caller only knows more specifics about the response if the caller knows the callee\u2019s custom code usage. And that it would break the neat property that, at the moment, 0x*0 always indicates a failure. (Possibly remove 0x*0 and 0x*1 from the custom code range?). Another way (taking up less codes) could be reserving 0xA6 through 0xA9 for custom failures and 0xAA through 0xAD for custom success codes. The caller could still reliably identify what\u2019s a success case and what\u2019s a failure case. Just a thought  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.20280612244898
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "19",
                    "likes": "0",
                    "time": "11/10/2018-16:40:00",
                    "content": "@schemar thanks for sharing your thoughts! Yeah, I fully agree with the spirit of what you\u2019ve written, though I think a few parts of the spec may have been missed.  Aside I have a WIP blog post(s) that I\u2019m trying to wrap up clarifying a lot of what\u2019s bellow, since people seem to jump to \u201coh this is a port of HTTP\u201d (different problem space and design), and the way the EIPs folks asked for the text to be laid out is confusing (ie: as just a list of codes, rather than as a table). I should also mention that the EIP itself is in the process of getting an overhaul (for clarity and adding a bunch of codes after gather feedback from a number of teams the past month). The aforementioned article is mostly to help clarify things for people looking to use the standard, but also to help collect thoughts for the upgrade.  Code Design  Would it help to specify a whole range as application specific successes or failures? E.g. use 0xB* and 0xC* for app specific failures and successes, respectively?  We\u2019ve designed the codes is as a 2D grid, so it\u2019s easy to parse out the category and reason, so it\u2019s better for programmatic reasoning and developer experience (only have to memorize what 32 numbers mean, not 256). This is much more structured than HTTP, where you have random stuff in each range  that could potentially lead to incompatibility or at least confusion if there will be official meanings assigned to these codes later on. Or for some apps 0xAA could be a success while for others it is regarded a failure. [\u2026] prevents apps from requiring multiple return values (e.g. official code plus app specific code)  Indeed, and this is what we\u2019re seeking to avoid in the spec! The app-specific range still adheres to the same reasons (the rows in the grid) as the rest of the spec. If used correctly, there should be no ambiguity about what each code means at a high level For example, making 0xA0 mean \u201csuccess\u201d is not following the spec. 0xA0 must mean \u201capplication-specific failure\u201d, 0xAF must mean \u201capplication-specific metadata\u201d, and so on. This range exists only to say \u201cthis failure isn\u2019t generic, and has something to do with the specific application\u2019s special domain\u201d. It\u2019s also a way of mapping internal state-machine enums to codes. Consumers of the codes should be able to understand that this is a failure/success/metadata/etc from the lower nibble alone.  Another way (taking up less codes) could be reserving 0xA6 through 0xA9 for custom failures and 0xAA through 0xAD for custom success codes. The caller could still reliably identify what\u2019s a success case and what\u2019s a failure case.  Yeah, this is a good idea  I\u2019m not sure that it\u2019ll work with the spec as it stands, since we want those reason codes to work universally (the flip side of a more structured approach). That said, we do need to make the spec flexible, but also parsable, so there\u2019s a balance here   Just a thought   It\u2019s good feedback \u2014 thank you! I hope that some of the above clarified parts of spec that were unclear. I\u2019ll noodle on the wider ranges idea  ",
                    "links": [
                        "https://fission.codes/#code-table"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.230084325396826
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/schemar",
                    "index": "20",
                    "likes": "0",
                    "time": "11/10/2018-17:12:15",
                    "content": "Thank you @expede  The spec is clear. As a recommendation I would put \u201creserved\u201d in all unused table cells to nudge app developers away from defining custom codes in (currently) unused cells. Or make \u201cUnspecified codes are not free for arbitrary use, but rather open for further specification.\u201d much more prominent      expede:  We\u2019ve designed the codes is as a 2D grid, so it\u2019s easy to parse out the category and reason, so it\u2019s better for programmatic reasoning and developer experience (only have to memorize what 32 numbers mean, not 256). This is much more structured than HTTP, where you have random stuff in each range   Right, I understand that and I really like that approach. However, some apps will need codes that are not covered by whatever the EIP specifies. And in that case the two options are:  multiple return values (additional custom return codes) an available range of codes to use  Maybe a second return value for codes in the 0xA* range is actually the cleaner solution      expede:  It\u2019s also a way of mapping internal state-machine enums to codes.   How can the EIP guarantee that there will be a code for every enum value of the app?  For now I\u2019ll wait for the additional codes after the overhaul  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.549178004535147
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/0age",
                    "index": "21",
                    "likes": "3",
                    "time": "05/11/2018-19:20:57",
                    "content": "Hello  - great presentation on ERC-1066 at devcon, @expede! I\u2019d like to propose a group of status codes specifically tailored to token transfers in the 0x5* range (as a pretty significant proportion of transactions deal specifically in that department ). 5 is unused so far, and looks a bit like $ so seems a natural fit to me. Here\u2019s the proposal for that range:     code description     0x50 transfer failure   0x51 transfer success   0x52 insufficient balance   0x53 insufficient allowance   0x54 invalid sender   0x55 invalid receiver   0x56 invalid operator   0x57 invalid value   0x58 invalid data   0x59 invalid approval   0x5a invalid state   0x5b contract paused   0x5c funds locked   0x5d invalid issuance   0x5e invalid redemption   0x5f token meta or info    0x50 / 0x51 would be for generic success / failure, 0x52 & 0x53 for the most common failure modes in a standard ERC20 token, then 0x54 through 0x58 would signify invalid parameters in more restrictive permissioned tokens. 0x59 would show that the transfer lacks approval (above and beyond the standard allowance), and 0x5a would mean that the transfer would put the token into an impermissible state (for instance, maybe the token restricts the number of holders). 0x5b would signal that all transfers are frozen (maybe the token has been retired or migrated to a new contract) and 0x5c would mean that the particular tokens in question were frozen (e.g. there is a lock-up period for the tokens that is still in effect). 0x5d & 0x5e would be returned if the token transfer would invoke an invalid mint or burn operation, respectively, and 0x5f would signal metadata in the same vein as the rest of the specification. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.469381313131313
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/boris",
                    "index": "22",
                    "likes": "2",
                    "time": "06/11/2018-05:26:34",
                    "content": "Thanks for thinking through this work! We\u2019re just back from Prague and in SF for the final weeks of the Tachyon program we are in. @expede is especially slammed because she\u2019s also speaking in New Orleans this week! Let\u2019s organize a community call \u2013 I\u2019m proposing Nov 22nd at 8:30am PST and have filed an issue in our community repo \u2013 I suspect @thegostep & @AdamDossa have opinions that intersect with their security token work and may want to join the call. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.420454545454545
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pakaplace",
                    "index": "23",
                    "likes": "1",
                    "time": "06/11/2018-13:55:22",
                    "content": "Here\u2019s what I propose (in response to our Telegram discussion). I appreciate the depth of error codes you covered here but think a minimal implementation might be the best first step. We can leave slots in the 0x5* range open until they exist or are needed on an organic, case by case basis.     Minimal Subset- checked on canSend()      0x50 transfer failure   0x51 transfer success   0x54 invalid sender   0x55 invalid receiver   0x56 invalid operator (transfer agent)   0x5b contract paused   0x5c funds locked (lockup period)   2nd tier- can be checked by front-end instead of in canSend()    0x52 insufficient balance   0x53 insufficient allowance   3rd Tier- implementation yet to be seen    0x57 invalid value   0x58 invalid data   0x59 invalid approval   0x5a invalid state   0x5d invalid issuance   0x5e invalid redemption   0x5f token meta or info    *Note, I kept the status codes equal to your table above for easier referencing. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.46969696969697
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "24",
                    "likes": "3",
                    "time": "06/11/2018-17:50:48",
                    "content": "Hey @0age   great presentation on ERC-1066 at devcon  Yey thanks   5 is unused so far, and looks a bit like $ so seems a natural fit to me.  To me as well  The 5 = $ is in fact the visual metaphor that I\u2019m using in my working designs, too. They\u2019re currently in a notebook and on sticky notes on a wall.   but think a minimal implementation might be the best first step  I agree with @pakaplace here. We don\u2019t want to prematurely impose codes, and empty ranges are a feature not a bug. Since these need to keep forward compatibility, a bit of restraint and investment in design early on will go a long way later. It\u2019s only safe to add codes; removing them is problematic since contracts may depend on them. I do think that there\u2019s value in the codes that @0age proposed; I\u2019d be surprised if these codes need to land in the final design. However, many aren\u2019t specific to finance. For example, \u201cinvalid approval\u201d belongs in the authorization column. Since we want consistency for both DX and (autonomous) code efficiency, some of these will need to be laid out differently. I know that I mentioned this during the Devcon talk, but I truly apologize that ERC1066 v1.1 proposal isn\u2019t up yet  Our past few weeks (ie: Devcon and Tachyon) have been B-A-N-A-N-A-S, repeatedly flying intercontinentally, working on last-minute presentations, interviewing companies working with FISSION/ERC1066, possibly getting them on ETC, and so on. Automerge is also currently broken on the EIPs repo , and we\u2019re waiting for some changes like [restricted] placeholders (ie: @schemar\u2019s suggestion) to be merged. I\u2019ll try to get a WIP Google Sheet up for everyone to see the current state. I\u2019ll post to FEM when it\u2019s live. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.622564935064935
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/0age",
                    "index": "25",
                    "likes": "0",
                    "time": "06/11/2018-21:11:51",
                    "content": "Ok, leaving an empty range for forward-compatibility sounds good to me. I\u2019d say it makes the most sense to rearrange the codes a bit so that 1) the empty range is continuous, and 2) future extensions to the range, if they end up taking the form of the existing suggestions, are in a similar category as those codes at the end of the initial set. The 0x5f code is just keeping with the pattern for the rest of the top-level categories.     code description     0x50 transfer failure   0x51 transfer success   0x52 insufficient balance   0x53 insufficient allowance   0x54 transfers halted (contract paused)   0x55 funds locked (lockup period)   0x56 invalid sender   0x57 invalid receiver   0x58 invalid operator (transfer agent)   0x59    0x5a    0x5b    0x5a    0x5b    0x5c    0x5d    0x5e    0x5f token meta or info    Looking forward to discussing further on the 22nd! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.674242424242424
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AdamDossa",
                    "index": "26",
                    "likes": "1",
                    "time": "07/11/2018-12:50:10",
                    "content": "Great discussion here and on Telegram. Some comments:   \u201cinsufficient allowance\u201d vs. \u201cinvalid operator\u201d - these are somewhat similar concepts I think, the former more tied to the ERC20 approve / transferFrom and the latter more tied to the ERC777 operator semantics. Could possibly be wrapped up in a single code \u201cinvalid operator\u201d.   \u201cfunds locked\u201d - I wonder if this could be made a bit more general. Locked funds could be due to vesting, seasoning periods (e.g. 12 month lock up for Reg. D) etc\u2026 There are also restrictions at the token level (e.g. maximum number of investors or maximum volume per period). I wonder if distinguishing these two cases (restricted due to sender properties, restricted due to token properties) might be useful?   I\u2019ll def. be dialing into the community call on this - thanks @bmann for organising! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.817857142857142
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/0age",
                    "index": "27",
                    "likes": "0",
                    "time": "29/11/2018-21:24:46",
                    "content": "Sharing an example permissioned ERC20 token impementation that utilizes these status codes: https://github.com/TPL-protocol/tpl-contracts/blob/master/contracts/examples/token/ERC20/TPLERC20Permissioned.sol I also feel like 0x59 invalid balance (for representing cases where a minimum or maximum allowed balance would be exceeded) and 0x5a invalid state (for cases where the maximum number of total token holders would be exceeded or other similar errors) are common enough issues to warrant inclusion in the standard. Looking forward to the discussion on the 4th! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.645833333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Sirhill",
                    "index": "28",
                    "likes": "0",
                    "time": "06/12/2018-18:38:34",
                    "content": "Hello guys, I would be very interested to participate with your group. I am working on a similar issue with Mt Pelerin\u2019s bridge protocol (https://github.com/MtPelerin/MtPelerin-protocol) I\u2019ve also already submitted an EIP 1592 on this very specific topic. Best, ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party or author wants to collaborate on proposal"
                    ],
                    "Sentiment": 6.65625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "29",
                    "likes": "1",
                    "time": "06/12/2018-20:19:42",
                    "content": " FISSION Codes (prev \u201cESC\u201d) v1.0.0-beta Hi everyone  The past few months have been filled with interviewing around two dozen companies and projects, soliciting general feedback form the community, and exploring alternative code layouts. We had a community call earlier this week, and it\u2019s been great to see the interest both on and beyond Ethereum  One version that seemed promising at first was adding more structure: encoding the referent plus modal & temporal logics. This turned out to be too rigid, so we fell back to using the lowest bit to signify blocking/non-blocking, which is in the current proposal.  Fun Facts  Now have more codes than HTTP Nearly two dozen projects interviewed for research Used by at at least three other ERCs (at least one more being announced by a partner soon) Four FISSION presentations (so far)   Why the major version bump? As mentioned above, we propose moving a few of the rows to make even numbers \u201cblocking / others have control\u201d and odds \u201cunblocking / you have control\u201d. If there is strong opinion that this should not be the case, it is easily undone.  What\u2019s New?  Columns  0x1* Permission & CONTROL  This column already contained permissions. A prior working design included a column for \u201cstoplight\u201d style transitions. We realized that this is really a type of permission (ie: permission to proceed), and merged it into this column. Some examples:  0x10 Disallowed or STOP 0x11 Allowed or GO   0x3* Negotiation & GOVERNANCE  Negotiation has been expanded to include decision making and governance, which have lot of overlap. Some examples:  0x30 Sender Disagreed or NAY 0x31 Sender Agrees or YEA 0x34 Quorum Not Reached   0x4* Availability & Time  Simply expanded to include new rows (see below) Some examples:  0x42 Paused 0x43 Queued 0x48 Already Complete   Rows  0x*4 Lower Limit  Includes items like:  0x24 Underflow 0x54 Insufficient Funds 0xE4 Untrusted/Unsigned   0x*6 Upper Limit  Includes items like:  0x16 Revoked 0x26 Overflow 0x46 Expired   0x*8 Unnecessary or Duplicate  Includes items like:  0x28 Conflict or Duplicate Entry 0x48 Duplicate Request / Already Complete 0x58 Funds Not Required   Feedback? We\u2019d love any feedback that the community has before we make a PR against the EIPs repo    docs.google.com    FISSION v1.0.0-beta v1.0.0  0x0*,0x1*,0x2*,0x3*,0x4*,0x5*,0x6*,0x7*,0x8*,0x9*,0xA*,0xB*,0xC*,0xD*,0xE*,0xF* General,Permission & Control,Find, Inequalities & Range,Negotiation & Governance,Availability & Time,Tokens & Finance,Application-Specific,Encryption, Identity &...      ",
                    "links": [
                        "https://docs.google.com/spreadsheets/d/1qS_oG8t7XMUSddsLQiec0cbb0tKO7wsTuWNh9BORATs/edit?usp=sharing",
                        "https://docs.google.com/spreadsheets/d/1qS_oG8t7XMUSddsLQiec0cbb0tKO7wsTuWNh9BORATs/edit",
                        "https://docs.google.com/spreadsheets/d/1qS_oG8t7XMUSddsLQiec0cbb0tKO7wsTuWNh9BORATs/edit",
                        "https://docs.google.com/spreadsheets/d/1qS_oG8t7XMUSddsLQiec0cbb0tKO7wsTuWNh9BORATs/edit"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.592190285204991
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "30",
                    "likes": "1",
                    "time": "06/12/2018-20:51:42",
                    "content": "We spoke about this on the call, but I wanted to put it in the thread for the broader community.     v1.0.0-beta Code v1.0.0-beta Description 0age\u2019s Description     0x50 Transfer Failed transfer failure   0x51 Transfer successful transfer success   0x54 Insufficient funds insufficient balance   0x24 Below Ok Range insufficient allowance   0x42 Paused transfers halted (contract paused)   0x53 Hold or escrow funds locked (lockup period)   0x10 Disallowed invalid sender   0x10 Disallowed invalid receiver   0x10 Disallowed invalid operator (transfer agent)   0x5f Token or financial info token meta or info    The really challenging ones here are the ones that refer to a specific role in the flow (sender/receiver/operator). I really tried to get these to work with absolute and relative roles, but it doesn\u2019t fit well into the current design philosophy. I\u2019m open to options to get these to work, but here are two rough-but-workable solutions in the meantime:  Use application-specific ranges Have your protocol or other ERC include rider information:  returns (byte statusCode, address subject) //... return (hex\"10\", msg.sender) // specific operator not okay, taken programatically return (hex\"10\", receiverAddress) // specific user not authed return (hex\"10\", this) // this contract not authed  This pattern is applicable elsewhere, too returns (byte statusCode, address subject) //...  return (hex\"26\", tokenHolder) // holder has hit the max allowed balance for this token  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.33125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/tjayrush",
                    "index": "31",
                    "likes": "0",
                    "time": "10/12/2018-17:47:54",
                    "content": "When a Solidity function returns a boolean, the returned data is padded to an even 32-byte boundary: 0x0000000000000000000000000000000000000000000000000000000000000001. I presume there was some sort of engineering decision taken by the designers of the RPC to pad the data so drastically. (My guess is that it had something to do with performance. I can\u2019t think of any other reason other than perhaps laziness). Does anyone know why that choice was made? The reason I\u2019m asking is that this proposal (which inserts a one-byte value at the start of the returned output) may (for all we know) step on that engineering decision. If this proposal takes hold, every previously 32-byte (or 32-byte aligned) return would be off by one byte at the start. Does anyone know (or has anyone studied) the effect of this, if it becomes widely adopted, on overall system performance or efficiency? (Maybe it kicks something out of some hardware cache, or it causes Solidity compiler to generate horribly inefficient code \u2013 no-one knows and that\u2019s the point.) I recently started this discussion (Small suggested change to EIP 1), in the hopes that EIP authors would try to think about the effect of their proposal system-wide. I\u2019m not sure this EIP does or doesn\u2019t have system-wide effects, but it should be discussed. Thoughts? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 3.8796296296296298
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "32",
                    "likes": "0",
                    "time": "18/12/2018-02:13:41",
                    "content": "Hmm, you\u2019re right to ask  I would be very surprised if this caused issues. It\u2019s something that you can do right now, with no changes to the VM. For performance, EVM-native 32-byte numbers typically take more to emulate than single bytes, and thus should (in my WIP EVM implementation at least) be easy to emulate. My best guess about why that happens is that numbers on the stack will are padded to 32-bytes, but don\u2019t know of any concrete reason. @fubuloubu any ideas? Perhaps you could illuminate how Vyper behaves for bools? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 6.123333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jacqueswww",
                    "index": "33",
                    "likes": "3",
                    "time": "18/12/2018-03:44:49",
                    "content": "@tjayrush @expede So the reason why it gets encoded as 0x0\u20261 (len=32) is because of the ABI encoding. Everything on the ABI uses a 32byte boundary - because of the 32byte \u201cstack-word\u201d.  Going sub-32 byte gets really inefficient gas wise (in memory, gains are to be had when storing again). ERC-1066 as I read it is layered on top of the ABI spec. So looking at ERC-1066 spec briefly the abi would return bytes1  which on the binary level is the same as 1 word \\ bytes32.  So if one wanted on could easily add 31 bytes more of status codes in for the same cost  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.458333333333332
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "34",
                    "likes": "0",
                    "time": "10/01/2019-18:29:03",
                    "content": "Updated the EIP repo\u2019s copy of ERC-1066 to include the v1.0.0 codes  Next steps:  Update fission-suite/fission-codes JS & Solidity helper libraries Min 3 reusable example contracts that use v1.0.0 Set EIP to Last Call  2 week clock starts    ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Cornelius",
                    "index": "35",
                    "likes": "1",
                    "time": "15/01/2019-08:53:58",
                    "content": "Great work with this @expede and a great presentation on status codes at Devcon also. It would be great if you could illustrate the revert-with-reason with an example also. I\u2019ve looked at the examples at https://github.com/Finhaven/EthereumStatusCodes/tree/master/contracts/examples and at the https://eips.ethereum.org/EIPS/eip-1066 page, but didn\u2019t find a revert-with-reason example. If one would revert-with-reason would you just revert with the status code or would you also be able to add an additional message? ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-1066"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 8.625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "36",
                    "likes": "0",
                    "time": "25/01/2019-10:24:41",
                    "content": "The Solidity & JS libs just hit v1.0.0-RC1     github.com    fission-suite/fission-codes Status codes for smart contracts powering microservices for Web3      ",
                    "links": [
                        "https://github.com/fission-suite/fission-codes"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party advertising proposal"
                    ],
                    "Sentiment": 6.071428571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "37",
                    "likes": "1",
                    "time": "25/01/2019-10:31:38",
                    "content": "Ooh, the Finhaven lib is pretty out of date! The current repo has its own GitHub org: Fission \u00b7 GitHub On the current version of the helper lib, you have the ability to hand it an #erc-1444 localization directly for the require helpers. Both of these should work today: // Hardcoded Message requireOk(someCode, \"something went wrong!\");  // Using an ERC-1444 automated localization based on the specific code requireOk(someCode, Localization(0xabcdef));  I\u2019m actively working on getting the singleton language registry set up, which can then get hardcoded into the lib. The above would then look like: // Fully automatic translated message requireOk(someCode);  \u2026and it would just work, message and all  I hope that helps! ",
                    "links": [
                        "https://ethereum-magicians.org/tag/erc-1444",
                        "https://github.com/fission-suite/fission-codes/blob/master/contracts/FISSION.sol#L384-L410"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.141203703703704
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "38",
                    "likes": "0",
                    "time": "11/02/2019-14:41:51",
                    "content": "Please set a discussion end date   Ethereum Improvement Proposals   Status Codes Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.      reference https://eips.ethereum.org/EIPS/eip-1 This should be a full 14 days after the date which the discussion end date is added. ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-1066",
                        "https://eips.ethereum.org/EIPS/eip-1"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "39",
                    "likes": "0",
                    "time": "11/02/2019-16:30:44",
                    "content": "Ooh thanks for pointing that out! Will do right now  UPDATE Add review end date to EIP-1066 by expede \u00b7 Pull Request #1748 \u00b7 ethereum/EIPs \u00b7 GitHub ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.3392857142857135
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "40",
                    "likes": "4",
                    "time": "11/02/2019-17:08:57",
                    "content": " ERC-1066 Now in Last Call   The review ends on Monday, February 25, 2019. I would love to hear any final thoughts or discussion prior to it making it to Final. Thanks to everyone for the interest and feedback so far    Ethereum Improvement Proposals   All | Ethereum Improvement Proposals Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.      ",
                    "links": [
                        "https://eips.ethereum.org/all"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback"
                    ],
                    "Sentiment": 5.571428571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "41",
                    "likes": "1",
                    "time": "25/02/2019-18:38:40",
                    "content": "Here is my brief review of EIP-1066. I have not reviewed everything but a few items stand out. First are notes about the standardization. Standardization is premature No existing implementations are deployed. Nor are similar deployments cited that show a demand for these features. Therefore it is impossible to know if this EIP provides any value. Reasons are not motivated No documentation is shown to explain why these codes were chosen. Nibbles I recommend encouraging (SHOULD not MUST) people to use two-nibble returns hex\"01\" in all cases to promote clarity.  Here are more opinions on the topic itself. It is wasteful in the default case This ads one word of output for function calls to return a SUCCESS status code. Competing proposals do not require this extra cost. The cost of including an extra output word is not explained or experimented in this EIP. Another proposal returns status and other outputs during a revert. It is not backwards compatible Adding an additional function return makes this incompatible with every existing contract and other standard, including ERC-20 and ERC-721. It is unsafe We learned from ERC-20 that returning (rather than reverting) from a \u201cfailed\u201d function call is dangerous. Citation --> https://twitter.com/eth_classic/status/971030641406980096 Stronger motivation should be provided to rewrite this history with a new narrative. The async DEX examples are not realistic A DEX will not implement in this way. Codes are ill-defined Should I return 0xE1 Decrypt Success or 0x01 Success or 0x21 Found? If there are so many new codes being introduced, they should have well-defined meanings, including motivations. In other words, this EIP is basically proposing 100 different mini standards so I am expecting the rationale to be an order of magnitude longer than other EIPs I\u2019ve read.  In all, this is a noble effort. And I think it is close to a good solution. Here\u2019s my overall recommendation and a path forward. Recommendation As is, two issues are show stoppers for me:  Unsafeness on returning when a function fails This ERC is not backwards compatible with any existing contract or standard  Therefore I do not recommend anybody to use this EIP as-is. BUT With one quick modification, this can be easily addressed\u2026 Please consider to update this proposal to only use status codes through reverts. AND that makes it compatible with another proposal \u2014 https://github.com/ethereum/EIPs/issues/838#issuecomment-462363456 The result is efficient, backwards compatible and allows very semantic use. Also, feel free to reach out to me directly. ",
                    "links": [
                        "https://github.com/ethereum/EIPs/issues/838#issuecomment-462363456"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.399908172635445
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "42",
                    "likes": "0",
                    "time": "25/02/2019-21:15:09",
                    "content": "Thanks for the mini-review! Yes, these are the things we hear, explain to folks that it\u2019s a paradigm shift, and they tend to go \u201coh, yeah that actually makes a lot of sense.\u201d I\u2019m not totally sure how to more get it across in text, so I\u2019m very open to suggestions. Anyhow, in the meantime our standard short rebuttals are below:  In all, this is a noble effort. And I think it is close to a good solution.  Thanks!  No documentation is shown to explain why these codes were chosen.  Fair! You\u2019re right that it should be right in the proposal itself. I\u2019ll copy paste a bunch from the Medium post and the notes from when we did those several dozen company interviews. Thanks   No existing implementations are deployed  In fact, some contracts are already using this (typically in the the security token world). The ERC1400 Security Token proposal depends on it and we have had discussions with folks looking to use it for blockchain identity use cases, as well.  Nibbles I recommend encouraging ( SHOULD not MUST ) people to use two-nibble returns hex\"01\" in all cases to promote clarity.  I\u2019m confused. In all cases, they\u2019ll get cast to two nibbles, even if the first nibble is 0, since you can only work with full bytes. Am I misunderstanding something?  It is wasteful in the default case  Yes, but in what way was it successful? This is important information for many use cases that involve automation. Was it successful accepted but will be run later when quorum is reached? Did the transfer go through now? There are lots of cases here.  Adding an additional function return makes this incompatible with every existing contract and other standard, including ERC-20 and ERC-721.  Good news! You don\u2019t need to change those contracts to wrap them in an interface (in a proxy contract), effectively giving backwards compatibility for those that already rely on ERC20 or ERC721, but giving a separate interface for others. Future contracts can make use of this functionality. But I should emphasize that this proposal was created to solve problems that we were having when developing security tokens, and enables new use cases that are currently difficult to do interoperatively on Ethereum. Calling ERC20s and NFTs directly as is most commonly done today (largely because of how difficult it is to communicate between contracts autonomously) is not an amazing use case to show off this design pattern.  It is unsafe  As per the EIP, this is in no way a replacement for revert! Exceptional, state-breaking, or dangerous cases should absolutely 100% revert! In fact, the library provides helper functions to aid with a number of revert scenarios!  The async DEX examples are not realistic  Yes, it\u2019s true that today\u2019s DEXes aren\u2019t very smart. They could be smarter and more autonomous by using such a standard, but still IMO doing one on-chain is impractical for most scenarios. And fair, it\u2019s not the greatest use case, but it\u2019s short, and people in the ecosystem understand token-related flows today. Essentially it\u2019s a toy example for illustrating how codes can flow through a system, as per HTTP or BEAM. If you can think of a better example that\u2019s widely understandable to an audience with experience limited to Solidity and JS (and that shockingly often doesn\u2019t fully understand HTTP), I would love to include it!  Codes are ill-defined Should I return 0xE1 Decrypt Success or 0x01 Success or 0x21 Found?  I mean, it depends on your use case. If you decrypted something, you should use 0xE1, if you looked something up in a table or found something you should use 0x21, and if you want straight dumb compatibility with bools you should use 0x01. HTTP Status Codes have a similar range of more specific codes to help in control flow.  They should have well-defined meanings, including motivations  These are all taken from real-world scenarios from interviews that we did with Ethereum companies, so there are motivations for every code (some cases joined or abstracted), even if they\u2019re not all spelled out. As always with code, we think more documentation and use cases will be useful.  Please consider to update this proposal to only use status codes through reverts.  Evidently the paradigm and purpose of this document is not clear enough at the moment, for which I apologize. I do wonder if people come to this EIP with preexisting assumptions, since (as mentioned before) when I spell it out in detail that \u201cno it doesn\u2019t work like that and isn\u2019t written in that way anywhere\u201d, a light bulb goes off for a lot of people. It\u2019s purpose is to give more semantic information to other contracts, developers, and users, in an automated way, in a similar vein to HTTP status codes. It is not about propagating exceptions: it\u2019s about sending context around for both success and failure, and true errors/exceptional cases should promptly exist this flow and revert. I\u2019ll give you a simple illustrative real-world example for status codes: You need to check if someone is 1/n whitelists maintained by several parties. This is key in regulated scenarios, so that not every token has to (for example) check everyone\u2019s photo ID separately, which is time consuming, expensive, and error prone, and does not easily work across borders without multiple domain experts handling this per-domicile. Since you need to check several of these lists, you need to not revert if it fails, and it\u2019s not an irrecoverable error, it\u2019s a normal part of flow (chances are that you\u2019ll need to check several of these lists). You may not be allowed to read from this list (a closed list), the user being checked may be actively blacklisted, they may not be on that list, or their verification has started off-chain (someone is reviewing their passport) but hasn\u2019t completed. If you need 2/3 to succeed, and 2 have blocking codes (ie: even numbered codes), then you should revert. Likewise, if there is an overflow, it should also revert.  AND that makes it compatible with another proposal \u2014 EIP 838: ABI specification for REVERT reason string \u00b7 Issue #838 \u00b7 ethereum/EIPs \u00b7 GitHub  As per the EIP text, this is already fully compatible with revert-with-reason, and the helper lib provides ways of bridging the two with a nice, semantic interface.  Thanks again for the review  Looking forward to further feedback on the above responses!  Relevant Resources  Devcon IV Presentation A Vision of FISSION Project Website Mini Explainer Helper Lib  ",
                    "links": [
                        "https://slideslive.ch/38911936/erc1066-better-ux-dx-in-just-one-byte",
                        "https://medium.com/spadebuilders/vision-of-fission-b4f9e00c6cb3",
                        "https://fission.codes/",
                        "https://fission.codes/post/ethereum-status-codes",
                        "https://github.com/fission-suite/fission-codes"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.69759056732741
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "43",
                    "likes": "0",
                    "time": "26/02/2019-00:00:14",
                    "content": "Regarding wasteful. \u201cIn what way was it successful\u201d? This will /always/ depend on the application. If a function casts a vote that is effective later when a quorum is reached then that is something that should be documented and already understood by the caller. When I cast I vote I expect that to work like a vote. When I transfer a token I expect the token to be transferred. \u201cWaiting for a quorum to be achieved\u201d is a ridiculous outcome for a standard, generic token transfer. It might be cool for a DAO action, but again that is application-specific. Regarding upgrades. Please explain how to make a proxy for the existing CryptoKitties contract to add this feature using less than $100,000 of gas. Regarding revert with reason. The abstract says \u201cThey are fully compatible with both  revert  and  revert -with-reason.\u201d This conflicts with the specification \u201cCodes are returned either on their own, or as the first value of a multiple return\u201d since the specification only relates to returns, not reverts. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.583333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "44",
                    "likes": "0",
                    "time": "26/02/2019-01:53:59",
                    "content": " since the specification only relates to returns, not reverts.  Yes, because this spec isn\u2019t about the exceptional cases, it\u2019s about the rest. It doesn\u2019t preclude reverts, and the information gleaned from a code can be used in a revert. As an example: require(someCheck(msg.sender) == 0x41, localize(0x41));  Or with the helper lib pragma solidity ^0.5.0;  import { FISSION } from \"fission-codes/contracts/FISSION.sol\"; import { SimpleAuth } from \"./SimpleAuth.sol\";  contract Portfolio {     SimpleAuth private auth;     mapping (address => bool) private holdings;      constructor (SimpleAuth control) public {         auth = control;     }      function isHeld(address token) external view returns (byte status, bool held) {         byte permission = auth.min(SimpleAuth.Level.Unregistered);         if (FISSION.isBlocking(permission)) { return (permission, false); }         return (FISSION.code(FISSION.Status.Found_Equal_InRange), holdings[token]);     }      function setTracking(address token, bool track) external returns (byte status) {         FISSION.requireSuccess(auth.min(SimpleAuth.Level.Member));         holdings[token] = track;         return FISSION.code(FISSION.Status.Success);     } }  I\u2019ll add this as an example to the spec. Thanks for raising that!  Regarding upgrades. Please explain how to make a proxy for the existing CryptoKitties contract to add this feature using less than $100,000 of gas.  I see why you\u2019re confused; not proxy but rather adapter. You create a contract that calls out to regaulr CryptoKitties, and returns the value plus some status code. The extra 700 gas from a  CALL isn\u2019t going to break the bank.  This will /always/ depend on the application.  I sympathize with this position! People should be application-specific enums and returning them along with their data. The problem is that there are a lot of contracts and downstream stanards out there that are looking for a high level of genericity and/or can benefit from helper libraries, collaborator contracts, and so on. These codes are indeed intentionally designed to handle common use cases, no all use cases.  \u201cWaiting for a quorum to be achieved\u201d is a ridiculous outcome for a standard, generic token transfer  For a bog-standard OZ ERC20? Of course I agree with you. Again, that\u2019s not really what this enables. For a permissioned or multisig wallet this is a totally valid return! At the end of the day, most use cases fall into a handful of categories. Why make these contracts pluggable to a large number of producers and consumers of these messages that can\u2019t know about your specific contract beforehand? I agree that this is not how things are done today: we\u2019re stuck writing bespoke applications that don\u2019t interoperate with each other, and live in isolation. If you start to see the blockchain as a web of autonomous actors rather than one-off single-call programs, we start to need some way of communicating more generically. Does that help? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.19275308025308
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fulldecent",
                    "index": "45",
                    "likes": "0",
                    "time": "28/02/2019-05:06:02",
                    "content": "Here is the balance of my notes before.  Standardization is premature Still, no existing implementations are deployed to mainnet. That makes it premature to standardize anything.  Reasons are not motivated  Documentation will be or has been added.  Nibbles I was just recommending against short form. It will be more clear if all references to Success use the form 0x01 or hex\"01\" (pick one). This consistency can improve clarity.  It is wasteful in the default case I still have yet to see any single instance where it would be helpful, in a general sense, to know that a call to castVote has the resulting status APP_SPECIFIC_SUCCESS rather than simply SUCCESS . EVM already has a mechanism for showing successful outcomes and the default successful outcome already indicates that the function did what it advertises to do. I have not seen any counter point here yet. This proposal would be great as a way to return semantic information during a revert (i.e. throw values instead of return values). I cited a comment that implements throw values. This would be a welcome paradigm shift.  It is not backwards compatible It is claimed that an existing deployed ERC-721 could use an \u201cadapter\u201d to implement transfers using ERC-1066 DRAFT status codes with an additional 700 gas. But I have yet to see how. I assert that this would require ~$100,000 worth of gas to implement just for the CryptoKitties contract.  It is unsafe I disagree with the statement in the text:  The current state of the art is to \u2026 return a Boolean pass/fail status  My understanding is that current state of the art is to revert on failure. Also the statement:  Exceptional, state-breaking, or dangerous cases SHOULD revert!  Could be included in the EIP for clarity.  The async DEX examples are not realistic  We agree this example is not a good use case. Realistic and useful use cases should be included in the specification. If only contrived examples can be provided then the value of the document is limited. If a standard will be passed, the examples should be both conceivable and also deployed on mainnet.  Codes are ill-defined Regarding successful outcomes, it should not be necessary for me to choose between \u201ccompatibility with bools\u201d or other choices. The standard should have a prescriptive answer. Regarding codes for unsuccessful outcomes, I have no complaints. Again, I am a fan of using this proposal to describe unsuccessful outcomes.  Here are new notes introduced now.  The language is not strong enough Please adopt language such as RFC 2119. This will improve clarity of the proposal. Currently the specification is vague with statements such as:  Codes are returned as the first value of potentially multiple return values.  A much stronger and clearer statement would be:  A function that implements ERC-1066 MUST include a byte -typed value as the first return value and this value MUST follow the specification of the code table below.  It is currently unclear whether a contract can comply with ERC-1066 by having only some functions implement the protocol or if it is necessary for every function to implement the protocol.  Bytes32 is contradictory The document states:  byte is quite lightweight, and can be easily packed with multiple codes into a bytes32 (or similar) if desired. It is also easily interoperable with uint8 , cast from enum s, and so on.  but later contradicts (using incorrect math, 4\u226032):  Packing multiple codes into a single bytes32 is nice in theory, but poses additional challenges. Unused space may be interpeted as 0x00 Failure , you can only efficiently pack four codes at once, and there is a challenge in ensuring that code combinations are sensible. Forcing four codes into a packed representation encourages multiple status codes to be returned, which is often more information than strictly nessesary. This can lead to paradoxical results (ex 0x00 and 0x01 together), or greater resorces allocated to interpreting 2564 (4.3 billion) permutations.  Also, the example implementation does not follow this specification. This document badly needs to use RFC 2119. At current, I don\u2019t know if an application using multiple status codes packed into one bytes32 would be valid under this EIP. Presumably only the code >> 31 part would be covered by the specification, but this is currently ambiguous.  The output is wasteful The proposal is rigid in limiting extensions:  Unspecified codes are not free for arbitrary use, but rather open for further specification.  but developers will be sure to demand extensions. The Ethereum contract ABI specifies that return values will use a full word. Reference: https://solidity.readthedocs.io/en/develop/abi-spec.html#examples This means the current ERC-1066 DRAFT specification (in one possible interpretation) prescribes one status byte and 31 bytes of zeros. It may be helpful to use this specification:  A compliant function MUST have the status code as the first return value The return value MUST be either byte or bytes32 type The left-most 8 bits of the value MUST use the code table. i.e. byte(code)  A function that uses bytes32 return type MAY use the right-most 248 bits (i.e. bytes32(code) & ~bytes32(byte(0xff)) ) for application-specific status messaging.  If you choose this approach, definitely check with the Solidity and Vyper teams. You want to get a committment that if a function call returns a bytes32 when you are expecting a byte will not cause a problem. That committment should be documented in the Solidity and Vyper docs and should state that the return value will be truncated in this situation. (And, per my notes above it will be better if this specification applies to throw values rather than return values.) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "None"
                    ],
                    "Sentiment": 5.484036796536796
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/decanus",
                    "index": "46",
                    "likes": "0",
                    "time": "30/03/2019-18:14:44",
                    "content": "When there is revert with reasons, as there is now. I fail to see why a smart contract should ever return a status code. Smart contracts should not care about contracts independent outside of themselves. If an error occurs execution should stop, from a security perspective this is the most responsible thing to do. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.448979591836735
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/expede",
                    "index": "47",
                    "likes": "0",
                    "time": "30/03/2019-21:11:24",
                    "content": "Hi @decanus, Thanks for your question! You may be missing some of the idea behind this EIP. Other than the EIP text (which covers a lot of this), an explainer that a lot of people find helpful is the helper library\u2019s README.     decanus:  When there is revert with reasons, as there is now. I fail to see why a smart contract should ever return a status code.   As mentioned in the spec, and in the thread above, the  concept is not to handle errors or replace revert in any way whatsoever.  They are fully compatible with both revert and revert -with-reason. ~ The ERC-1066 Abstract  If you have an actual error (as opposed to an exception), you should absolutely revert immediately. In fact, this work makes it easier to revert with a message when combined with ERC-1444 (which was split out from ERC-1066). The helper library provides several functions for exactly this.     decanus:  Smart contracts should not care about contracts independent outside of themselves   That\u2019s great if your smart contract doesn\u2019t depend on any collaborator contracts. This is possible for some, but not for many. In fact, many of the most powerful uses cases of smart contracts involve communication between them. You won\u2019t own all of the state that you need to interact with (e.g. a regulation whitelist, NFT ownership, ACLs, &c), and need to move context around the system. To do this mechanically in a generalized way, you need some kind of system of messages. Yes, a message recipient with more context about a call may want to additionally revert. You should think of this like HTTP responses. In API-driven services, you get both a payload and a status code. If you get a  202 Accepted on a request to create a resource, you can\u2019t assume that the resource exists yet (that\u2019s a 201 Created). It\u2019s also not an error since it hasn\u2019t been rejected (e.g. 422 Unprocessable Entity). You can assume that your resource may (or may not) be created at some point in the future, and either listen for a callback, or poll the collaborator. The problem space is different, which is why we have a more structured and generlizable system for statuses, but this is the general sort of thing that we\u2019re doing with this ERC. Does that help clarify? ",
                    "links": [
                        "https://github.com/fission-suite/fission-codes#powering-mircoservices-for-web3",
                        "https://eips.ethereum.org/EIPS/eip-1066"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.89347290640394
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/tjayrush",
                    "index": "48",
                    "likes": "0",
                    "time": "31/03/2019-14:37:40",
                    "content": "Are there any examples (i.e. addresses) of smart contracts that are currently using status codes? If you provide a few of them, I can use them as test cases for QuickBlocks. One on of the things I\u2019m interested in is how these status codes behave. If I understand correctly, they insert a single byte in the \u2018output\u2019 data field of a Parity trace. I\u2019d like to dig into the details of what that looks like, and will be happy to write a Medium post about what I find. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.8273809523809526
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/thecryptofruit",
                    "index": "49",
                    "likes": "2",
                    "time": "17/04/2019-05:53:13",
                    "content": "Hi @tjayrush , I\u2019ll likely be using it similar to how @0age mentioned above within the TPL protocol, i.e. returning just hex values that can be interpreted off-chain. Mind you, the proposed way of using it is making the contracts much harder to read. Take a look at https://github.com/fission-suite/fission-codes/blob/ce563bddc98d0fb42a745cb316b93213073de292/contracts/examples/AgeValidator.sol#L30 \u2026 This makes it unclear as to what the function is all about, with most of the code just about figuring out the status code \u2026 I prefer simply assigning the code, add comment and let the off-chain part figure it out from a lib and display to the user. Like:  require(_thisId != bytes32(0), hex\"20\"); //FISSION.code(FISSION.Category.Find, FISSION.Status.NotFound_Unequal_OutOfRange)   Nonetheless, I like ERC-1066 very much and am following it closely. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.4125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/tjayrush",
                    "index": "50",
                    "likes": "0",
                    "time": "19/04/2019-17:34:22",
                    "content": "@thecryptofruit Is there a deployed contract on the mainnet? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                }
            ]
        }
    ],
    "group_index": "736"
}