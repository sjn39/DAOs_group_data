{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/final-eip-5192-minimal-soulbound-nfts/9814",
            "title": "FINAL EIP-5192 - Minimal Soulbound NFTs ",
            "index": 9814,
            "category": [
                "Tokens"
            ],
            "tags": [
                "nft"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "1",
                    "likes": "3",
                    "time": "30/06/2022-22:52:32",
                    "content": "Information:  Final Specification: EIP-5192: Minimal Soulbound NFTs  Reference Implementation: https://github.com/attestate/ERC5192   PEEPanEIP #89: EIP-5192: Minimal Soulbound NFTs with Tim Daubensch\u00fctz by the Ethereum Cat Herders.  ",
                    "links": [
                        "https://github.com/attestate/ERC5192",
                        "https://www.youtube.com/watch?v=unFTcUjQE3o",
                        "https://ethereum-magicians.org/t/eip-4973-account-bound-tokens/8825/111",
                        "https://ethereum-magicians.org/t/eip-5484-consensual-soulbound-tokens/10424",
                        "https://ethereum-magicians.org/t/erc-721-subordinate/12479/8",
                        "https://ethereum-magicians.org/t/eip-5058-erc-721-lockable-standard/9201/5"
                    ],
                    "GPT-summary": "The post presents the final specification of the EIP-5192 proposal for Minimal Soulbound NFTs, along with a reference implementation. It also includes a podcast episode featuring Tim Daubensch\u00fctz discussing the proposal with the Ethereum Cat Herders. The post explains the proposal and provides resources for further information. Additionally, the podcast episode extends to the proposal by discussing it in more detail. There is no negative feedback or constructive criticism provided in the post.",
                    "GPT-proposal-categories": null,
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "3rd party or author is advertising proposal",
                        "None"
                    ],
                    "Sentiment": 4.699999999999999
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/DAYvid",
                    "index": "2",
                    "likes": "1",
                    "time": "01/07/2022-09:20:34",
                    "content": "I\u2019m really impressed by the simplicity of this EIP! It accomplishes its goal in an elegant way, and its goal is the most minimal increment of a long-term feature. Perfect! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving entirely positive feedback on proposal",
                        "3rd party extending to proposal"
                    ],
                    "Sentiment": 7.9
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/kladkogex",
                    "index": "3",
                    "likes": "0",
                    "time": "01/07/2022-12:43:53",
                    "content": "One problem with never being able to transfer the token is that you will never be able to rotate the corresponding crypto key. From this perspective it is not clear at all whether it should be an extension of a NFT. It should probably be more like a map of User_ID to public key pairs, where the UID is randomly set at creation, and you can rotate a key corresponding to a UID ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.527777777777779
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "4",
                    "likes": "2",
                    "time": "01/07/2022-13:54:49",
                    "content": "    kladkogex:  One problem with never being able to transfer the token is that you will never be able to rotate the corresponding crypto key.   This is out of scope, has been extensively discussed in EIP-4973 and frankly it is wrong. The standard doesn\u2019t require the token holder account to be an EOA. An account can be represented by a contract. We\u2019re all responsible users and lecturing people what not to do is IMO not the role of the EIP process/document. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/aram",
                    "index": "5",
                    "likes": "1",
                    "time": "03/07/2022-19:24:02",
                    "content": "@TimDaub I read various posts, discussions and documents, and really appreciate your (and ra-phael and MicahZoltu\u2019s) efforts around this topic. With the idea of trying to start with a minimal first-step, I was wondering how about introduce a very simple function (and therefore an interface) that checks transferability (or boundedness) of a token? function locked(uint256 tokenId) external view returns (bool)  This will allow wallets to check for transferability for UX, allows implementers more freedom around mint/burn and maybe even allowing transfers in certain situations. Lastly the supportsInterface() will have a more meaningful role when it says that it supports transferability/boundedness checks. If you think this is a different can of worms I can move this suggestion somewhere else. Let me know what are your thoughts, as you\u2019ve been working on this for quiet a while  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.7559523809523805
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "6",
                    "likes": "0",
                    "time": "09/07/2022-10:09:14",
                    "content": "yeah, @aram I think this is a good idea as it\u2019ll still allow someone to inseparably bind a token to an account, but leave that choice to the user (which IMO should ultimately have the freedom of decision). The effect is that it can shut up the nay-sayers arguing for better key rotation practices in SBTs as the interface is neutral towards the concept of permanent locking. Here\u2019s what I suggest: Please send the proposed interface design change to my GitHub TimDaub/EIPs so that I can propose it to ethereum/EIPs, thanks! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 6.45
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/walterKomarek",
                    "index": "7",
                    "likes": "0",
                    "time": "17/07/2022-19:12:32",
                    "content": "account abstract\uff0c\uff0c\uff0c\uff0c\uff0c\uff0c\uff0c\uff0c\uff0c ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "8",
                    "likes": "1",
                    "time": "26/07/2022-14:45:05",
                    "content": "    aram:  function locked(uint256 tokenId) external view returns (bool)   Implemented in Add EIP-5192 - Minimal Soulbound NFTs by TimDaub \u00b7 Pull Request #5192 \u00b7 ethereum/EIPs \u00b7 GitHub thanks for making this suggestion. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.166666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/aram",
                    "index": "9",
                    "likes": "0",
                    "time": "26/07/2022-17:13:47",
                    "content": "Sounds great @TimDaub, sorry that I didn\u2019t make the PR earlier, pretty was busy with project work  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.6499999999999995
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "10",
                    "likes": "0",
                    "time": "01/08/2022-10:33:27",
                    "content": "EIP-5192: Minimal Soulbound NFTs was accepted today and is now available at https://eips.ethereum.org/EIPS/eip-5192 ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "11",
                    "likes": "0",
                    "time": "28/08/2022-10:38:23",
                    "content": "Attempting to move to \u201cLast Call\u201d: Move to Last Call by TimDaub \u00b7 Pull Request #5549 \u00b7 ethereum/EIPs \u00b7 GitHub ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "12",
                    "likes": "0",
                    "time": "29/08/2022-15:28:22",
                    "content": "last call is active until 2022-09-12: EIP-5192: Minimal Soulbound NFTs ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.611111111111112
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "13",
                    "likes": "2",
                    "time": "19/09/2022-08:35:43",
                    "content": "EIP5192 is now final. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "14",
                    "likes": "0",
                    "time": "29/09/2022-21:43:55",
                    "content": "Just to understand the compactness of using EIP-5192 in NTTs that revert on throw. With just a few lines of code, a lot can be done that can help indexers to identify Soulbound tokens. What follows is a proposed change set for an NTT contract throwing on all transferring functions that EIP-5192 was proposed to added. It\u2019s a total of 6 additions: Add first cut ERC5192 interface by TimDaub \u00b7 Pull Request #6 \u00b7 public-assembly/curation-protocol \u00b7 GitHub ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.083333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/alex-ppg",
                    "index": "15",
                    "likes": "0",
                    "time": "15/10/2022-12:50:26",
                    "content": "Hey @TimDaub, quick question on the EIP that seems to be a bit unclear even tho it has been set as \u201cFinal\u201d. With regards to _mint operations, it is clear that the Locked event should be emitted. What about _burn operations? Should they emit the Unlocked event since the NFT is no longer bound? Thanks for clarifying in advance, I believe this information should be included in the EIP itself as well. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.055555555555555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "16",
                    "likes": "0",
                    "time": "15/10/2022-14:17:37",
                    "content": "Thanks for your feedback. I agree that we missed defining lock and unlock for burn. But as burning is transferring to address(0) the token must be unlocked before a burn. But then what should happen after calling burn is out of scope as my opinion is that the token stops existing. Does that help? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/CHANCE",
                    "index": "17",
                    "likes": "2",
                    "time": "27/10/2022-18:17:39",
                    "content": "While this has been marked as Final, it is pretty odd to have a Locked and Unlocked event. It is unfortunate that this EIP did not receive the proper review and consideration before being approved. Typically, one would expect a single Lock function with data representing the state. Different events for the two are not emitted when minting and burning tokens. Simply, the data within those events are updated.     /// @dev This emits when ownership of any NFT changes by any mechanism.     ///  This event emits when NFTs are created (`from` == 0) and destroyed     ///  (`to` == 0). Exception: during contract creation, any number of NFTs     ///  may be created and assigned without emitting Transfer. At the time of     ///  any transfer, the approved address for that NFT (if any) is reset to none.     event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);  Now, to emit an event, devs have two options, and users have one: Developers:  Use an if statement that wastes gas Bifurcate function logic to work around EIP definition  Users:  Pay more in gas  The expected state of only having 1 event is echoed in EIP-5633: Composable Soulbound NFT, EIP-1155 Extension. Is there a reason as to why having two events is preferred? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.8732993197278915
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "18",
                    "likes": "0",
                    "time": "27/10/2022-18:41:47",
                    "content": "    CHANCE:  While this has been marked as Final, it is pretty odd to have a Locked and Unlocked event. It is unfortunate that this EIP did not receive the proper review and consideration before being approved. Typically, one would expect a single Lock function with data representing the state.       CHANCE:  Is there a reason as to why having two events is preferred?   You might enjoy the discussion in this comment: EIP-5192: add event LockingStatusChanged(uint256 tokenId, bool status) by 0xanders \u00b7 Pull Request #5459 \u00b7 ethereum/EIPs \u00b7 GitHub We had considered using a single event and opted for two for better readability. So this was reviewed. But yeah, gas efficiency wasn\u2019t considered, as it\u2019s an implementation detail and not part of the interface. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.124458874458875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/CHANCE",
                    "index": "19",
                    "likes": "2",
                    "time": "27/10/2022-19:24:50",
                    "content": "That is unfortunate, but I appreciate the link share! This choice will severely limit adoption and make it impossible to recommend. It is less about actual financial cost as chains inevitably get cheaper daily. Still, this EIP requires spaghetti code in a sea of EIPs that swim vigorously in the opposite direction. Especially since even if someone wants to emit both events from the same function, there must be a check to determine what event to emit and if they can emit that event unless individuals are allowed to multi-emit the same duplicate event multiple times. While \u201cjust an interface\u201d it has extremely broad implementation impacts that should have been considered. Thanks for your time. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.668055555555556
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "20",
                    "likes": "6",
                    "time": "01/11/2022-18:20:47",
                    "content": "(I wrote this post in preparation for PeepAnEIP - have fun reading.)  The history of EIP-5192 - Minimal Soulbound tokens This is the story of how EIP-5192 Minimal Soulbound tokens got started and how we reached a status final on the interface definition. It\u2019s not a very long story, actually, but what\u2019s remarkable is that it starts at 2 am in the morning with me sitting on the computer hammering words into the keys. EIP-5192 is a product of quickly having to sketch out an idea as a document as a means to make my sleep more peaceful and not full of thoughts about Solidity interfaces.  Screenshot 2022-10-31 at 15.17.571336\u00d71196 85.5 KB  But the reason I\u2019ve ended up in this situation is that long before EIP-5192, I had involved myself with specifying EIP-4973 \u201cAccount-bound tokens,\u201d and so a frustration in not being able to find solutions to the community feedback I had received eventually evolved into this document for composable \u201cMinimal Soulbound tokens.\u201d  The Timeline  Screenshot 2022-10-31 at 15.14.211920\u00d71380 136 KB  Early in the year, in January, Vitalik posted their blog post titled \u201cSoulbound,\u201d and so when I visited ETHDenver to flee the German COVID-winter, I enjoyed the conversations there on Harberger taxes and what Kevin Owocki and others called non-skeuomorphic property. So even after returning, I dwelled on these thoughts, and by April fool\u2019s day, I submitted a solution for EIP issue \u201c1238\u201d (Non-transferrable tokens) that would end up being called EIP-4973 \u201cAccount-bound tokens.\u201d A month later, Weyl et al. then released the Decentralized Society, and while I had been working with clients - I\u2019m a freelancer  - on implementing EIP-4973 as badges, this brought more attention to our previous work than we could have imagined or managed to deal with.  image1517\u00d7891 62.3 KB  So to address the profound stream of user feedback we were getting for most of \u201cSoulbound summer,\u201d we huddled to produce meaningful and explanatory content on EIP-4973 regarding soul-binding, account-binding, and generally how to deal with that on a cultural, operational security, and technical level. Quite a few times, I felt like withdrawing as the requirements seemed complex and overwhelming. And during one of those frustrating days, when I was about to go to bed, I had this idea about a minimal non-transferrable token specification for SBTs: Not even to aid EIP-4973 \u201cAccount-bound tokens\u201d but rather to hedge my risk - as quantum thought and to cement these potentially divergent missions. So on August 1, 2022, I published EIP-5192 \u201cMinimal Soulbound tokens\u201d on GitHub.  The Motivation  Screenshot 2022-10-31 at 15.14.081920\u00d71376 173 KB  What had become particularly frustrating with the DeSoc publication had been that although we had directly associated ourselves with the term \u201cSoulbound tokens,\u201d our EIP-4973 hadn\u2019t been mentioned by Weyl et al.'s mega-popular paper. And so suddenly, left and right, I saw ourselves being confronted with Medium articles on how to \u201cEASILY IMPLEMENT SOULBOUND TOKENS\u201d and their content being this one message: \u201cUse EIP-721 and just revert on all transfer functions.\u201d contract NFT { //...   function transferFrom(     address _from,     address _to,     uint256 _tokenId) external payable {     revert(\"SOULBOUND\");   } }  And having worked on Account-bound tokens for four months already, I found it incredibly frustrating that the most basic composability ideas were missing from those medium tutorials. So I felt compelled to use my newly found EIP-editing skills to improve the situation, and that one night, I had the deciding idea. It would just be a particular \u201cSoulbound token\u201d EIP-165 identifier that supportsInterface(bytes4 interfaceID) would yield `true\u2019 upon. And so here\u2019s what that first iteration looked like (I had called the standard EIP-5555 as a placeholder name):  Screenshot 2022-10-31 at 15.08.211434\u00d7742 119 KB  So essentially, EIP-5192 was an EIP-165 identifier value where, e.g., EIP-721 contracts were supposed to yield true upon calling supportsInterface(bytes4 interfaceID). And that\u2019s all. We didn\u2019t specify events, and generally, when that EIP was to be implemented, a token would be permanently bound to an account.  The Problem But as I\u2019ve already mentioned in my ERC lightning talk at devcon in Bogota, the above wouldn\u2019t be truly an EIP if it wasn\u2019t heavily factoring in feedback from the community. And one such item of feedback we had been getting excessively but reasonably already in EIP-4973 was that binding tokens to accounts is considered an anti-pattern. This is because users want to reserve the freedom of key rotating their private keys, and since account abstraction isn\u2019t ready for prime time yet: So the concern for account-binding is really that, although it\u2019s potentially possible to account-bind only to contracts that enable key rotation, practically users and developers will bind to EOAs, and hence the standard must consider this in the design.  Screenshot 2022-10-31 at 15.30.011554\u00d7544 70 KB  Confidently, I can herein say that this is a real problem that needs to be addressed in the Soulbound token specifications - and there are no safe escape paths from that line of reasoning for now. I ended up accepting that, and so when being confronted with the same \u201caccount-binding\u201d rationale in EIP-5192 as in EIP-4973, I accepted its importance and gladly ended up realizing that an opinionated approach towards standardizing this concept of Soulbound tokens is anyways a better one. Here\u2019s how we solved that problem.  The Compromise So eventually, @aram fixed the specification by introducing the function locked for a uint256 tokenId and that it returns a boolean conditionally.  Screenshot 2022-10-31 at 15.29.371532\u00d7890 147 KB  And actually, while I have been fairly skeptical at first about this change - now it has been growing on me tremendously. Because I accept that standard documents cannot enforce implementation details anyways - and with that, we also have to acknowledge that, fundamentally, account-binding, soul-binding, or whatever you may wanna call it is a property of implementation and not part of the standard interface. But before I continue on this line of reasoning, I wanna reveal now the finalized version of EIP-5192 below for anyone to see:  Screenshot 2022-10-31 at 15.34.361416\u00d71434 359 KB  An overview:  Any soul-bindable EIP-721 token is now recognizable by a machine/marketplace/wallet using the EIP-165 interface function. It is subject to the implementor whether an EIP-5192 token shall be permanently bound to an account. But any other configuration is available through the unopinionated interface definition (e.g., even implementing a permanently transferrable EIP-721 token). Dynamic locking use cases, e.g., the one outlined in DeSoc with community recovery, are implementable using the events and the locked view function.   The Implementation And so that\u2019s how EIP-5192 got standardized, and just for you, the reader, to understand why I put such great focus on the document\u2019s provenance: It\u2019s because I think it\u2019s important to highlight its history to explain the design decision we took towards finalization. And then lastly, I also want to point out a first minimal implementation. Namely, a long-shot pull request I recently did for the public-assembly project. In fact, they had implemented a non-transferable token exactly in the way how medium tutorials had initially suggested - and so the entire fix was actually not that complicated. It consisted of adding the function locked but always returning true and by emitting an event Locked(...) when minting the NTT. And importing the interface. Here\u2019s the entire change in a screenshot:  Screenshot 2022-10-31 at 15.43.461202\u00d71106 155 KB  and the maintainer\u2019s feedback:  Screenshot 2022-10-31 at 15.46.221778\u00d71262 303 KB  So I personally see this as a huge win, as it means we\u2019ve gone from 0 to 1 on the specification and on the implementation. Now: It validates the NTT use case for now - and arguably, it doesn\u2019t validate the Soulbound token use cases just yet. But I feel that we have a pretty general interface that allows implementing many token-locking use cases for wallets, marketplaces, and inventory management systems. So I\u2019m excited for the future and where this specification might be headed then.  The Conclusion The conclusion is that I submitted a specification document on a whim and that the Ethereum Magicians community managed to turn it into something genuinely useful for an Ethereum community project. It\u2019s important and useful to factor in external feedback and allows open participation. While this can be scary at times through losing oversights, it pays off over the long term by creating a more credibly neutral solution. ",
                    "links": [
                        "https://ethereum-magicians.org/uploads/default/original/2X/3/3968d77eb7e0c8c5f98117bb886303d7a4552b06.jpeg",
                        "https://ethereum-magicians.org/uploads/default/original/2X/d/dfcfa90db2666cc77a86fb0b6d80424858f373ec.jpeg",
                        "https://ethereum-magicians.org/uploads/default/original/2X/f/f87cc533fd3823bedce71af40e3ad1e92ea46fd1.jpeg",
                        "https://github.com/TimDaub/EIPs/blob/c0684fdf8ddb714a23c0992602194113a22cc95f/EIPS/eip-5555.md",
                        "https://ethereum-magicians.org/uploads/default/original/2X/6/6242cc1c67511b8261347d08da238cb7e6271111.png",
                        "https://ethereum-magicians.org/uploads/default/original/2X/0/0f211f0a670411bfe331d4fc3be4bcdc595dfd54.png",
                        "https://ethereum-magicians.org/uploads/default/original/2X/2/255a659a2f420f03c195dad133634ce3367c1eb4.png",
                        "https://ethereum-magicians.org/uploads/default/original/2X/c/c98bb5bd4423ca5342f7e21a46f0e19dc88ab4a9.png",
                        "https://ethereum-magicians.org/uploads/default/original/2X/c/c6122e18cb03909a6222a10aaf18d46ddf8dc7b6.png",
                        "https://ethereum-magicians.org/uploads/default/original/2X/f/f4aa1a8ada3e44a46ad67f3242f3614dcda46d47.png"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.552735872690001
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/poojaranjan",
                    "index": "21",
                    "likes": "2",
                    "time": "14/11/2022-17:19:44",
                    "content": "Recording of  PEEPanEIP #89: EIP-5192: Minimal Soulbound NFTs with @TimDaub      ",
                    "links": [
                        "https://www.youtube.com/watch?v=unFTcUjQE3o"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/YutaroNagumo",
                    "index": "22",
                    "likes": "0",
                    "time": "30/11/2022-09:08:35",
                    "content": "Is there some sample code? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "23",
                    "likes": "0",
                    "time": "30/11/2022-10:42:43",
                    "content": "yeah here FINAL EIP-5192 - Minimal Soulbound NFTs - #14 by TimDaub ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/YutaroNagumo",
                    "index": "24",
                    "likes": "1",
                    "time": "01/12/2022-05:41:24",
                    "content": "Thank you. Is this completed? I can\u2019t understand how the Lock function works. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/donnoh",
                    "index": "25",
                    "likes": "1",
                    "time": "20/12/2022-21:52:10",
                    "content": "That implementation does not follow the spec because locked doesn\u2019t throw when passing a tokenId assigned to the zero address, or am i missing something? Your code:  /*  *  EIP-5192 Functions  */ function locked(uint256 tokenId) external view returns (bool) {   return true; }   The spec:  /// @notice Returns the locking status of an Soulbound Token /// @dev SBTs assigned to zero address are considered invalid, and queries /// about them do throw. /// @param tokenId The identifier for an SBT. function locked(uint256 tokenId) external view returns (bool);   ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.9
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "26",
                    "likes": "1",
                    "time": "21/12/2022-10:37:15",
                    "content": "you are correct it should throw ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/0xTimepunk",
                    "index": "27",
                    "likes": "0",
                    "time": "06/01/2023-10:48:14",
                    "content": "I am looking for something such as this standard, but for 1155\u2019s as well. Couldn\u2019t this be achieved? Soulbound 1155\u2019s (with fungibility)? EDIT: this is the closest I have found EIP-5727: Semi-Fungible Soulbound Token - #11 by 0xTimepunk ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yuki-js",
                    "index": "28",
                    "likes": "1",
                    "time": "06/01/2023-12:33:58",
                    "content": "I submitted an EIP that is the same simple interface EIP-5192. Please take a look.    SBT implemented in ERC1155 Primordial Soup       I\u2019m going to submit an EIP so I want to discuss my idea. Here is my draft EIP.   Simple Summary UNTransferability Indicator for ERC-1155, an extension of ERC-1155 for indicating the transferability of the token   Abstract The following standard is an extension of EIP-1155. It introduces the interface for indicating whether the token is transferable or not, without regard to non-fungibility, using the feature detection functionality of EIP-165.   Motivation We propose the introduction of the UNTr\u2026     ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sullof",
                    "index": "29",
                    "likes": "0",
                    "time": "11/01/2023-01:26:49",
                    "content": "I just posted a similar solution (Minimalistic non-transferable interface - #4 by sullof) and discovered this one thanks to a comment. The issue with proposal 5192 is that it assumes that there is a specific point at which the token switches from being transferable to non-transferable. In my work in the gaming industry, while it is necessary to know if a token is locked or not, the reason for this lock is often dependent on other contracts. There is no event that switches the status of the NFT, but the NFT can be locked for various reasons such as the owner having a locked balance, only a certain number of tokens being unlocked at the same time, or the owner having to own a second specific token in order to unlock the first. In all these cases, the NFT is monitoring other contracts and determining if it is transferable or not based on their status. If we were to implement a system where the NFT switches its transferability through direct transactions in a game, it would happen dozens of times a day and would be unsustainable. I believe that the token should simply return its status without emitting any events. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.198412698412699
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "30",
                    "likes": "1",
                    "time": "11/01/2023-10:35:11",
                    "content": "Interesting, use case! If you don\u2019t want to emit events every time, it can make sense that you implement EIP-5192\u2019s function locked(), and then upon status changes, you don\u2019t emit the Locked and Unlock events. It\u2019s not ideal but at least you have partial standard support then. In that case, although you\u2019d have to notify indexers, at least all wallets etc. could check if your token was locked by calling the function locked. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.5625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sullof",
                    "index": "31",
                    "likes": "0",
                    "time": "12/01/2023-02:17:11",
                    "content": "Maybe I wrongly assumed that your proposal was requiring the emission of events at status change. It looks like it is not Add EIP-5192 - Minimal Soulbound NFTs by TimDaub \u00b7 Pull Request #5192 \u00b7 ethereum/EIPs \u00b7 GitHub Actually, if it just is interface IERC5192 {   function locked(uint256 tokenId) external view returns (bool); }  it looks good to me. I will remove mine and will support this. It will force me to find a new naming for ERC721Lockable but it is ok  ",
                    "links": [
                        "https://github.com/ndujaLabs/erc721lockable/blob/main/contracts/IERC721Lockable.sol"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving entirely positive feedback on proposal",
                        "3rd party giving constructive criticism of proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.525974025974026
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sullof",
                    "index": "32",
                    "likes": "1",
                    "time": "12/01/2023-02:25:07",
                    "content": "Never mind, I realized that was an old implementation and the new one is here  github.com/public-assembly/curation-protocol         Add first cut ERC5192 interface   public-assembly:main \u2190 TimDaub:feat/add-eip-5192              opened 09:36PM - 29 Sep 22 UTC                 TimDaub               +34 -2       - happy to add tests if this implementation is interesting to you - eip-5192 is\u2026 final so it should be safe to implement       Exchanges listen to events to update their databases. That means that OpenSea is not going to call the locked view, most likely it will assume that if no event has been emitted, the status has not changed. For this reason I suggest that the events MUST be emitted if someone implements the interface.   /// @notice Emitted when the locking status is changed to locked.   /// @dev If a token is minted and the status is locked, this event MUST be emitted.   /// @param tokenId The identifier for a token.   event Locked(uint256 tokenId);  Leaving the implementer the freedom of deciding if emitting an event or not risks to create confusion. ",
                    "links": [
                        "https://github.com/public-assembly/curation-protocol/pull/6/files",
                        "https://github.com/TimDaub",
                        "https://github.com/public-assembly/curation-protocol/pull/6/files",
                        "https://github.com/public-assembly/curation-protocol/pull/6"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.5479797979797985
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "33",
                    "likes": "0",
                    "time": "12/01/2023-11:59:47",
                    "content": "Just for confirmation, the actual valid specification is always here (and it won\u2019t change anymore because it has been marked \u201cfinal\u201d): EIP-5192: Minimal Soulbound NFTs  Exchanges listen to events to update their databases. That means that OpenSea is not going to call the locked view, most likely it will assume that if no event has been emitted, the status has not changed. For this reason I suggest that the events MUST be emitted if someone implements the interface.  Yes, sadly, true. Would you mind expanding on why sometimes emitting the Locked and Unlocked events aren\u2019t in your interest? I understand that it\u2019d increase your gas costs to emit those events. But e.g., for an indexer, I honestly see no better way than working with events and emitting them on every state change. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.75
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sullof",
                    "index": "34",
                    "likes": "1",
                    "time": "12/01/2023-17:52:41",
                    "content": "If a transaction causes a change in status, it may make sense to emit an event. In games, things are more dynamic. A token may be transferable or not depending on what happens in the game. For example, a token can only be transferred if the owner has enough rewards in the game\u2019s ERC20 token or if they also own another token. Additionally, only one token can be transferred at a time if the owner has more assets in the same family. These issues are often resolved by staking tokens in a pool and giving up ownership. However, the current trend is to allow the owner to keep ownership while locking the token in different ways. In this case, the feature that is most affected is the transferability. I believe that emitting events makes sense with Soulbound NFTs, but not with NFTs used in games or other dynamic environments. That is why I suggest a minimalistic interface that only tells the caller if the token is transferable or not, ignoring the nature of the token. In my opinion, a Soulbound token is just one example of a non-transferable token and we should not create a standard for this sub-case. Of course, this is just my opinion and I may not be correct. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.4921875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sullof",
                    "index": "35",
                    "likes": "0",
                    "time": "12/01/2023-17:57:45",
                    "content": "    TimDaub:  for an indexer, I honestly see no better way than working with events and emitting them on every state change   That is true as long as the indexer can count on the event, i.e., if the event is mandatory. However, if the standard does not require events and just exposes a view, an exchange is forced to call the view. If not all the tokens emit the events, of course, the exchange is anyway forced to call the view, but that would be a failure. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.833333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "36",
                    "likes": "0",
                    "time": "13/01/2023-11:30:01",
                    "content": " Published a proper reference implementation of ERC5192: https://github.com/attestate/ERC5192   ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sullof",
                    "index": "37",
                    "likes": "0",
                    "time": "15/01/2023-20:16:40",
                    "content": "I\u2019ve been working on a project called ERC721Lockable. The goal is to allow individuals to stake their NFTs in a pool without losing ownership of the NFTs. I created it for a specific use case in the game Everdragons2, where players can stake their dragons to earn rewards, but still maintain the ability to vote on the dragon as a governance token. I\u2019ve recently updated the project to extend IERC5192. I would appreciate your input on the project, particularly on the naming. If it makes sense for you, you can also list it as an implementation of your ERC in a scenario different than Soulbound tokens.   GitHub    GitHub - ndujaLabs/erc721lockable: A simple approach to lock NFTs without... A simple approach to lock NFTs without transferring the ownership - GitHub - ndujaLabs/erc721lockable: A simple approach to lock NFTs without transferring the ownership      ",
                    "links": [
                        "https://github.com/ndujaLabs/erc721lockable"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal"
                    ],
                    "Sentiment": 4.854166666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sullof",
                    "index": "38",
                    "likes": "0",
                    "time": "15/01/2023-23:39:05",
                    "content": "I apologize for joining this discussion at such a late stage. However, as the issue has not yet been finalized, I would like to propose a solution to the problem of lockable tokens that cannot emit events. If we were to have two separate interfaces: interface IERC5192 {   function locked(uint tokenId) external view returns(bool); }  and interface IERC5192Extended is IERC5192 {   // events MUST be emitted   event Locked(uint tokenId);   event Unlocked(uint tokenId); }  This would solve the problem at hand. A contract that cannot emit events would implement the first interface, while a contract that can do so would implement the second. The main benefit of this approach is that in the second interface, the emission of events can be made mandatory, which would resolve the dilemma faced by marketplaces (not being able to trust the events, if they \u201cshould\u201d be emitted, but may not). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.385416666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dtedesco1",
                    "index": "39",
                    "likes": "1",
                    "time": "16/01/2023-03:43:05",
                    "content": "From the EIP\u2019s Security Concerns section:  There are no security considerations related directly to the implementation of this standard. It might be worth mentioning some critical, relevant security concerns in the EIP. For instance:  The contract should have proper access controls to ensure that only authorized parties (e.g. the contract owner) can lock or unlock tokens. Care should be taken to ensure that the locking function cannot be called multiple times on the same token, as this could potentially lead to the token being permanently locked by an attacker. The contract should have a mechanism to handle emergency situations, such as a way to unlock the token in case the original owner loses access to their account. It\u2019s important to also consider the security of the EIP-165 and EIP-721 that this EIP is based on.  I get that these mostly aren\u2019t \u201cdirectly\u201d related to the functionality of the extension, but the extension only works if there\u2019s a locking function added to the NFT contract. That locking function is probably getting written at the same time as this extension is getting implemented, so it might be worth calling out the key security concerns. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.4940476190476195
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "40",
                    "likes": "0",
                    "time": "28/01/2023-13:40:28",
                    "content": "I wrote a blog post about why Lockable Tokens are needed.  \u2192 The Red Whale that Killed the Ocean DAO  redwhale-min1024\u00d71024 65.4 KB  ",
                    "links": [
                        "https://ethereum-magicians.org/uploads/default/original/2X/a/a7e5fa84eb7c99f92925453d59fefa1eb17ae25b.jpeg"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yuki-js",
                    "index": "41",
                    "likes": "0",
                    "time": "31/01/2023-13:56:56",
                    "content": "I came across a proposal to change the name, which can be found here: Update EIP-5192: Change name to \"Lockable tokens\" by TimDaub \u00b7 Pull Request #6330 \u00b7 ethereum/EIPs \u00b7 GitHub. However, I believe it would be best to have a discussion on this matter, as SBT is now a well-established term and any renaming should be done with the consensus of the community to avoid potential confusion. Please note that \u201clockable\u201d alone could refer to locking of metadata. Additionally, there is already a proposal for a similar name \u201cLockable Non-Fungible Tokens\u201d. ",
                    "links": [
                        "https://eips.ethereum.org/EIPS/eip-5058#bound-nft"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.666666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "42",
                    "likes": "0",
                    "time": "31/01/2023-16:05:59",
                    "content": "What is an SBT? I have no idea tbh. PS: I\u2019m disappointed that the eip5058 authors didn\u2019t answer my call to merge our work streams in SEPTEMBER and that they\u2019re now proposing a duplication of the work done in eip5192: EIP-5058: ERC-721 Lockable Standard - #2 by TimDaub ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 3.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yuki-js",
                    "index": "43",
                    "likes": "0",
                    "time": "31/01/2023-16:53:18",
                    "content": "Certainly, as there is no direct mention of SBT in EIP, my explanation was incorrect. I apologize. The correct term is \u201cSoulbound\u201d. I mean the notion of soulbound is already accepted by the community. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal"
                    ],
                    "Sentiment": 4.75297619047619
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yuki-js",
                    "index": "44",
                    "likes": "0",
                    "time": "03/02/2023-16:51:30",
                    "content": "I agree that \u201cMinimal soulbound NFTs\u201d is not appropriate, and the idea of SBTs should be divided into two traits: untransferability and non-fungibility, in the context of implementation. That\u2019s why I named EIP-6268 \u201cUntransferability Indicator for EIP-1155\u201d. Actually, I first wanted to rename this EIP (see the first revision). IMHO \u201cUntransferability Indicator for EIP-721\u201d has clearer meaning. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.416666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sullof",
                    "index": "45",
                    "likes": "0",
                    "time": "18/02/2023-23:11:44",
                    "content": "The goal of EIP5058 is quite different. They focus on token that can be locked, instead of being staked, with all the function that are needed to reach that goal. It is very close to the contracts I wrote for our application (GitHub - ndujaLabs/erc721lockable: A simple approach to lock NFTs without transferring the ownership), with the central difference that in my proposal is the owner of the token\u2019s contract that whitelists the contracts authorized to lock the token, while in ERP5058, the owner of a tokenID can approve any contract, exactly like we do for spending. I have to say that I like that approach because it is very general. Of course, they could have extended EIP5192, as I did in my implementation after reading this thread. The only required change is to move the function isLocked to locked. ",
                    "links": [
                        "https://github.com/ndujaLabs/erc721lockable"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving entirely positive feedback on proposal",
                        "3rd party giving constructive criticism of proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.367857142857143
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sullof",
                    "index": "46",
                    "likes": "0",
                    "time": "19/02/2023-00:52:20",
                    "content": "@TimDaub I made a PR to suggest the addition of a defaultLocked function in your proposal at  github.com/ethereum/EIPs         Improvement proposal to 5192   ethereum:master \u2190 sullof:improvement-proposal-to-5192              opened 11:56PM - 18 Feb 23 UTC                 sullof               +5 -2       I suggest to add a function `defaultLocked` to the interface, which becomes ```\u2026 // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0;  interface IERC5192 {   /// @notice Emitted when the locking status is changed to locked.   /// @param tokenId The identifier for a token.   event Locked(uint256 tokenId);    /// @notice Emitted when the locking status is changed to unlocked.   /// @param tokenId The identifier for a token.   event Unlocked(uint256 tokenId);    /// @notice Returns the locking status of an Soulbound Token   /// @dev SBTs assigned to zero address are considered invalid, and queries   /// about them do throw.   /// @param tokenId The identifier for an SBT.   function locked(uint256 tokenId) external view returns (bool);      /// @notice Returns the default locking status of an Soulbound Token   /// @dev it avoid enforcing the emission of a Locked or Unlocked event at minting   ///      It may be a `pure` function in most cases, but a view is more flexible   function defaultLocked() external view returns (bool); } ```  **Why?**  I am currently working on a security-oriented project and developing a similar interface (https://github.com/ndujaLabs/protector-protected-protocol/blob/main/contracts/interfaces/IERC721Approvable.sol). In our case, we need to control the approvability of a token. While investigating, I realized a significant problem with emitting events (such as `Locked` and `Unlocked`) is that you have to emit them each time there's a change. However, when you mint a token, it typically starts with a default value for every tokenId, so emitting events at that point would be a waste of gas. For instance, with a typical soulbound token that is not transferable and never will be, it does not make any sense to emit the event. This would cause that whoever is deploying such a token would not use ERC5192.  In this proposal, the emission of the event at minting is unnecessary because an external actor can check if the token supports ERC5192 and query a function that returns the default status if no events have been emitted.  **UPDATE** In a first commit, I was also suggesting to change the events, but I removed it later to stay focused on the central issue here.       I made it there, because here the discussion seems not very active, while in the PR the reviewers will be required to intervene, avoiding long, not very useful discussions. Here is the text of the PR I suggest to add   /// @notice Returns the default locking status of an Soulbound Token   /// @dev it avoid enforcing the emission of a Locked or Unlocked event at minting   ///      It may be a `pure` function in most cases, but a view is more flexible   function defaultLocked() external view returns (bool);  to the interface. I am currently working on a security-oriented project and developing a similar interface (protector-protected-protocol/IERC721Approvable.sol at main \u00b7 ndujaLabs/protector-protected-protocol \u00b7 GitHub). In our case, we need to control the approvability of a token. While investigating, I realized a significant problem with emitting events (such as Locked and Unlocked) is that you have to emit them each time there\u2019s a change. However, when you mint a token, it typically starts with a default value for every tokenId, so emitting events at that point would be a waste of gas. For instance, with a typical soulbound token that is not transferable and never will be, it does not make any sense to emit the event. This would cause that whoever is deploying such a token would not use ERC5192. In this proposal, the emission of the event at minting is unnecessary because an external actor can check if the token supports ERC5192 and query a function that returns the default status if no events have been emitted. ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/6522",
                        "https://github.com/sullof",
                        "https://github.com/ethereum/EIPs/pull/6522/files",
                        "https://github.com/ethereum/EIPs/pull/6522",
                        "https://github.com/ndujaLabs/protector-protected-protocol/blob/main/contracts/interfaces/IERC721Approvable.sol"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.224231786731787
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/xtools-at",
                    "index": "47",
                    "likes": "2",
                    "time": "21/02/2023-19:56:28",
                    "content": "late to the part, but i particularly liked this spec since it\u2019s quite lightweight, i appreciate simplicity  just successfully implemented it for ERC-1155 in a way that each token id can be un/locked individually, was wondering why the spec is only applicable to 721s \u201cofficially\u201d  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.05
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/TimDaub",
                    "index": "48",
                    "likes": "1",
                    "time": "22/02/2023-17:10:50",
                    "content": "I focused on specifying an addon to ERC721 only because I find it difficult to understand the entirety of the ERC1155 specification. I\u2019m familiar with ERC721 and so I decided to only specify an addon for it. But anyone is welcome to transfer the ERC-5192 logic into ERC-1155! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sullof",
                    "index": "49",
                    "likes": "0",
                    "time": "17/03/2023-06:14:41",
                    "content": "@TimDaub Following Pandapip1 suggestion (when he closed my PR on your EIP), I made an alternative proposal. I would have preferred to work with you on that, but it looks like when an EIP is in the final stage nothing can be changed.     ERC721 Lockable Proposal With Default Status Tokens       Many proposals for lockable ERC721 contracts exist in different phases of development:        and many others.  Unfortunately, any of them misses something or is too complicated and add extra functions that do not need to be part of a standard.  I tried to influence ERC-5192 making many comments and a PR that was closed by @Pandapip1 who suggested I make a new proposal. So, here we are.  interface ILockable {  // Must be emitted one time, when the contract is deployed,  // defining the default s\u2026     I would appreciate you opinion on it. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.167832167832168
                }
            ]
        }
    ],
    "group_index": "1799"
}