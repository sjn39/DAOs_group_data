{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-1153-transient-storage-opcodes/553",
            "title": "EIP-1153: Transient storage opcodes ",
            "index": 553,
            "category": [
                "EIPs",
                "Core EIPs"
            ],
            "tags": [
                "opcodes",
                "storage"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "1",
                    "likes": "2",
                    "time": "15/06/2018-23:07:46",
                    "content": "  github.com/ethereum/EIPs         Transient storage opcodes   ethereum:master \u2190 ledgerwatch:master            opened 10:56PM - 15 Jun 18 UTC               AlexeyAkhunov             +75 -0       When opening a pull request to submit a new EIP, please use the suggested templa\u2026te: https://github.com/ethereum/EIPs/blob/master/eip-X.md  We have a GitHub bot that automatically merges some PRs. It will merge yours immediately if certain criteria are met:   - The PR edits only existing draft PRs.  - The build passes.  - Your Github username or email address is listed in the 'author' header of all affected PRs, inside <triangular brackets>.  - If matching on email address, the email address is the one publicly listed on your GitHub profile.       I have written this EIP after having reviewed EIP-1087 (EIP-1087: Net gas metering for SSTORE operations) and its discussion (EIP-1087: Net storage gas metering for the EVM - #35 by Arachnid). I propose an alternative design (which Nick said he also considered at some point), which in my opinion can bring bigger benefits than EIP-1087, at lower cost (by this I mean new opcodes with very simple semantics and gas accounting rules, and keeping the existing gas accounting rules for SSTORE intact). Let me know what you think ",
                    "links": [
                        "https://github.com/ethereum/EIPs/pull/1153",
                        "https://github.com/AlexeyAkhunov",
                        "https://github.com/ethereum/EIPs/pull/1153/files",
                        "https://github.com/ethereum/EIPs/pull/1153",
                        "https://eips.ethereum.org/EIPS/eip-1087",
                        "https://ethereum-magicians.org/t/eip-1087-net-storage-gas-metering-for-the-evm/383/35",
                        "https://ethereum-magicians.org/t/extsload-opcode-proposal/2410/5",
                        "https://ethereum-magicians.org/t/account-bound-evm-memory/2270",
                        "https://ethereum-magicians.org/t/eip-5283-a-semaphore-for-parallelizable-reentrancy-protection/10236/2",
                        "https://ethereum-magicians.org/t/shanghai-cancun-candidate-eip-1153-transient-storage/10784",
                        "https://ethereum-magicians.org/t/remediations-for-eip-1283-reentrancy-bug/2434/16"
                    ],
                    "GPT-summary": "The author of the post is proposing a new EIP (Ethereum Improvement Proposal) and is asking for feedback on the proposal. The author explains that the proposal is an alternative design to EIP-1087 and can bring bigger benefits at lower cost. The post also mentions a GitHub bot that automatically merges some PRs and lists the criteria that need to be met for the bot to merge a PR. A 3rd party can give constructive criticism, ask questions, or audit and review the proposal.",
                    "GPT-proposal-categories": [
                        "Smart contract updates",
                        "Not a proposal"
                    ],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal"
                    ],
                    "Sentiment": 5.0872564935064934
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "2",
                    "likes": "0",
                    "time": "16/06/2018-01:25:29",
                    "content": "as mentioned in that other thread EIP-1087: one year ago there was a discussion between me, @chriseth and @pirapira about very similar approach. It would be great to hear their opinion. As far as I remember, there were following aspects to discuss:  Which contracts from the call stack should be allowed to access (read/write) which transient variables? Should be a new variable instance created on new recursive call (stack) or an existing instance should be reused?  one year ago we have decided to drop the transient storage EIP in favour to the idea of EIP-1087. But if we review that decision once more, we should possibly think more about signalling we would like to implement. Possibly we have more use cases than ReentranceLock here. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.061553030303031
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "3",
                    "likes": "0",
                    "time": "16/06/2018-09:39:27",
                    "content": "    Ethernian:  one year ago there was a discussion between me, @chriseth and @pirapira about very similar approach. It would be great to hear their opinion.   Thank you very much for this, I shall ask if they remember     Ethernian:   Which contracts from the call stack should be allowed to access (read/write) which transient variables?    Good question - I will need to update the EIP. The idea is that transient variables are private to the contract, in the same way the storage is     Ethernian:   Should be a new variable instance created on new recursive call (stack) or an existing instance should be reused?    If a contract gets re-entered within the same transaction, it accesses the same transient storage. Otherwise it would like existing memory, but with different addressing.     Ethernian:  Possibly we have more use cases than ReentranceLock here.   Another use case (though a bit contrived at the moment) is passing back error messages from the deeper execution frames. Again, passing them via outputs is not reliable, since intermediate frames can modify them. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.677575757575758
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/MicahZoltu",
                    "index": "4",
                    "likes": "0",
                    "time": "16/06/2018-10:01:52",
                    "content": "What happens if something writes to transient storage and then reverts?  Would the transient storage changes be rolled back or retained for the remainder of the transaction (assuming not all gas was burned during the revert)? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "5",
                    "likes": "1",
                    "time": "16/06/2018-13:20:06",
                    "content": "    MicahZoltu:  What happens if something writes to transient storage and then reverts?  Would the transient storage changes be rolled back or retained for the remainder of the transaction (assuming not all gas was burned during the revert)?   Good question! The transient storage would be retained for the remainder of the transaction. Because otherwise the two use cases I am thinking about (reentrant lock and error message passing) are harder to program. Also, semantics of not interacting with reverts and invalid instructions makes implementation simpler. I will include this clarification into the EIP ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 6.291666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "6",
                    "likes": "0",
                    "time": "18/06/2018-11:11:35",
                    "content": "As mentioned in the other thread, I think this option is less attractive because it introduces more complexity to the EVM, in the form of new opcodes, and another form of memory with new semantics. I think changing gas accounting around SSTORE/SLOAD is much simpler and more versatile. Further, a change to SSTORE/SLOAD gas accounting will reduce gas costs for contracts already using storage for transient or repeated updates. Examples include contracts using storage to implement locks, and ERC20 tokens using \u2018approve\u2019 between contracts. If transient storage is implemented instead, new standards would need to be developed to permit the use of transient storage for these purposes.  When implementing contract-proxies using DELEGATECALL, all direct arguments are relayed from the caller to the callee via the CALLDATA, leaving no room for meta-data between the proxy and the proxee. Also, the proxy must be careful about storage access to avoid collision with target storage-slots. Since transient storage would be shared, it would be possible to use transient storage to pass information between the proxy and the target.  It\u2019s not clear to me why you can\u2019t just pass the metadata along with the call data. Further, this approach would not work if you may end up with recursive calls; it\u2019s the equivalent of using global variables.  Transient storage does not interact with reverts or invalid transactions, that means if a frame reverts, its effects on the transient storage remain until the end of the transaction.  I think this is a really bad idea. Every other state change is reverted when a call reverts or throws; introducing a new semantic for this one type of storage would be counterintuitive, and creates a special case that is likely to lead to a great number of nonobvious bugs and security issues. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.573028420854508
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "7",
                    "likes": "0",
                    "time": "18/06/2018-12:27:03",
                    "content": "    Arachnid:  As mentioned in the other thread, I think this option is less attractive because it introduces more complexity to the EVM, in the form of new opcodes, and another form of memory with new semantics. I think changing gas accounting around SSTORE/SLOAD is much simpler and more versatile.   I am now trying to see if the Transient Storage is attractive enough without comparison to the SSTORE reduction proposal, which I think stands well on its own.     Arachnid:   Transient storage does not interact with reverts or invalid transactions, that means if a frame reverts, its effects on the transient storage remain until the end of the transaction.  I think this is a really bad idea. Every other state change is reverted when a call reverts or throws; introducing a new semantic for this one type of storage would be counterintuitive, and creates a special case that is likely to lead to a great number of nonobvious bugs and security issues.   Thanks for this feedback. You see, I am not very sure how this should work. But for concreteness, I choose non-revertability of the transient storage. It turns out that this non-revertability gives smart contracts a unique resource that wasn\u2019t available before (namely reliable communication from the re-enterancy frames that reverted/threw). But it could have the drawbacks you are talking about. I will try to make this more concrete with some POC. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.145113566988567
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "8",
                    "likes": "0",
                    "time": "18/06/2018-12:39:29",
                    "content": "    AlexeyAkhunov:  It turns out that this non-revertability gives smart contracts a unique resource that wasn\u2019t available before (namely reliable communication from the re-enterancy frames that reverted/threw).   You can do this with return data. What\u2019s the use-case that you have in mind that you can\u2019t use return/revert data for? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 6.648809523809524
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "9",
                    "likes": "1",
                    "time": "18/06/2018-12:42:11",
                    "content": "    Arachnid:      AlexeyAkhunov:  It turns out that this non-revertability gives smart contracts a unique resource that wasn\u2019t available before (namely reliable communication from the re-enterancy frames that reverted/threw).   You can do this with return data. What\u2019s the use-case that you have in mind that you can\u2019t use return/revert data for?   If contract A (frame 1) calls into contract B, then B calls into A again (frame 2). Frame 2 of contract A reverts, and returns some data. Frame of contract B can choose to discard, or modify the return data instead of passing it verbatim to Frame 1 of contract A. Non-revertiable transient storage would allow Frame 2 of contract A pass any info to Frame 1 of contract A regardless of what contract B is doing. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.648809523809524
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "10",
                    "likes": "0",
                    "time": "18/06/2018-12:53:43",
                    "content": "    AlexeyAkhunov:  f contract A (frame 1) calls into contract B, then B calls into A again (frame 2). Frame 2 of contract A reverts, and returns some data. Frame of contract B can choose to discard, or modify the return data instead of passing it verbatim to Frame 1 of contract A. Non-revertiable transient storage would allow Frame 2 of contract A pass any info to Frame 1 of contract A regardless of what contract B is doing.   What\u2019s an actual use-case for this, though? Where would it be useful? In general nonlocal returns are a big source of confusion and nonobvious control flow in traditional programming. I\u2019m not keen on adding them to the EVM. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.3500000000000005
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "11",
                    "likes": "0",
                    "time": "18/06/2018-13:02:44",
                    "content": "    Arachnid:      AlexeyAkhunov:  f contract A (frame 1) calls into contract B, then B calls into A again (frame 2). Frame 2 of contract A reverts, and returns some data. Frame of contract B can choose to discard, or modify the return data instead of passing it verbatim to Frame 1 of contract A. Non-revertiable transient storage would allow Frame 2 of contract A pass any info to Frame 1 of contract A regardless of what contract B is doing.   What\u2019s an actual use-case for this, though? Where would it be useful?   I do not know yet. I only discovered this two days ago, after having answered @MicahZoltu question above. I decided then not to roll back my choice, but explore it a bit more. Thanks for this discussion, BTW ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.7142857142857135
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "12",
                    "likes": "0",
                    "time": "18/06/2018-15:08:42",
                    "content": "    AlexeyAkhunov:  Non-revertiable transient storage would allow Frame 2 of contract A pass any info to Frame 1 of contract A regardless of what contract B is doing.   What is the difference between this use case and existing implementation of ReeantranceLock? You can set the lock from Frame 2 and read it Frame 1. Only the necessary lock clean up at the end? More challenging could be signalling between different frames in different contracts, but I have no good use case yet. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.635416666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "13",
                    "likes": "0",
                    "time": "18/06/2018-15:41:26",
                    "content": "    Arachnid:   When implementing contract-proxies using DELEGATECALL, all direct arguments are relayed from the caller to the callee via the CALLDATA, leaving no room for meta-data between the proxy and the proxee.  It\u2019s not clear to me why you can\u2019t just pass the metadata along with the call data.   BTW, I can recognize here another dropped proposal I have made in ethereum/solidity to support an trailing data in message call. Possibly it worth reviewing it once more. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.0625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "14",
                    "likes": "0",
                    "time": "18/06/2018-15:41:31",
                    "content": "    Ethernian:  What is the difference between this use case and existing implementation of ReeantranceLock?   You will need to point me to the existing implementation of ReentranceLock, I could not find it, sorry.     Ethernian:  You can set the lock from Frame 2 and read it Frame 1. Only the necessary lock clean up at the end?   The reentrancy lock has to be unlocked after the call regardless of whether one uses storage or transient storage. Because after the call is complete, the lock is still locked. So no change in usage here, apart from the gas cost.     Ethernian:  More challenging could be signalling between different frames in different contracts, but I have no good use case yet.   Transient Storage cannot be used directly to implement signalling between frames of different contracts. All interactions between distinct contracts can only happen via CALL and STATICCALL. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.363095238095238
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "15",
                    "likes": "0",
                    "time": "18/06/2018-15:50:28",
                    "content": " You will need to point me to the existing implementation of ReentranceLock, I could not find it, sorry.  Oh\u2026 I mean nothing special. Just a standard implementation with some further message call in the locked scope. See Contract Mutex, modifier noReentrancy     AlexeyAkhunov:  Transient Storage cannot be used directly to implement signalling between frames of different contracts.   (Even I am not sure it is good) why not? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.052579365079365
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "16",
                    "likes": "0",
                    "time": "18/06/2018-16:04:07",
                    "content": "    Ethernian:      AlexeyAkhunov:  Transient Storage cannot be used directly to implement signalling between frames of different contracts.   (Even I am not sure it is good) why not?   Because of this (from EIP)   Transient storage is private to the contract that owns it, in the same way as \u201cregular\u201d storage is. Only owning contract frames may access their transient storage.   ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.392857142857142
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "17",
                    "likes": "0",
                    "time": "18/06/2018-16:30:18",
                    "content": "    AlexeyAkhunov:  Only owning contract frames may access their transient storage.   you mean definitely: \u201cOnly owning contract frames may write- access their transient storage\u201d. What is bad with read access? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 3.7343750000000004
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "18",
                    "likes": "0",
                    "time": "18/06/2018-16:44:59",
                    "content": "    Ethernian:  you mean definitely: \u201cOnly owning contract frames may write- access their transient storage\u201d. What is bad with read access?   I see what you mean. To read from other contracts\u2019s storage, one would need to modify the TLOAD opcode to have 2 arguments, one for address of account you are reading, and the other - for the address of the \u201ccell\u201d you are reading. It might not be a bad idea, actually. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 3.5781250000000004
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "19",
                    "likes": "0",
                    "time": "18/06/2018-16:55:19",
                    "content": "    Ethernian:  you mean definitely: \u201cOnly owning contract frames may write- access their transient storage\u201d. What is bad with read access?   One use case for contracts reading other contracts transient storage could be calling libraries via CALL (STATICCALL) instead of DELEGATECALL or CALLCODE, and passing structures (like trees and linked lists) without having to serialise them into input data. Calling via CALL and STATICCALL is arguably safer, because you don\u2019t give the callee access to your storage. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 3.5781250000000004
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "20",
                    "likes": "0",
                    "time": "18/06/2018-17:21:31",
                    "content": "    AlexeyAkhunov:  To read from other contracts\u2019s storage, one would need to modify the TLOAD opcode to have 2 arguments,   I thought about usual public accessors, not about extending TLOAD opcode. Replacing accessor functions with \u201cnative\u201d read access per opcode deserves seperate EIP and cautios evalation. The idea to have a \u201cnative\u201d per-reference read-only access to data structures without serialization looks to me as a major change targeting EVM-2.0. I need to compare it to library pattern. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.609375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "21",
                    "likes": "0",
                    "time": "23/06/2018-15:20:59",
                    "content": "    AlexeyAkhunov:  To read from other contracts\u2019s storage, one would need to modify the TLOAD opcode to have 2 arguments.   How much as should the opcode execution cost? I would try to compare it with gas costs for usual message call. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.708333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "22",
                    "likes": "0",
                    "time": "23/06/2018-19:50:25",
                    "content": "    Ethernian:      AlexeyAkhunov:  To read from other contracts\u2019s storage, one would need to modify the TLOAD opcode to have 2 arguments.   How much as should the opcode execution cost? I would try to compare it with gas costs for usual message call.   I suggested 8 gas per TLOAD operation. It does not cost much more to read from other contract\u2019s transient storage. An implementation would most probably already have some kind of nested hash table (contract_address => (storage address => value)) which can be access by 2-argument TLOAD. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.928571428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Ethernian",
                    "index": "23",
                    "likes": "0",
                    "time": "11/07/2018-08:09:56",
                    "content": "Sorry for long delay, @AlexeyAkhunov. All in all I see two proposals here:  introduce transient storage and TSTORE/TLOAD opcodes. allow store reading opcodes (TLOAD, SLOAD) to read other contract\u2019s storage.  I think (2) is interesting, because it is much less expensive than usual contract reading calls - we don\u2019t need serialization/deserealization any more. It is some kind of reversing delegate call idea: we let our contract code read external storage. If we think ethereum as a storage for public data like identities or merkle trees, offered onchain for other contracts, this proposal will help a lot. It allows powerful searches even if they are implemented later in user\u2019s contract instead of in the public storage initially. Nevertheless, (2) is possible without Transient Storage at all. In case of permanent storage I am also not quite sure about 8 gas costs. Possibly we should limit an amount of other contract storages accessible by user\u2019s contract, in order to ensure all calls are hitting the cache and not a disk. Then we can keep it low. For (1) I am still unclear about meaningful distinct usecase. Technically it means that some contract should create (not load from disk!) a reasonable amount of data (more than few flags for signalling) and offer it for access to other contracts. What use case should it be? I don\u2019t know. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.363505747126437
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "24",
                    "likes": "0",
                    "time": "04/12/2018-01:05:59",
                    "content": "RETURNDATA could have leveraged this generic memory had it existed before, instead of having to put everything in a special memory that is only used for one single thing (and requires 2 instructions). Though most of us are extremely happy that they added it, it can also be argued that return data is \u201cwrong\u201d compared to adding a generic transaction-spanning memory, readable and writable through VM instructions, in a manner similar to what is proposed here. Languages could easily work around control flow and all other type of issues. Just because they can use it doesn\u2019t mean they have to. But you know all that. Solidity & EVM could just reserve the two first words for return data position and length, for example. The point is there would still only be 2 instructions, TLOAD & TSTORE, just like RETURNDATA & RETURNDATASIZE, but it can be used for a lot more. Return system could be deprecated. If the memory is different arrays mapped to addresses then maybe other transaction-spanning data could be mapped to it as well, for example, maybe CALLDATA could just be assigned to transMem[0x000\u2026000]. It would still be read-only there. Maybe taking it to far but there seem to be many potential use cases. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.738565162907268
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Arachnid",
                    "index": "25",
                    "likes": "2",
                    "time": "04/12/2018-01:28:34",
                    "content": "Bear in mind that this kind of global transient memory would make static analysis difficult or even impossible in many cases. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.361111111111111
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "26",
                    "likes": "0",
                    "time": "04/12/2018-18:04:10",
                    "content": "This is interesting. What do you think about updating the EIP to make it a map of arrays? I read some of your posts and the discussion here and in the gas netting thread and I saw that suggestion, but i will formulate it again. Basically, the key would be an ethereum address and the value a regular byte array. Informally: Map<Address, byte[]> tStorage;  Perhaps it would require a temp version too so nothing is added until it is certain there is no reverts. Instructions: TSTORE (sAddr val) - pop 'sAddr' and 'val' and set tStore(_ADDRESS_)[sAddr] = val TLOAD (accAddr, sAddr) - pop 'accAddr' and 'sAddr' and push tStore(accAddr)[sAddr]  _ADDRESS_ would be the address of the current account. Additionally there could be TCOPY or something which could work like CALLDATACOPY and CODECOPY works now, i.e. copying data from transient storage to memory. The EVM could use _ADDRESS_ = 0 for immutable data, since no account would be able to write there, and it could decide for itself what addresses to use so it doesn\u2019t overwrite anything itself. The good thing with this is that much of the EVM functionality that are now using separate instructions and storage locations could maybe be harmonized. For example, it could be used for all the things you say. It could be used for return data, and tx data - and maybe even contract-to-contract calldata. There would be difficulties, and some of this is probably not practical, but it is at least an interesting discussion. There are plenty of instructions involved in passing data around (all the CALLs, and everything CALLDATA-related, and RETURN-related), and then there are reentrancy locks and such, so maybe it can all be part of one single EIP. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.934523809523809
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "27",
                    "likes": "0",
                    "time": "04/12/2018-18:10:57",
                    "content": "The thing that makes this even worth talking about imo is that there is no good and uniform way to store data over an entire transaction execution, so everything related has to be done using things that feel like \u201chacks\u201d, like using permanent storage for non permanent data, special call, calldata and return logic, and other things. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.151785714285715
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "28",
                    "likes": "1",
                    "time": "04/12/2018-22:42:47",
                    "content": "    androlo:  there is no good and uniform way to store data over an entire transaction execution, so everything related has to be done using things that feel like \u201chacks\u201d   Yes, I suspect that when EVM was designed, one of perceived goal was maximum isolation for the sake of security. In the hindsight, that turned out to be quite restrictive, even for implementation of security-related primitives (like reentrancy locks). I think a good way to go about it is to first redesign EVM completely given what we know now about our needs, and then make a reduction back to EVM, to see what are the best modifications. It would be quite an intense process though  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.055555555555555
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "29",
                    "likes": "0",
                    "time": "05/12/2018-01:47:23",
                    "content": "Seems it\u2019s pretty complicated to do it the byte array way. At least in a programming language. \u201cstatic initialization\u201d is no problem and could just be a flag in the transient storage array (a reserved address) that is set the first time the contract code is run during a transaction, and it would be possible to use that to prepare user defined variables, but the contract storage map type seems like the only good way to actually do that efficiently. But using a map instead of an array will of course make it terrible to use for arrays like return and call-data. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.666666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "30",
                    "likes": "0",
                    "time": "05/12/2018-02:11:23",
                    "content": "If no dynamic arrays or mappings are allowed: { // start of body code      transient uint x = 5;     transient bytes bts;     transient bool b;     // tStorage     // 0x0 : static initialization     // 0x20: free mem pointer      // assembly version of what would always run when contract is called, before any functions.     if(iszero(tload(address, 0)) { // is tStorage of this contract 0 at address 0x00         tstore(0x00, 0x01) // set init flag         tstore(0x40, 0x05) // init x         // 0x60 reference to \u2018bts\u2019         // 0x80 value of b         tstore(0x20, 0x100) // update free tstore pointer     }  }  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.550000000000001
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "31",
                    "likes": "0",
                    "time": "05/12/2018-09:22:25",
                    "content": "    androlo:  Seems it\u2019s pretty complicated to do it the byte array way. At least in a programming language   Yes, compilers would need to hide this problem away, but inserting the initialisation logic you showed later. Also, to calculate the size of storage require, and perhaps issue opcode to explicitly resize the storage. Although it makes life harder for compilers, it will eventually make life easier for developers. They will be able to use libraries (finally), closely integrate with eWASM, and stop using cryptographic hash function as a cheat data structure  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "Author of proposal is explaining proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.892857142857142
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "32",
                    "likes": "0",
                    "time": "06/12/2018-01:41:48",
                    "content": "I\u2019ve implemented TLOAD/STORE as I suggested in a previous post (memory type array mapped to addresses). I modified the LLL compiler and added the instructions in at 0x5C (TLOAD) and 0x5D (TSTORE), just after JUMPDEST. This is a contract doing a \u201cstatic init\u201d type routine before running: { \t \t(def \"T_INIT_ADDR\" 0x00) \t(def \"T_COUNTER_ADDR\" 0x20)  \t(def \"tInit\" (TLOAD (ADDRESS) T_INIT_ADDR))  \t(def \"tInitW\" (val) (TSTORE T_INIT_ADDR val))  \t(def \"StaticInit\"  \t    (unless tInit { \t\t(tInitW 1) \t    }) \t) \t \tStaticInit \t \t(return tInit) }  It compiles down to this: 6000305c600c57600160005d5b6000305c60005260206000f300  (the STOP at the end is auto injected by LLLC) I also modified my own evm implementation to include the new opcodes. This is the output after running that code: { \t\"errno\": 0, \t\"errpc\": 24, \t\"returnData\": \"0000000000000000000000000000000000000000000000000000000000000001\", \t\"mem\": \"0000000000000000000000000000000000000000000000000000000000000001\", \t\"stack\": [], \t\"accounts\": [ \t\t{ \t\t\t\"address\": \"cd1722f2947def4cf144679da39c4c32bdc35681\", \t\t\t\"balance\": \"0\", \t\t\t\"nonce\": 1, \t\t\t\"code\": \"\", \t\t\t\"storage\": [], \t\t\t\"destroyed\": false \t\t}, \t\t{ \t\t\t\"address\": \"0f572e5295c57f15886f9b263e2f6d2d6c7b5ec6\", \t\t\t\"balance\": \"0\", \t\t\t\"nonce\": 0, \t\t\t\"code\": \"6000305c600c57600160005d5b6000305c60005260206000f300\", \t\t\t\"storage\": [], \t\t\t\"destroyed\": false \t\t} \t], \t\"logs\": [] }   The EVM implementation was actually not hard, since I just created TStorage by modifying a copy of the data structure I use for normal storage, using memory structs as values (instead of just 32 byte ints). This of course would not be as simple to do in an actual fully featured EVM like the one in geth or parity\u2026 Either way, I will continue to experiment a bit. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 3.4294043374925733
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "33",
                    "likes": "0",
                    "time": "06/12/2018-02:12:00",
                    "content": "Here\u2019s a more interesting example: { \t \t(def \"T_INIT_ADDR\" 0x00) \t(def \"T_COUNTER_ADDR\" 0x20)  \t(def \"tInit\" (TLOAD (ADDRESS) T_INIT_ADDR)) \t(def \"tCounter\" (TLOAD (ADDRESS) T_COUNTER_ADDR))  \t(def \"tInitW\" (val) (TSTORE T_INIT_ADDR val)) \t(def \"tCounterW\" (val) (TSTORE T_COUNTER_ADDR val))  \t(def \"StaticInit\"  \t    (unless tInit { \t\t(tInitW 0x01) \t\t(tCounterW 0x00) \t    }) \t) \t \tStaticInit  \t(unless (= tCounter 5) { \t\t(tCounterW (+ tCounter 1)) \t\t(msg (ADDRESS) 0) \t}) \t \t(return tCounter) }  Calling itself a number of times, using the static counter to keep track of how many. Output: { \t\"errno\": 0, \t\"errpc\": 76, \t\"returnData\": \"0000000000000000000000000000000000000000000000000000000000000005\", \t\"mem\": \"0000000000000000000000000000000000000000000000000000000000000005\", \t\"stack\": [], \t\"accounts\": [ \t\t{ \t\t\t\"address\": \"cd1722f2947def4cf144679da39c4c32bdc35681\", \t\t\t\"balance\": \"0\", \t\t\t\"nonce\": 1, \t\t\t\"code\": \"\", \t\t\t\"storage\": [], \t\t\t\"destroyed\": false \t\t}, \t\t{ \t\t\t\"address\": \"0f572e5295c57f15886f9b263e2f6d2d6c7b5ec6\", \t\t\t\"balance\": \"0\", \t\t\t\"nonce\": 0, \t\t\t\"code\": \"6000305c601157600160005d600060205d5b60056020305c1460405760016020305c0160205d6000600052602060006020600060003060155a03f150600051505b6020305c60005260206000f300\", \t\t\t\"storage\": [], \t\t\t\"destroyed\": false \t\t} \t], \t\"logs\": [] }   I haven\u2019t added in any revert protection yet but that won\u2019t be hard since all it needs is logic similar to how dirty account modifications are discarded, which i have. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 3.455729166666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "34",
                    "likes": "0",
                    "time": "06/12/2018-03:01:19",
                    "content": "Even more interesting one, deploying contract and do static init in both init and body. The code should increment the counter twice, once in init and once in body (because of the call). The value written to storage address 0x20 in the first contract is the value read from the other contract\u2019s transient storage, i.e. a message has been passed between contracts without using return. { \t(def \"T_INIT_ADDR\" 0x00) \t(def \"T_COUNTER_ADDR\" 0x20)  \t(def \"tInit\" (TLOAD (ADDRESS) T_INIT_ADDR)) \t(def \"tCounter\" (TLOAD (ADDRESS) T_COUNTER_ADDR))  \t(def \"tInitW\" (val) (TSTORE T_INIT_ADDR val)) \t(def \"tCounterW\" (val) (TSTORE T_COUNTER_ADDR val))  \t(def \"StaticInit\"  \t    (unless tInit { \t\t(tInitW 0x01) \t\t(tCounterW 0x00) \t    }) \t) \t \t[0x20] (create { \t \t\tStaticInit \t\t(tCounterW (+ tCounter 1))  \t\t(returnlll { \t\t\tStaticInit \t\t\t(tCounterW (+ tCounter 1)) \t\t\t(return 0) \t\t}) \t}) \t \t(msg @0x20 0) \t[[0x00]] (TLOAD @0x20 T_COUNTER_ADDR) }  The contract with address 0f572e5295c57f15886f9b263e2f6d2d6c7b5ec6 is the deploying one, using the default contract address for evm invocations like these. The one being deployed is 5ecfbe86fcd903321c505cb5c8a5de6331e2e7b1. { \t\"errno\": 0, \t\"errpc\": 64, \t\"returnData\": \"\", \t\"mem\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000005ecfbe86fcd903321c505cb5c8a5de6331e2e7b1296000396000f300fe6000305c601157600160005d600060205d5b60016020305c0160205d600060005260206000f30000000000000000000000000000000000\", \t\"stack\": [], \t\"accounts\": [ \t\t{ \t\t\t\"address\": \"cd1722f2947def4cf144679da39c4c32bdc35681\", \t\t\t\"balance\": \"0\", \t\t\t\"nonce\": 1, \t\t\t\"code\": \"\", \t\t\t\"storage\": [], \t\t\t\"destroyed\": false \t\t}, \t\t{ \t\t\t\"address\": \"0f572e5295c57f15886f9b263e2f6d2d6c7b5ec6\", \t\t\t\"balance\": \"0\", \t\t\t\"nonce\": 1, \t\t\t\"code\": \"6000600052596000526050806042600051396000516000f060205260006000526020600060206000600060205160155a03f1506000515060206020515c60005500fe6000305c601157600160005d600060205d5b60016020305c0160205d60278060296000396000f300fe6000305c601157600160005d600060205d5b60016020305c0160205d600060005260206000f300\", \t\t\t\"storage\": [ \t\t\t\t{ \t\t\t\t\t\"address\": \"0\", \t\t\t\t\t\"value\": \"2\" \t\t\t\t} \t\t\t], \t\t\t\"destroyed\": false \t\t}, \t\t{ \t\t\t\"address\": \"5ecfbe86fcd903321c505cb5c8a5de6331e2e7b1\", \t\t\t\"balance\": \"0\", \t\t\t\"nonce\": 0, \t\t\t\"code\": \"6000305c601157600160005d600060205d5b60016020305c0160205d600060005260206000f300\", \t\t\t\"storage\": [], \t\t\t\"destroyed\": false \t\t} \t], \t\"logs\": [] }   Here\u2019s an even more advanced one. The first contract writes a message into its transient storage then calls the other. The other contract looks at the transient storage of (CALLER) to see if they left them a message. If so, and if it\u2019s the correct one, it will respond. The first contract checks the targets transient storage after the call and writes the response into its regular storage. { \t(def \"T_INIT_ADDR\" 0x00) \t(def \"T_MSG_ADDR\" 0x20)  \t(def \"tInit\" (TLOAD (ADDRESS) T_INIT_ADDR)) \t(def \"tMsg\" (TLOAD (ADDRESS) T_MSG_ADDR))  \t(def \"tInitW\" (val) (TSTORE T_INIT_ADDR val)) \t(def \"tMsgW\" (val) (TSTORE T_MSG_ADDR val))  \t(def \"StaticInit\"  \t    (unless tInit { \t\t(tInitW 0x01) \t\t(tMsgW 0x00) \t    }) \t) \t \t[0x20] (create { \t \t\tStaticInit  \t\t(returnlll { \t\t\tStaticInit \t\t\t(when (= (TLOAD (CALLER) T_MSG_ADDR) \"Here's ur message.\") (tMsgW \"Thanks, bro.\")) \t\t\t(return 0) \t\t}) \t})  \t(tMsgW \"Here's ur message.\") \t(msg @0x20 0) \t[[0x00]] (TLOAD @0x20 T_MSG_ADDR) }  andreas@AndreasLT:~/solevm/bin$ node run.js { \t\"errno\": 0, \t\"errpc\": 101, \t\"returnData\": \"\", \t\"mem\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000005ecfbe86fcd903321c505cb5c8a5de6331e2e7b16000305c601157600160005d600060205d5b7f486572652773207572206d6573736167652e00000000000000000000000000006020335c14156060577f5468616e6b732c2062726f2e000000000000000000000000000000000000000060205d5b600060005260206000f3000000000000000000000000000000000000000000\", \t\"stack\": [], \t\"accounts\": [ \t\t{ \t\t\t\"address\": \"cd1722f2947def4cf144679da39c4c32bdc35681\", \t\t\t\"balance\": \"0\", \t\t\t\"nonce\": 1, \t\t\t\"code\": \"\", \t\t\t\"storage\": [], \t\t\t\"destroyed\": false \t\t}, \t\t{ \t\t\t\"address\": \"0f572e5295c57f15886f9b263e2f6d2d6c7b5ec6\", \t\t\t\"balance\": \"0\", \t\t\t\"nonce\": 1, \t\t\t\"code\": \"600060005259600052608c80610067600051396000516000f06020527f486572652773207572206d6573736167652e000000000000000000000000000060205d60006000526020600060206000600060205160155a03f1506000515060206020515c60005500fe6000305c601157600160005d600060205d5b606c806100206000396000f300fe6000305c601157600160005d600060205d5b7f486572652773207572206d6573736167652e00000000000000000000000000006020335c14156060577f5468616e6b732c2062726f2e000000000000000000000000000000000000000060205d5b600060005260206000f300\", \t\t\t\"storage\": [ \t\t\t\t{ \t\t\t\t\t\"address\": \"0\", \t\t\t\t\t\"value\": \"5468616e6b732c2062726f2e0000000000000000000000000000000000000000\" \t\t\t\t} \t\t\t], \t\t\t\"destroyed\": false \t\t}, \t\t{ \t\t\t\"address\": \"5ecfbe86fcd903321c505cb5c8a5de6331e2e7b1\", \t\t\t\"balance\": \"0\", \t\t\t\"nonce\": 0, \t\t\t\"code\": \"6000305c601157600160005d600060205d5b7f486572652773207572206d6573736167652e00000000000000000000000000006020335c14156060577f5468616e6b732c2062726f2e000000000000000000000000000000000000000060205d5b600060005260206000f300\", \t\t\t\"storage\": [], \t\t\t\"destroyed\": false \t\t} \t], \t\"logs\": [] }  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None"
                    ],
                    "Sentiment": 3.6098484848484844
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "35",
                    "likes": "0",
                    "time": "06/12/2018-09:50:10",
                    "content": "    androlo:  Instructions: TSTORE (sAddr val) - pop 'sAddr' and 'val' and set tStore(_ADDRESS_)[sAddr] = val TLOAD (accAddr, sAddr) - pop 'accAddr' and 'sAddr' and push tStore(accAddr)[sAddr]  _ADDRESS_ would be the address of the current account   Great work! I need some time to catch up with you. so TLOAD above allows reading from other contract\u2019s transient storage? So that it allows arbitrary message passing across contracts in a frame? ",
                    "links": [],
                    "GPT-discussion-categories": [],
                    "Sentiment": 5.775
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "36",
                    "likes": "0",
                    "time": "06/12/2018-15:25:04",
                    "content": "Yes. I think I saw you write this in some other post that this could be a goal? Maybe you did not put it exactly like this but it seems like a good start. The way I implemented it as of right now, every account get an additional memory that it can read and write to and the data will remain throughout an entire transaction (i.e. in between contract-to-contract calls). They can also read from other contract\u2019s transient storage \u201cmemory\u201d. The last example i posted above is essentially a call that involves calldata + returndata, but uses only the transient storage. I am making a repo which i will upload soon, with some stuff from this thread and ideas on various things like how to structure call/returndata. It also shows instructions on how to run my modified solidity evm (until a better alternative is done, maybe using pyeth or something). Maybe I upload tomorrow or today. BTW the modified LLLC can be found at: https://github.com/androlo/solidity It is in the \u2018tstore\u2019 branch, just build like normal (with -DLLL=ON) and it will understand: TLOAD accountAddress storageAddress (0x5C) TSTORE storageAddress value (0x5D) TCOPY accountAddress storageAddress memoryAddress length (0x5E) Copy is just a simple way to move data to memory, since it would be very useful for return/calldata, but I guess for reentrancy checks and such it is optional. EDIT: repo is here: https://github.com/androlo/tstorage ",
                    "links": [
                        "https://github.com/androlo/tstorage"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.633035714285715
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "37",
                    "likes": "0",
                    "time": "06/12/2018-19:23:33",
                    "content": "Honestly, I don\u2019t understand why this storage would be worse, or why it would make code analysis more difficult. If a general purpose memory could simplify or even deprecate several other instructions, along with their special purpose memories it should imo make analysis easier and not harder. Shouldn\u2019t it make the model of computation simpler? This could probably be proven I\u2019m guessing. Sure, it would make return and calldata \u201cvolatile\u201d in that it could change when making a call in the code, but that\u2019s already the case for returndata afaik. also i don\u2019t understand why regular calldata needs to be some holy data that can\u2019t be edited. tStorage for 0x000\u2026000 could be used by EVM to store the transaction input, which means it would be accessible throughout the entire transaction, from all contracts, sort of like argv. it would also be immutable. The data passed between one contract and another could just be managed with TLOAD/TSTORE using a standard, for example in the repo i show how it can have standard reserved addresses for length and location. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.469047619047619
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "38",
                    "likes": "0",
                    "time": "06/12/2018-19:31:15",
                    "content": "    androlo:  Honestly, I don\u2019t understand why this storage would be worse, or why it would make code analysis more difficult. If a general purpose memory could simplify or even deprecate several other instructions, along with their special purpose memories it should imo make analysis easier and not harder. Shouldn\u2019t it make the model of computation simpler? This could probably be proven I\u2019m guessing.   I believe this type of storage would be better. And do think reading from other contract\u2019s transient storage/memory could be a useful resource. I just need some time to process what you have done so far. These opcodes might be quite useful when we start integrating eWASM into Ethereum 1.0 (Or Ethereum 1x). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.573979591836736
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "39",
                    "likes": "1",
                    "time": "06/12/2018-23:41:58",
                    "content": "Added some solidity versions to repo too. They compile with the modified compiler i link to in the docs and runs in the solevm I link to as well. Below is example of an already posted LLL contract that has a static counter. A bit contrived but it maybe shows a bit better what the idea is to people who don\u2019t know LLL. pragma solidity ^0.5.0;  // compile bin-runtime and use '364497e4' as input argument after the bytecode with ./bin/run  contract Test {      function __STATIC_INIT() private view {         assembly {             if iszero(tload(address, 0x0)) {                 tstore(0x00, 1)                 tstore(0x20, 0)             }         }     }      function counterIncrease() private view {         assembly {             tstore(0x20, add(tload(address, 0x20), 1))         }     }      function counterGet() private view returns (uint) {         uint ctr;         assembly {             ctr := tload(address, 0x20)         }         return ctr;     }      constructor() public {         __STATIC_INIT();     }      function body() public view returns (uint) {         __STATIC_INIT();          if (counterGet() < 5) {             counterIncrease();             this.body();         }          return counterGet();     } }  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.3125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/AlexeyAkhunov",
                    "index": "40",
                    "likes": "0",
                    "time": "07/12/2018-11:37:37",
                    "content": "    androlo:  Added some solidity versions to repo too. They compile with the modified compiler i link to in the docs and runs in the solevm I link to as well.   Looks good! I am really grateful to you for researching these ideas. What do you think the main advantage of using transient storage/memory would be? I thought about libraries - in the current form, and not just libraries for computing some functions, but more importantly, libraries for dealing with data structures (hash tables, balanced trees, skip lists). Of course, it would be great to have the non-transient storage to be linear too, so that you can map part of the storage to the transient memory, pass it to the library (for example, to a balanced tree library), which will modify the structure, and then the owner of the storage commits it back to the storage. I am not suggesting you do all this work, but I am really intrigued about what Ethereum would look like if EVM was designed with linear storage, how much more efficient and convenient it would be. That is one of the reason I attempted to introduce linear cross-contract storage in State Rent proposal. It is likely that it won\u2019t be implemented as part of the State Rent, but I still think the idea of linear storage is important. And perhaps it will be a requirement for proper integration with eWASM ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "Author of proposal is asking for feedback",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.55448717948718
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "41",
                    "likes": "0",
                    "time": "07/12/2018-14:07:29",
                    "content": "i don\u2019t know about linear storage i mainly just think that this eip is a good idea and that many instructions could be made easier and even removed if there is a memory like this. it feels like everything that has to do with transaction-wide data and contract-to-contract messaging is a form of hack. that itself is not a problem i guess since it works fine, but maybe the hacks are becoming too many, and it also seems to be the way forward. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 7.277777777777778
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "42",
                    "likes": "0",
                    "time": "07/12/2018-14:48:15",
                    "content": "    AlexeyAkhunov:  Of course, it would be great to have the non-transient storage to be linear too, so that you can map part of the storage to the transient memory, pass it to the library (for example, to a balanced tree library), which will modify the structure, and then the owner of the storage commits it back to the storage.   actually my solidity evm has linear storage since i wanted it to reside only in the vm memory. it also does all invocations in the same actual vm (only internal functions) - so running it is one single call to a view function. it would probably be easy to emulate the stuff you\u2019re suggesting in there. you have to be more specific though, are you talking about a space that is editable by any contract? like one single \u201cscratch space\u201d that is read writable by any contract that wants to? hmm maybe that\u2019s preferable to the behemoth system i am envisioning\u2026 hmm\u2026 i guess static variables in the way i think about would not be feasible. at least things like reentrancy locks would be better solved with gas netting then putting in a tx wide memory that is not reserved for a single account, but i guess library stuff like you suggest would be plenty more efficient since you would only have to write it once. and i guess the single scratch space could be used for other call and return data too. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.570134575569358
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/androlo",
                    "index": "43",
                    "likes": "0",
                    "time": "07/12/2018-19:41:02",
                    "content": "I have thought about this some more, and done some more experimentation. It seems like the security issue with calldata/returndata is tied to whether or not the transient memory is cleared in combination with a call or return. If not, then it is very bug prone. If it is, that makes it useless for what it was originally intended for which is to store data between calls (all it would become is essentially a merging of the current calldata and returndata memories) If a map with one memory for every address is implemented, the evm could use address 0 as a combined call/return data storage, used by the various return, calldata, and call instructions, but the other ones would be writable to only by a single contract account each, so the efficient data editing by other accounts would not work. Also, regardless of how it\u2019s implemented, it would be an enormous new component. Real static variables would be fully supported though. If there is only the scratch space then that would be good for the libraries, who could pass data very efficiently, but that\u2019s all it would be good for - no static variables, not possible to use for regular calls/returns, which means it would require a new memory + new instructions on top of those that already exists. EDIT: A more advanced memory model is maybe needed to do the linear memory but it seems it would require either more instructions or modified instructions, and potentially a lot more bookkeeping by the evm. I am not sure how it would work though. Maybe someone already has suggestions out there. I\u2019m gonna look around a bit. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.873010054461667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/axic",
                    "index": "44",
                    "likes": "0",
                    "time": "09/12/2021-15:50:23",
                    "content": "@moodysalem started to revive this proposal: fix: edit eip-1153.md to treat transient storage the same as persistent storage with regards to reverts by moodysalem \u00b7 Pull Request #4529 \u00b7 ethereum/EIPs \u00b7 GitHub I wonder if instead of storage, should we consider an alternative: a second persistent memory area during a transaction frame.  Basically that means instead of a word-addressed memory (e.g. TSTORE/TLOAD), there is a freely addressed memory space. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.666666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "45",
                    "likes": "1",
                    "time": "09/12/2021-22:34:32",
                    "content": "Here is a concrete example of my use case that requires these opcodes (A is a third party developer, B is the protocol):   A calls B#openCheckbook()   B calls ICheckbookOpener(msg.sender).opened()   A calls B#spend() which accumulates a debt to the checkbook (transient storage)  A calls B#deposit() which pays off a debt to the checkbook (transient storage)    B checks the checkbook is balanced and reverts if not    We want user contract A to be able to call methods in protocol contract B in any order and while interacting with any external contracts in between calls to B, and check the accounting only when user contract A is done. Giving up control to the caller of B is the easiest way to do this. The minimum amount of transient storage slots used by this pattern for accounting in our use case is 6, but transactions can easily use more than 6 slots for accounting. The cost to make all these transient SSTOREs makes up more than half the gas cost. As of EIP-3529, the refund is limited to 20% of the gas used, so the transaction must spend at least 600k gas to get a full refund for 6 transient storage slots. In addition, the SLOADs for 6 slots that are guaranteed to be 0 make up another ~15k gas. This model isn\u2019t really feasible with the high cost of storage-used-transiently. The only alternative model available in the EVM today is creating a separate \u2018VM\u2019 (a la weiroll VM) that is executed by contract B. However, to do so without introducing security issues in contract B is very difficult, and also the design is hard to use (difficult to construct the calldata onchain). ",
                    "links": [
                        "https://ethereum-magicians.org/t/eip-5283-a-semaphore-for-parallelizable-reentrancy-protection/10236/2"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.319360902255639
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/jochem-brouwer",
                    "index": "46",
                    "likes": "0",
                    "time": "13/12/2021-17:32:10",
                    "content": "Interesting EIP. This would make it possible to create maps and dynamic arrays in contracts/solidity without paying excessive gas costs. In case of reverts it should rollback all changes to the transient storage. In case that someone wants to propagate error messages you can use and accumulate returndata. The gas cost should be on par with accounting for reverts and the lookup time of this \u201cdynamic\u201d memory. Note: maps/dynamic arrays would also be possible if we do @axic 's proposal. This would mean that it is only available in the current call frame, but I think in practical cases this would okay. It would also be easier to implement since there is easy revert logic, just discard all memory and transient memory. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.612847222222222
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/fredlacs",
                    "index": "47",
                    "likes": "2",
                    "time": "10/01/2022-16:03:57",
                    "content": "This EIP would also be useful for Arbitrum. The Outbox contract is responsible for handling execution of L2 to L1 transactions. It uses a pattern similar to a reentrancy lock in order to surface context information of the current L2 to L1 transaction. This allows the outbox to surface the context information without putting any assumptions on a necessary interface when consuming these transactions. ",
                    "links": [
                        "https://ethereum-magicians.org/t/shanghai-cancun-candidate-eip-1153-transient-storage/10784",
                        "https://ethereum-magicians.org/t/eip-5283-a-semaphore-for-parallelizable-reentrancy-protection/10236/2"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party extending to proposal",
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wbl",
                    "index": "48",
                    "likes": "0",
                    "time": "14/01/2022-22:30:12",
                    "content": "I\u2019m interested in seeing this progress, and am willing to contribute some motivation text to the proposal and implementation elbow grease. First some text questions: I do have some questions about exactly what is meant by \u201ca write within a frame\u201d If we have contact A and the callstack A->B->A, and the outermost A reverts, I would expect the transient writes in the innermost call to A to also revert. I think the example implementation proposal works semantically but isn\u2019t a model for implementors. It makes reverts cheap, but at the expense of extra complexity in reads since they must look through the stack of maps to see if a previous write exists. It also adds a linear in dirty set cost to ordinary returns. I\u2019d prefer to spend the cost on reverts, while making reading and writing cheap. One way to achieve this is to have a single map per transaction that maps (account, addressing_word)->word and a list of writes and calls. A write appends the old value and the new value of the address to the list, and a call adds a marker to the list. On revert the list can be used to undo all writes that happened after the most recent call. As for axic\u2019s proposal I\u2019m less enthused. I really want this to be across call frames, akin to static data in C. Otherwise I think it is akin to the existing memory, and doesn\u2019t enable the interesting uses. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party offering to collaborate on proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.653053087263613
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "49",
                    "likes": "0",
                    "time": "18/01/2022-18:33:34",
                    "content": "Another pattern that this would benefit is reading constructor arguments from the sender contract, as in UniswapV3Factory  github.com   Uniswap/v3-core/blob/9161f9ae4aaa109f7efdff84f1df8d4bc8bfd042/contracts/UniswapV3Pool.sol#L119                       }                       /// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()           modifier onlyFactoryOwner() {               require(msg.sender == IUniswapV3Factory(factory).owner());               _;           }                       constructor() {               int24 _tickSpacing;               (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();               tickSpacing = _tickSpacing;                           maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);           }                       /// @dev Common checks for valid tick inputs.           function checkTicks(int24 tickLower, int24 tickUpper) private pure {               require(tickLower < tickUpper, 'TLU');               require(tickLower >= TickMath.MIN_TICK, 'TLM');               require(tickUpper <= TickMath.MAX_TICK, 'TUM');                     This is done to prevent the constructor arguments from being part of the CREATE2 address, allowing CREATE2 addresses to be cheaply computed onchain because the init code hash does not need to be computed. With smaller proxies, the cost of writing and reading from storage may be less than 20% of the gas to deploy the proxy.     wbl:  I do have some questions about exactly what is meant by \u201ca write within a frame\u201d If we have contact A and the callstack A->B->A, and the outermost A reverts, I would expect the transient writes in the innermost call to A to also revert.   Yes, it should behave just like regular storage. If the outermost call to A reverts after exiting the A->B->A call stack, any writes in the innermost A should also revert. I would approve any clarifications to the text in the EIP.     wbl:  I think the example implementation proposal works semantically but isn\u2019t a model for implementors. It makes reverts cheap, but at the expense of extra complexity in reads since they must look through the stack of maps to see if a previous write exists. It also adds a linear in dirty set cost to ordinary returns. I\u2019d prefer to spend the cost on reverts, while making reading and writing cheap. One way to achieve this is to have a single map per transaction that maps (account, addressing_word)->word and a list of writes and calls. A write appends the old value and the new value of the address to the list, and a call adds a marker to the list. On revert the list can be used to undo all writes that happened after the most recent call.   Great feedback, thanks! Would you be able to send a PR to edit the EIP? ",
                    "links": [
                        "https://github.com/Uniswap/v3-core/blob/9161f9ae4aaa109f7efdff84f1df8d4bc8bfd042/contracts/UniswapV3Pool.sol#L119"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.544519874065329
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/brockelmore",
                    "index": "50",
                    "likes": "2",
                    "time": "20/01/2022-04:54:06",
                    "content": "Throwing another use case in here: better transient solidity arrays. Memory based arrays in solidity suck as you have to define their lengths beforehand and lack push semantics. Transient storage would make it trivial to implement arrays like every other language does without massive headaches. Would be a major win for devUX ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.237500000000001
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "51",
                    "likes": "4",
                    "time": "30/01/2022-19:56:58",
                    "content": "Reentrancy protection is a sufficient reason to support these opcodes. A couple of other missing features that would become possible with EIP 1153:  transient mapping.  Currently there is no easy way to have a transient map or an array of variable length objects in memory. Maintaining an opaque context across calls in the same transaction.  We have a concrete use for both in the EntryPoint contract of ERC 4337, where the batching function needs to iterate twice on structs that have a bytes[] component.  The contract currently resorts to an asm implementation of memory pointers.  The proposed opcodes would make it cleaner and less dependent on current solidity memory management. Mapping, could be implemented using just memory, but the fact that TSTOR/TLOAD works across frames would enable the ERC 4337 paymaster to maintain its context without returning it to EntryPoint in the first call and receiving it as calldata in the second call.  EntryPoint only conveys the opaque context between multiple calls to the paymaster, and never needs to see it.  With TSTOR/TLOAD the context would be maintained locally in the paymaster. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.897222222222222
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wbl",
                    "index": "52",
                    "likes": "2",
                    "time": "12/02/2022-00:15:03",
                    "content": "I\u2019ve opened https://github.com/ethereum/EIPs/pull/4791. I\u2019m still unsure of the process to get this discussed by the relevant people. I\u2019ll go start work on an implementing PR if people haven\u2019t already. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 7.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "53",
                    "likes": "3",
                    "time": "19/02/2022-23:56:46",
                    "content": "Another perspective for why transient storage makes sense is that the low refund cap incentivizes state bloat, because it ends up being cheaper to keep a storage slot dirty if it\u2019s used in a transient way. Granted, this is probably not a significant component of the state growth problem, but I think it clearly shows that storage and transient runtime data are inherently different and have conflicting implementation concerns, so they should be implemented as separate concepts in the EVM. I believe efficient transient storage will enable a whole family of smart contract programming patterns to be developed, because it is a key primitive for contract composability where multiple call frames are involved. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 4.913392857142857
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wbl",
                    "index": "54",
                    "likes": "1",
                    "time": "24/02/2022-00:01:04",
                    "content": "I\u2019ve opened a draft implementing PR https://github.com/ethereum/go-ethereum/pull/24463. There\u2019s a number of points keeping me from making it a real PR, starting with a lack of tests, all discussed there. Comments welcome. Also we should discuss how the semantics work during contract creation. I\u2019m not entirely sure my PR will be right depending on what we decide. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.044642857142857
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/tynes",
                    "index": "55",
                    "likes": "4",
                    "time": "04/03/2022-16:06:31",
                    "content": "At ETHDenver, the Optimism team built a proof of concept implementation of  EIP-1153, including the necessary changes to go-ethereum and solc to allow developers to test it out. This EIP introduces two new opcodes - TLOAD and TSTORE. Both of which mirror SLOAD and SSTORE but instead use memory instead of reading/writing to disk. These opcodes enable an in memory key/value store that is namespaced by the current address(this). Some usecases include reentrency locks, in memory mappings, better in memory arrays. The transient storage persists throughout execution of the transaction, but is not globally accessible. This means that if contract A writes something into transient storage, then contract B will not be able to read that value. It seems like there is some desire to have a global transient storage that can be accessed between accounts. This adds complexity as a system will need to be in place for preventing contracts from overwriting keys that were written by other contracts and contracts will need to use a dynamic keying system to prevent storage slot collision. Perhaps another opcode EXTSLOAD can be considered in the future for this functionality. h/t @moodysalem The solc fork supports yul functions for TLOAD and TSTORE as well as an experimental transient keyword in solidity. For a quickstart guide on compiling contracts locally to use these opcodes, see https://github.com/tynes/eip1153 A hosted node running the code can be found at https://eip1153.optimism.io. If you are interested in receiving some funds to test it out, dm @tyneslol on Twitter. Shoutout to Matthew Slipper and Conner Fromknecht for their help in implementing it, Ben Wilson in deploying it, as well as various conversations with protolambda, Kelvin Fichter, Karl Floersch, Ben Jones and Ethereum researchers around its usage and implementation. Note: the solc fork is highly experimental and should not be used in production. See the code here:   github.com   GitHub - tynes/go-ethereum at eip1153 eip1153 Official Go implementation of the Ethereum protocol         github.com   GitHub - cfromknecht/solidity at transient-keyword transient-keyword Solidity, the Smart Contract Programming Language. Contribute to cfromknecht/solidity development by creating an account on GitHub.      ",
                    "links": [
                        "https://github.com/tynes/go-ethereum/tree/eip1153",
                        "https://github.com/tynes/go-ethereum/tree/eip1153",
                        "https://github.com/cfromknecht/solidity/tree/transient-keyword",
                        "https://github.com/cfromknecht/solidity/tree/transient-keyword",
                        "https://github.com/cfromknecht/solidity/tree/transient-keyword"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.465046672077922
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/brockelmore",
                    "index": "56",
                    "likes": "0",
                    "time": "07/03/2022-18:01:22",
                    "content": "I have concerns over the current pricing model. I can setup GitHub - imapp-pl/gas-cost-estimator for geth, REVM, and sputnik and use the above implementation for geth, and implement it in REVM and sputnik (common rust EVMs) to measure performance. My guess is 100 is much too high, even with revert requirements. If i were to estimate before measuring, I would guess it would probably be better around 30 gas for TSTORE. Reasoning, in reference to comparable opcodes that exist today: MSTORE + 5 // store in map, add 5 for calculating placement in mapping MSTORE + 5 // store changelog info price similarly to standard word memory storage, add 5 for calculating placement in mapping // IMPLICIT REVERT MLOAD + 5  // load changelog info, add 5 for calculating location in mapping to load MSTORE + 5 // undo storage change, add 5 for calculating update location in mapping  This naive guess would put it at 32 gas for a TSTORE. TLOAD should never be more than 10 probably. Symmetric pricing doesn\u2019t make sense given TLOAD has no revert considerations to my knowledge. edit: the changelog is a mapping of index to \u201coriginal values\u201d built up when you do a TSTORE. You basically build up a mapping or array of changed indexes, then roll them back when there is a revert, by loading the value by index in the mapping (thus the extra \u201cMSTORE\u201d + \u201cMLOAD\u201d - not literal MSTORE/MLOADs, but conceptually and performance similar) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None"
                    ],
                    "Sentiment": 5.316666666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/tynes",
                    "index": "57",
                    "likes": "0",
                    "time": "07/03/2022-18:24:19",
                    "content": "One thing to take into consideration is the total amount of memory that can be allocated if a block has a single tx that uses all gas to store as many key/value pairs as possible. If this is enough memory to oom the node on consumer hardware, then the gas price is too low. I definitely prefer to lower the gas cost as much as possible while being safe and think it would be good to have some benchmarks/formulas on how much memory would be allocated in 15 million gas in this scenario. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.8311688311688314
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/brockelmore",
                    "index": "58",
                    "likes": "1",
                    "time": "07/03/2022-18:28:57",
                    "content": " how much memory would be allocated in 15 million gas in this scenario.  15,000,000 total gas / 32 gas = 468,750 TSTOREs max memory usage: 468,750 TSTOREs * 32 bytes per word = 15,000,000 bytes == 15mb memory allocation that is dropped at the end of the transaction edit: you also have to do 2 PUSH1(x) per TSTORE, so actual max is 394,736 TSTOREs so 12.6mb ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal"
                    ],
                    "Sentiment": 5.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "59",
                    "likes": "0",
                    "time": "07/03/2022-19:24:18",
                    "content": "I implemented a PoC of this for vyper as well, but I think the codegen would be better if TLOAD and TSTORE were byte addressed instead of word addressed like SLOAD and SSTORE. I discussed with @tynes and it sounds like this is doable in geth, just slightly more complicated as unaligned loads/stores need to issue two reads or writes. Also it would be nice if there were batch copy opcodes, analogous to CALLDATACOPY and CODECOPY. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "60",
                    "likes": "0",
                    "time": "07/03/2022-19:25:37",
                    "content": "Maybe worth it to price in a transient storage expansion cost, to model cost going up as you approach OOM. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/tynes",
                    "index": "61",
                    "likes": "0",
                    "time": "07/03/2022-19:54:46",
                    "content": "I would support opening a PR that reduces the costs to the proposed values, there is going to be some overhead in the implementations themselves that would make the maximum memory allocated higher than in the formulas. I have some code locally that uses https://github.com/fjl/memsize to observe the size of the transient storage struct after filling it up with a ton of bytes. If we can come to an agreement on what the safe max size is, then I can add a test to the geth implementation for that. Perhaps 15mb? Would need to run it again with the new values to see where its at. I think we should also come to agreement on the bytes that represent the opcodes themselves, because in its current state different implementations are using different numbers.   https://github.com/ethereumjs/ethereumjs-monorepo/pull/1768 uses 0xa5 and 0xa6   https://github.com/tynes/go-ethereum/tree/eip1153 uses 0x5c and 0x5d   https://github.com/cfromknecht/solidity/tree/5aaf51f82e7acd9c50406332e2acb4e175b7572a uses 0x5c and 0x5d   https://github.com/vyperlang/vyper/tree/transient uses 0x4E and 0x4F   The Ethereum JS VM implements Simple Subroutines which use 0x5c and 0x5d  but I think the codegen would be better if TLOAD and TSTORE were byte addressed instead of word addressed like SLOAD and SSTORE  I\u2019m definitely not opposed to this but would want more feedback from people first. Perhaps @AlexeyAkhunov @axic?  Maybe worth it to price in a transient storage expansion cost, to model cost going up as you approach OOM.  I\u2019d prefer to not have dynamic costs if possible since that would increase the complexity of the implementations, but that would make it much safer against mass TSTORE'ing. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.823863636363637
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/brockelmore",
                    "index": "62",
                    "likes": "0",
                    "time": "07/03/2022-19:55:44",
                    "content": "unlike mstore (max memory expansion is 2.5gb from what someone else calculated), max memory allocation is small. Strongly think the complexity isn\u2019t worth it but i will explore later with concrete benchmarks. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.633333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "63",
                    "likes": "0",
                    "time": "09/03/2022-20:48:11",
                    "content": "    charles-cooper:  but I think the codegen would be better if TLOAD and TSTORE were byte addressed instead of word addressed like SLOAD and SSTORE   The alternate solution of a byte-addressed persistent memory makes it a lot harder to support things like mappings or dynamic arrays. Our primary use case needs mappings. Implementing a mapping in memory is painful. I imagine persistent memory would also have to be more expensive to account for reverts, which require you to store snapshots of the persistent memory with each new context for an address. I also think the revert behavior of persistent memory will not be as obvious for developers. For those reasons I\u2019d prefer opcodes with the same semantics of storage.     brockelmore:  unlike mstore (max memory expansion is 2.5gb from what someone else calculated), max memory allocation is small. Strongly think the complexity isn\u2019t worth it but i will explore later with concrete benchmarks.   We chatted in DMs and the 2.5gb number seems incorrect. A closer estimate of the max memory size that can be allocated via mstore is below: 30M gas = 3x + x^2 / 512 where x is the number of 256-bit words that can be allocated implies x = ~123,169 256-bit words max memory size in MB = ~123,169 words * 256 bits/word * 1MB / 2^23 bits = ~3.75MB This is computed with the assumption of a single call context, so maybe it can be inflated by creating a new context but I doubt it can be inflated by several orders of magnitude. To verify, go to evm.codes and enter the offset 123169 * 32 = 3941408 to see a gas cost of ~30M due to memory expansion. Not sure about the original motivation of this very constrained memory. Re TLOAD/TSTORE pricing: if the warm SLOAD/SSTORE is overpriced/underpriced, I think it makes more sense to reprice those opcodes than to give TLOAD/TSTORE a separate pricing model. They operate exactly the same with regards to reverts except the original value of the slot does not need to be loaded. Sidenote: I am working on testing the impact of TSTORE/TLOAD opcodes on the prototype I\u2019m working on. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.510648577612863
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "64",
                    "likes": "0",
                    "time": "09/03/2022-21:05:12",
                    "content": " The alternate solution of a byte-addressed persistent memory makes it a lot harder to support things like mappings or dynamic arrays. Our primary use case needs mappings. Implementing a mapping in memory is painful.  Not sure why, since there will be no transient storage/persistent memory expansion cost. Mappings will still work the same way as storage. It will just make it easier to issue unaligned loads and stores. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.535714285714286
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nikolai",
                    "index": "65",
                    "likes": "0",
                    "time": "10/03/2022-05:50:58",
                    "content": "Wouldn\u2019t TXID make more sense to start with\u2026 you can implement one with the other but not vice versa ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.9375
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "66",
                    "likes": "3",
                    "time": "18/03/2022-03:11:24",
                    "content": "I\u2019ve tested our prototype against this solidity compiler and using this gist to work around the incomplete solidity compiler support for the transient keyword, plus a grep to update the opcodes to match the EIP (PR waiting merge), and this  @ethereumjs/vm fork, and found the gas differences to be very significant as expected. This is far from an optimal implementation because I had to manually write the loads and stores in solidity plus they go through a delegatecall to an intermediate library (incurring a minimum 2600 + 100*(N-1) gas overhead). For example, the reentrancy lock looks like this using the linked gist: import {TransientStorageProxy, TransientStorage} from './libraries/TransientStorage.sol';  contract Contract {     using TransientStorage for TransientStorageProxy;      TransientStorageProxy public immutable transientStorage;      constructor() {         transientStorage = TransientStorage.init();     }      uint256 public constant LOCKED_BY_SLOT = uint256(keccak256('lockedBy'));      function lockedBy() public returns (address) {         return address(uint160(transientStorage.load(LOCKED_BY_SLOT)));     }      function setLockedBy(address addr) internal {         transientStorage.store(LOCKED_BY_SLOT, uint256(uint160(addr)));     } }  For our most expensive transactions, e.g. the first position to mint for a given tick range around the current price, #mint around current price new position mint first in range: the savings are minor, 385k to 365k. As expected the change does not benefit expensive transactions as much since the 20% refund cap is not as limiting, but there are still savings to be had avoiding unnecessary cold SLOADs. However, for a simple swap: #swapExact0For1 first swap in block with no tick movement, gas goes from 204k to 137k. Given V3 swaps are around 100k gas, this is the difference between feasible and infeasible for the prototype design (note this isn\u2019t exactly apples to apples\u2013the 37k difference will come down with proper support and is also made up elsewhere). Not having this EIP means we have to use a worse design. ",
                    "links": [
                        "https://gist.github.com/moodysalem/e569592adc97ad52bd72bb34f4013e32",
                        "https://github.com/cfromknecht/solidity/pull/4",
                        "https://github.com/ethereumjs/ethereumjs-monorepo/pull/1768/files",
                        "https://github.com/Uniswap/v3-core/blob/ed88be38ab2032d82bf10ac6f8d03aa631889d48/test/__snapshots__/UniswapV3Pool.gas.spec.ts.snap#L67"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.929316311260756
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "67",
                    "likes": "0",
                    "time": "18/03/2022-16:46:43",
                    "content": "    nikolai:  Wouldn\u2019t TXID  make more sense to start with\u2026 you can implement one with the other but not vice versa   I don\u2019t understand how that\u2019s related to this.     charles-cooper:  Not sure why, since there will be no transient storage/persistent memory expansion cost. Mappings will still work the same way as storage. It will just make it easier to issue unaligned loads and stores.   Byte-addressing for the TLOAD/TSTORE opcodes while still using an underlying map implementation is an unexpected hybrid between storage and memory that will confuse developers and implementers. It also would have to have dynamic gas cost to represent the fact that it reads/writes from either 1 or 2 slots depending on whether the given offset is word aligned, and unaligned writes will also have to avoid overwriting existing values via 2 separate loads. Thus it\u2019s a leaky abstraction to the fact that transient storage is key-value storage\u2013compiler devs will need to understand the hidden underlying implementation. Bytecode generation improvements in rare use cases don\u2019t seem worth the complexity in this case.     tynes:  I think we should also come to agreement on the bytes that represent the opcodes themselves, because in its current state different implementations are using different numbers.   Have since updated the EIP to TLOAD = 0xb3 and TSTORE = 0xb4. I\u2019ve also added the security considerations about non-quadratic memory expansion to the EIP. TSTORE is cheaper than MSTORE after 24831 words have been stored to memory. 24831 words occupy less than a megabyte.   wolframalpha.com    (3(x 1)   (x 1)^2 / 512) - (3x   x^2 / 512) = 100 - Wolfram|Alpha Wolfram|Alpha brings expert-level knowledge and capabilities to the broadest possible range of people\u2014spanning all professions and education levels.      Open to suggestions about how to improve the pricing for memory expansion. Agree with @tynes that ideally it does not result dynamic memory cost, but open to changing that about the EIP if it\u2019s deemed necessary by the client developers, and also would like if we can decrease the cost of small amounts of transient storage.     axic:  I wonder if instead of storage, should we consider an alternative: a second persistent memory area during a transaction frame. Basically that means instead of a word-addressed memory (e.g. TSTORE/TLOAD), there is a freely addressed memory space.   After working through the prototype, I still favor this map based interface (a la TSTORE/TLOAD) over a persistent memory similar to MSTORE/MLOAD because of how important mappings and dynamic arrays are for the use cases it enables, and also the expectation of how it interacts with reverts. ",
                    "links": [
                        "https://www.wolframalpha.com/input?i=%283%28x%2B1%29%2B%2B%2B%28x%2B1%29%5E2%2B%2F%2B512%29%2B-%2B%283x%2B%2B%2Bx%5E2%2B%2F%2B512%29%2B=%2B100",
                        "https://www.wolframalpha.com/input?i=%283%28x%2B1%29%2B%2B%2B%28x%2B1%29%5E2%2B%2F%2B512%29%2B-%2B%283x%2B%2B%2Bx%5E2%2B%2F%2B512%29%2B=%2B100"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.373397435897436
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/nikolai",
                    "index": "68",
                    "likes": "0",
                    "time": "18/03/2022-20:29:39",
                    "content": "    moodysalem:      nikolai:  Wouldn\u2019t TXID  make more sense to start with\u2026 you can implement one with the other but not vice versa   I don\u2019t understand how that\u2019s related to this.   I will try a different angle It might make sense to ask the cost of a origin calldata \u2018witness\u2019 verification via txid Then ask how expensive (or cheap) these tload/tstore opcodes would have to be to be used in practice It might turn out that the practical outcome of this is yet more reason to increase the cost of calldata Then after that it would no longer be logically connected, like you are implying ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.640625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "69",
                    "likes": "0",
                    "time": "25/03/2022-19:03:45",
                    "content": " After working through the prototype, I still favor this map based interface (a la TSTORE/TLOAD) over a persistent memory similar to MSTORE/MLOAD because of how important mappings and dynamic arrays are for the use cases it enables, and also the expectation of how it interacts with reverts.  I think @axic\u2019s proposal is still workable. The revert issue may potentially be addressed with a paging/COW implementation; and, mappings / resizable dynamic arrays should not be a deciding motivator here since they are a language restriction, not an EVM restriction. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.4
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wbl",
                    "index": "70",
                    "likes": "0",
                    "time": "25/03/2022-21:17:56",
                    "content": "I disagree with @charles-cooper . Nothing stops a language implementation from addressing an associative memory 2^256 words in size as though it was a linear memory of smaller size. Meanwhile the benefit to implementors for having such an oversize memory in reduced bookkeeping for maps and dynamic arrays is considerable. As for the size of entries in the memory the EVM works with 256 bit words natively. Addressing memory smaller than word size makes loads of these values harder, or consumes more opcode space for each width. Meanwhile there is no reason that values need to be compacted in this memory space given the low costs of access. If you have particular applications in mind that trump these concerns please share. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.37037037037037
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chriseth",
                    "index": "71",
                    "likes": "0",
                    "time": "29/03/2022-13:46:41",
                    "content": "Sorry, this is not meant to sound rude, but I\u2019m very sceptical about the usefulness of these new opcodes. They make the memory (in the more general sense) model and calling convention of the EVM even more complicated than it already is. The use cases I have seen do personally not convince me. They are either saving only a small amount of gas or need way more explanation. I\u2019m looking at the list as currently published on eips.ethereum.org):  \u201creentrancy locks\u201d - that\u2019s a joke, right? I don\u2019t understand this - can someone add more explanation please? not sure why this cannot be passed by memory passing error codes and messages up the execution stack is currently working well not sure how generic libraries with callbacks would use transient storage. Do you wont to store code in storage? isn\u2019t this what we currently have by the name of modifiers? How does this need transient storage? using transient storage for calldata metadata sounds like a hack to me.  Seriously, let\u2019s stop putting all our brain power towards saving 10k-100k per transaction and start scaling this thing properly! We need trees of rollups and especially we need things like \u201cevaluate evm inside evm\u201d, don\u2019t we? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.143488455988456
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "72",
                    "likes": "2",
                    "time": "29/03/2022-16:19:14",
                    "content": "    chriseth:  They make the memory (in the more general sense) model and calling convention of the EVM even more complicated than it already is.   The gas accounting rules for storage are currently so complicated, it\u2019s difficult for an experienced smart contract developer to estimate how much storage accesses in a transaction will cost in practice. With adoption, this EIP allows those accounting rules to be simplified.     chriseth:   \u201creentrancy locks\u201d - that\u2019s a joke, right?    As much of a joke as PUSH0 saving a O(1e11) gas on deploys alone, or simplifying 11.5% of all PUSH1 instructions, i.e. making all Ethereum nodes more efficient for the same effect. Uniswap V2 uses a transient storage slot just for unlocked. If you discount 2500 gas on every swap, mint, and burn on Uniswap V2, for wasted SLOADs, with V2 once accounting for 40%+ of the network traffic, you easily get billions-trillions of gas over the life of the contracts, and millions-billions of read ops on millions of hard drives (remember, this applies to hosted node services like Infura too). Making nodes more efficient is good. They\u2019re supposed to eventually run on mobile after all. Making the network horizontally scalable is also good. Maybe instead of making the EVM more efficient, the Ethereum nodes could JIT compile EVM bytecode, and still do gas accounting using the old bytecode, but that\u2019s a level of indirection and complexity that pushes out client developers and does not pass on performance improvements to users.     chriseth:   I don\u2019t understand this - can someone add more explanation please?    E.g.: v3-core/UniswapV3PoolDeployer.sol at ed88be38ab2032d82bf10ac6f8d03aa631889d48 \u00b7 Uniswap/v3-core \u00b7 GitHub This is done to avoid constructor arguments being part of the init code hash, allowing addresses to be computed on chain without constructing the preimage of the init code hash (i.e. the init code + constructor arguments). This is especially useful for proxies that have cheaper deploy costs. Yes this is an issue with the CREATE2 opcode, and the init code hash probably shouldn\u2019t have been included since it provides no guarantees about the deployed code. That ship has sailed.     chriseth:   not sure why this cannot be passed by memory    I think you are referring to single transaction approvals. This can be done with regular storage today. It cannot be done with memory, because the #transferFrom call will re-enter the token and have a new context in which the memory from the #approveAndCall is not accessible.     chriseth:   passing error codes and messages up the execution stack is currently working well    Passing errors up the stack is the weakest point, which is why I updated the EIP to have the same revert behavior as regular storage. It actually isn\u2019t useful for passing errors up the stack with the new behavior. I will update the EIP.     chriseth:   isn\u2019t this what we currently have by the name of modifiers? How does this need transient storage?    Yes, it is effectively modifiers, where the inner logic is actually calling into an external untrusted contract, which can do some set of operations as long as some invariants are held. This is not possible without using storage to keep track of the state between calls. If your modifier is complicated, you need a lot of transient storage for otherwise cheap operations. See the example.     chriseth:   using transient storage for calldata metadata sounds like a hack to me.    I don\u2019t find this point that convincing either, but it was there in an earlier draft. That said, calldata metadata is already in use today (also with gas station network IIRC) and looks very complicated.     chriseth:  especially we need things like \u201cevaluate evm inside evm\u201d, don\u2019t we?   If you read the above example, you will see, this is effectively allowing us to \u2018evaluate EVM inside of EVM\u2019, instead of evaluate \u2018custom Uniswap VM\u2019. The same thing is potentially useful for fault proofs. This EIP is supported by developers from both Arbitrum and Optimism. ",
                    "links": [
                        "https://github.com/Uniswap/v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/UniswapV2Pair.sol#L30-L36",
                        "https://github.com/Uniswap/v3-core/blob/ed88be38ab2032d82bf10ac6f8d03aa631889d48/contracts/UniswapV3PoolDeployer.sol#L34-L36",
                        "https://ethereum-magicians.org/t/eip-1153-transient-storage-opcodes/553/45",
                        "https://github.com/wighawag/clones-with-immutable-args/tree/86ab167f71fd0fd3321f58d13a3c7c8c3556ee53#cloneswithimmutableargs",
                        "https://opengsn.org/",
                        "https://ethereum-magicians.org/t/eip-1153-transient-storage-opcodes/553/45"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.64269268313386
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chriseth",
                    "index": "73",
                    "likes": "0",
                    "time": "31/03/2022-08:47:48",
                    "content": "Moody and me have talked in the meantime. I\u2019m still not convinced it is worth the complexity, but I understand some of the use-cases now. Having spent some more thoughts on this, one thing that caught my eye is that this is a transaction-based feature instead of a call-based feature. Until now (please correct me if I\u2019m wrong), the only way an \u201cinner call\u201d can be distinguished from an \u201couter call\u201d inside the EVM is using tx.origin and maybe some aspects of selfdestruct. And both tx.origin and selfdestruct have been heavily criticized because of that, for example with regards to account abstraction. Please excuse me if this has been discussed before, but one problem I can see (and mind me, it is a complicated feature) is that if we reset transient storage to zero only at the end of the transaction, we can no longer group two transactions together. For example, if you have a reentrancy lock and people do not reset it (because they want to save the gas) and rely on it being reset at the end of the transaction, you will no longer be able to call this contract for the rest of the transaction at all. We can solve this problem by resetting the transient storage of a contract whenever a call returns from the contract and the same contract is not in the current call stack. It would eliminate some other use cases, but it would feel much cleaner to me. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.008928571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "74",
                    "likes": "1",
                    "time": "31/03/2022-15:25:06",
                    "content": "    chriseth:  Having spent some more thoughts on this, one thing that caught my eye is that this is a transaction-based feature instead of a call-based feature. Until now (please correct me if I\u2019m wrong), the only way an \u201cinner call\u201d can be distinguished from an \u201couter call\u201d inside the EVM is using tx.origin and maybe some aspects of selfdestruct. And both tx.origin and selfdestruct have been heavily criticized because of that, for example with regards to account abstraction.   You could also check the code length of caller is greater than zero. You can\u2019t do this for code running in a constructor I\u2019m not sure if the exact criticisms of those opcodes applies here. Could you elaborate or share a link?     chriseth:  We can solve this problem by resetting the transient storage of a contract whenever a call returns from the contract and the same contract is not in the current call stack. It would eliminate some other use cases, but it would feel much cleaner to me.   This is interesting, but it might make transient storage harder to implement in the clients, since you need to keep track of the depth of the call stack by address. I don\u2019t think it would introduce any additional risk, but the contract is already capable of resetting storage before returning from the calls (and also if the call reverts, all transient storage writes within it are reverted as well.) The 100 gas per TSTORE saved is probably not worth optimizing, and actually more explicitly represents the cost of clearing the slots. IMO this should be handled by the smart contract, not by the opcode, because it is trivial to handle within the smart contract. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.538392857142858
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/chriseth",
                    "index": "75",
                    "likes": "0",
                    "time": "31/03/2022-16:36:14",
                    "content": "If you use a transient mapping and don\u2019t store the keys, the contract cannot reset it. Also this is just something people will forget about - \u201cah, it will be cleared at the end of the transaction anyway, I don\u2019t need to do it\u201d. The current go-ethereum implementation curretnly keeps a full transaction log of all transient store operations - clearly an address per call would not be a big deal. What I would be more interested in is which use-cases would not be possible any more in this modified version. Most cases I have seen call back into the caller, so those would be fine, as is the reentrancy lock obviously, but are there any where this does not happen? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.090277777777777
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "76",
                    "likes": "1",
                    "time": "31/03/2022-17:08:45",
                    "content": "    chriseth:  If you use a transient mapping and don\u2019t store the keys, the contract cannot reset it. Also this is just something people will forget about - \u201cah, it will be cleared at the end of the transaction anyway, I don\u2019t need to do it\u201d.   True, but why are you storing values in the mapping unless you later need to iterate through the map? I can\u2019t think of a use case that uses a mapping but doesn\u2019t store a list of keys. EDIT: you can also just count the number of set keys, which is more efficient, and check that it\u2019s 0 (require the caller to do something that unsets the keys) Sidenote, an iterable map data type would be cool to have in solidity, rather than doing this separately.     chriseth:  What I would be more interested in is which use-cases would not be possible any more in this modified version.   One case it breaks is a call to a hypothetical ERC20#temporaryApprove that only lasts one transaction, and then another call to a separate contract that calls #transferFrom (which looks for a transient approval before a regular approval). In the context of 3074, this might be the cheaper version of approve and swap in a single transaction (for tokens that would support it) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.081168831168831
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wjmelements",
                    "index": "77",
                    "likes": "0",
                    "time": "13/04/2022-21:13:54",
                    "content": "If the SSTORE_RESET refund were greater, there would be no need for transient storage; you could just reset the storage and its cost would be reduced. In addition, reverts are mispriced (and should refund), which prevents persistent storage from cheaply implementing transient storage. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 7.25
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/pcaversaccio",
                    "index": "78",
                    "likes": "3",
                    "time": "14/06/2022-15:53:39",
                    "content": "Hey everyone, I visualised the adjusted EVM with transient storage. Let me know if I missed something. It helped me a lot to explain the aim of EIP-1153. Maybe some of you can make use of it.  image3716\u00d71884 170 KB  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party extending to proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sergio_lerner",
                    "index": "80",
                    "likes": "0",
                    "time": "04/08/2022-21:02:03",
                    "content": "After reading EIP-1153 again: one strange thing about EIP-1153 is that it doesn\u2019t get reverted on REVERT or OOG in its own frame. How a robust mutex is implemented if it may leave the mutex activated by an error? This can be abused by an attacker to censor a certain contract. Let say a contract A calls another trusted contract T which uses a transient mutex. The attacker can perform a transaction that calls a contract A but blocks the execution of a targeted child contract T by performing these steps:  Call to T with very little gas so that it raises OOG during the execution of T, leaving the mutex active. Call A which will try to call T and that call will fail because of the mutex.  So this brings the stack overflow security problem back, but now using broken mutexes. Interaction with reverts should be be mandatory. At least transient memory writes should be reverted if the contract owning it reverts! ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.5067791005291005
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "81",
                    "likes": "2",
                    "time": "04/08/2022-21:55:45",
                    "content": "The original version of EIP-1153 did not interact with reverts. However, I edited the EIP so that it interacts with reverts in the exact same way that regular storage does. So it indeed works as you want it to, and the EIP-1153 text plus all existing implementations reflect that:  If a frame reverts, all writes to transient storage that took place between entry to the frame and the return are reverted, including those that took place in inner calls. This mimics the behavior of persistent storage.  Dropping a link here to the EIP-1153 implementation project board: EIP-1153 \u00b7 GitHub Sara Reynolds + Emily Williams at Uniswap Labs implemented the tests here, which verify the revert behavior described in the EIP: adding first filler tests by snreynolds \u00b7 Pull Request #1 \u00b7 snreynolds/tests \u00b7 GitHub ",
                    "links": [
                        "https://github.com/snreynolds/tests/pull/1/files"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party auditing and reviewing proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.729166666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wjmelements",
                    "index": "82",
                    "likes": "0",
                    "time": "17/10/2022-20:56:18",
                    "content": "My initial impression was that this is worse than just making transient storage patterns cost-effective for SSTORE/SLOAD. But since we have to pay storage gas up-front, the larger issue is that REVERT does not refund (see EIP-3978). I would rather the gas costs be fixed than for two opcodes to go toward this. The new opcodes won\u2019t fix existing gas injustices like UniswapV2\u2019s re-entry lock. These opcodes just create new complexity to isolate a small portion of new code from the problem, rather than addressing the problem itself. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.911931818181818
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Philogy",
                    "index": "83",
                    "likes": "1",
                    "time": "20/10/2022-19:37:43",
                    "content": "Thinking about potential use cases beyond making existing patterns more efficient I think it quickly becomes clear that dedicated opcodes are necessary. The upfront cost of setting a zero slot to a non-zero value combined with the cap to refunds is simply too high. I don\u2019t think you can efficiently use storage as transient storage because fundamentally nodes have to read from disk to check whether or not you\u2019re overriding a value meaning that effort has to be priced in. With transient storage you\u2019d get this fresh plot of data that can safely be modified throughout the transaction without needing to read anything from disk. A different approach to transient storage in general would be to allow contracts to mark storage slots as impermanent at deployment, via EOF. You\u2019d then change how SSTORE is priced by first checking whether the slot that\u2019s being read / written to was marked as impermanent allowing you to safely know that the default value is 0 and that the final value does not have to be written to disk at the end of a transaction. But this feels more complex vs. just adding separate opcodes ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.880392156862745
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wjmelements",
                    "index": "84",
                    "likes": "0",
                    "time": "27/10/2022-19:13:06",
                    "content": "    Philogy:  The upfront cost of setting a zero slot to a non-zero value combined with the cap to refunds is simply too high.   Again, this is the real problem, and transient storage is a band-aid. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.6000000000000005
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "85",
                    "likes": "0",
                    "time": "27/10/2022-19:34:29",
                    "content": "How do you propose gas costs should be fixed? How is this related to refunding on revert? As far as I can tell, the \u201creal problem\u201d is that storage is fundamentally a persistent data structure and resource, and using it for transient purposes is almost guranteed to be inefficient. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party asking questions about proposal",
                        "3rd party giving constructive criticism of proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wjmelements",
                    "index": "86",
                    "likes": "0",
                    "time": "27/10/2022-19:51:31",
                    "content": "    frangio:  How do you propose gas costs should be fixed?   By pricing transient use cheaply.     frangio:  How is this related to refunding on revert?   Revert is the main case in which storage writes are unfairly priced; we are paying for storage that will not occur, similar to your transient case. There is an EIP (EIP 3978) to fix this, but it needs work. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.138888888888888
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Philogy",
                    "index": "87",
                    "likes": "0",
                    "time": "27/10/2022-22:41:11",
                    "content": "    wjmelements:  Again, this is the real problem, and transient storage is a band-aid.   How is transient a storage just a band-aid? Do you disagree that storage accessing opcodes cannot safely have the same cost as standalone transient storage opcodes? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.166666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wjmelements",
                    "index": "88",
                    "likes": "0",
                    "time": "27/10/2022-22:51:04",
                    "content": "    Philogy:  How is transient a storage just a band-aid?       EIP-1153: Transient storage opcodes Core EIPs       My initial impression was that this is worse than just making transient storage patterns cost-effective for SSTORE/SLOAD. But since we have to pay storage gas up-front, the larger issue is that REVERT does not refund (see EIP-3978).  I would rather the gas costs be fixed than for two opcodes to go toward this. The new opcodes won\u2019t fix existing gas injustices like UniswapV2\u2019s re-entry lock. These opcodes just create new complexity to isolate a small portion of new code from the problem, rather t\u2026         Philogy:  Do you disagree that storage accessing opcodes cannot safely have the same cost as standalone transient storage opcodes?   Yes (thought you shouldn\u2019t ask questions in the negative; it makes answers ambiguous) I don\u2019t see why UniswapV2\u2019s re-entry lock should cost more gas than equivalent transient opcodes (besides COLD_STORAGE_ACCESS). Neither change the state. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author is advertising proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.232954545454546
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Philogy",
                    "index": "89",
                    "likes": "2",
                    "time": "28/10/2022-12:34:46",
                    "content": "    wjmelements:  thought you shouldn\u2019t ask questions in the negative; it makes answers ambiguous   Ah my bad on the negative formulation. Here\u2019s why I believe that transient storage opcodes are necessary or at least a better approach to alternatives, let me know what you disagree with and why because I don\u2019t fully follow your argumentation so far:  The goal of good opcode gas pricing should be to fairly represent the practical runtime cost for nodes to process certain operations in the EVM Storage is persistent meaning that changing / reading from it requires expensive disk operations (I assume that the state trie is stored on disk for the most part) If you use persistent storage for transient storage you still have the overhead of at least reading from disk to ensure you\u2019re not changing state, this cost needs to be accounted for Conversely if you have dedicated transient storage operations you never have to worry about existing state at the beginning of a transaction, meaning you don\u2019t need to do any disk operations  So fundamentally, even if you allow for full refunds, dedicated transient storage operations can achieve a lower cost than using persistent storage for transient storage because with SLOAD / SSTORE you need to check you\u2019re not messing up some existing state. Concretely let\u2019s look at a reentrancy lock using storage and what operations need to be done:   Initial lock check (cold SLOAD): Read value from storage. Value at slot could\u2019ve already been set and thus disk needs to be checked. Cached after initial retrieval to reduce subsequent cost.  Changing the state of the lock (warm SSTORE, change from initial value): The storage value can only be changed in the cache initially, however saving it later may require a disk write, therefore gas needs to be charged upfront  Subsequent lock check upon reentrancy (warm SLOAD): Simply retrieve state from cache, low cost.  Resetting lock state after method execution completes  (warm SSTORE, value reverting): Only change state in cache. However by resetting to the original value a potential write to disk is averted, therefore the upfront gas cost can be refunded.  The example shows that even if you remove the cap on refunds there\u2019ll always be the cost of the cold SLOAD which needs to look at the state trie. Am I missing something? An alternative approach to dedicated transient storage opcodes would be to mark certain slots as transient via EOF or other opcode and then adjust the cost of the SLOAD / SSTORE if they\u2019re interacting with transient slots, however I don\u2019t like this approach as it packs even more complexity into the accounting and use of SSTORE / SLOAD which are already complicated enough on their own. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.284821428571429
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "90",
                    "likes": "0",
                    "time": "01/11/2022-21:57:56",
                    "content": "    chriseth:  resetting the transient storage of a contract whenever a call returns from the contract and the same contract is not in the current call stack. It would eliminate some other use cases, but it would feel much cleaner to me.   Definitely agree that something like this would be cleaner (but not exactly this, I think it\u2019s too complex). Starting to appreciate this perspective.     moodysalem:  this should be handled by the smart contract, not by the opcode, because it is trivial to handle within the smart contract.   Yes it can be trivially handled, but the point made by @chriseth is that it can also not be handled. The fact that it\u2019s optional creates a new ability that smart contracts do not have currently. Specifically, a contract will now be able to check if it has previously executed as part of the same transaction. (Update: I was wrong, this is not entirely new! It can already be implemented by abusing CREATE[2] and SELFDESTRUCT, though it would become impossible again after EIP-4758.) This is why Nikolai (rest in peace ) brought up TXID:     EIP-1153: Transient storage opcodes Core EIPs       Wouldn\u2019t TXID make more sense to start with\u2026 you can implement one with the other but not vice versa     I am personally a fan of transient storage and want to see it happen, but I haven\u2019t seen this newly enabled expressivity discussed in this thread except for Nikolai hinting at it, and I think it deserves more discussion. Another similar angle is that transient storage at the tx level breaks referential transparency. Although the EVM is stateful, CALL is surprisingly pure except for just a few bits of state, which would need to be extended to include transient storage according to the current proposal. An alternative design would only propagate transient storage \u201cdownwards\u201d but not \u201cupwards\u201d, i.e. reverting changes to it when returning from a call. Not sure if this alternative was discussed either. ",
                    "links": [
                        "https://github.com/ethereum/EIPs/issues/222"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party extending to proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.047718253968254
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "91",
                    "likes": "0",
                    "time": "08/11/2022-17:53:41",
                    "content": "Some use cases of transient storage EIP-1153 that work best with the transaction-level version of transient storage (rather than transient storage just for subcalls, which must use callbacks): ERC20 temporary approve: approve a spender for a single transaction Why not EIP-1363 approveAndCall? That requires the spender to support a callback or an intermediary contract which is more expensive and does not work well for approving multiple tokens KYC: call a kyc contract to verify your identity, and then call other KYC-gated functions on other contracts that also check you\u2019ve verified your identity in that transaction. This might be used with transient storage because you only want to prove your identity for a single transaction (rather than associate your identity to the account for all time, including e.g. after loss of a private key) NFT royalties or ERC20 fee-on-transfer: pay a fee to unlock transfers for that token ID or token amount for a single transaction. Other designs of FOT or NFT royalties break composability, e.g. fee on transfer tokens may take fees either from the recipient or the sender balance. This avoids the breakage due to transfer fees. Also allows fees to be paid by a third party or in a different token. If you propose everything should be a callback, you get callback hell. Imagine you want to temporarily approve an ERC20 to pay some NFT royalties to accept an offer on a KYC-gated NFT marketplace. Or, imagine that you want to approve 3 different tokens and then call into a contract. Both require 3 separate callbacks. How do you order them, and how do you construct calldata for passing through the several callbacks? How do you verify callbacks all came from the right contracts? Callbacks should be avoided unless necessary, and it\u2019s not accurate to say all these use cases are supported via callbacks in the subcall-only transient storage version. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.08843537414966
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/frangio",
                    "index": "92",
                    "likes": "0",
                    "time": "08/11/2022-21:12:40",
                    "content": "Yeah, while initially call-scoped transient storage sounded to me like it was just as good, because you can just use callbacks, I agree now that callbacks are not a good solution and tx-scoped transient storage would enable some valuable patterns to be implemented in a much nicer way. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.6875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "93",
                    "likes": "2",
                    "time": "09/11/2022-10:15:52",
                    "content": "At the risk of not making any friends here, I\u2019d like to voice some concerns about this from the Solidity perspective (beyond those already voiced by @chriseth above). While it may not be a huge effort to implement this on the execution layer in clients, this change induces a severe increase in the complexity of the semantics of the EVM that I\u2019m not sure is fully appreciated in the discussion so far. Just some points I haven\u2019t seen discussed exhaustively so far:  No matter what we do on the language level itself, in its current specification, this will be abused for in-memory mappings that are meant to be semantically call-local, but which will nonetheless bleed through on the transaction-level, which will increase the danger of reentrency bugs. In general (as others have commented already), I\u2019d expect transient storage to increase the complexity of any kind of static analysis and manual code analysis / auditing significantly. I\u2019d also expect the induced increase in semantic complexity and the reduction of the purity of EVM calls to cause pains for formal verification, in perpetuity. On the language level alone, we\u2019d need to consider whether transient storage warrants a new serialization format, which would significantly increase the complexity of the language semantics, and even if not, an additional data location means increasing the testing surface by an order of magnitude (the EVM already has an unhealthy amount of distinct data locations as is). In general, proper language support for this is non-trivial.  As far as use cases are concerned, transient storage still seems like a hacky catch-all solution to me - for reentrancy locks introducing an entire new address space of data is utter overkill; passing complex data structures between calls seems like an issue to be addressed in how calldata works instead; using it as a replacement for in-memory maps is downright dangerous etc. pp. All that being said, if this makes it to a hardfork, we will of course have no choice, but to implement support on the Solidity level - but I sincerely hope you have thought this through properly and properly consulted with all the affected parties before jumping at this - to me personally, to be honest, seeing given the state of the discussion, it seems a bit premature to be considering this a candidate for inclusion in Shanghai. EDIT: changing \u201cseeing\u201d to \u201cgiven\u201d since apparently otherwise it\u2019s assumed that I just saw this for the first time and am randomly commenting out of the blue. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.447214076246334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/leonardoalt",
                    "index": "94",
                    "likes": "0",
                    "time": "09/11/2022-11:42:30",
                    "content": "I don\u2019t have much else to contribute after @ekpyron\u2019s post. But honestly I think this is just so exaggerated. You\u2019re seriously listing KYC as a reason to change EVM semantics heavily? Regardless of whether it should go into any hard fork, it does look like the discussion has not taken into account all the potential problems this might bring. For the people championing the EIP, are you really sure that you\u2019ve thought through the problems mentioned above, and that you\u2019re actively fine with it instead of just ignoring it because it brings you the feature you want? I don\u2019t think more work for the clients and compilers is a problem per se, of course with progress come the changes and they need to be supported. But we need to be sure (or at least convinced) that this is for the good of the EVM, and not just a hack that will make a few happy and the EVM worse. edit: Just adding a final point: many of the listed problems will not go away by simply choosing \u201ctx level or call level or whatever else\u201d. There are clear pros and clear cons about transient storage. Those are likely not going to change. In the end there needs to be a decision on which outweighs which. Either the problems are too much, or we\u2019re fine with them given the pros we get. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.661666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "95",
                    "likes": "1",
                    "time": "09/11/2022-15:58:47",
                    "content": "Given the unanimous app developer support, it\u2019s quite silly for solidity compiler devs to join the discussion this late to tell their users they shouldn\u2019t have it for their own protection. It\u2019s the app developer\u2019s responsibility to ensure the security of the contracts they write, not the compiler or other tools, which is why the arguments that bugs could be written with it are unconvincing.     ekpyron:   No matter what we do on the language level itself, in its current specification, this will be abused for in-memory mappings that are meant to be semantically call-local, but which will nonetheless bleed through on the transaction-level, which will increase the danger of reentrency bugs.    It\u2019s still much more expensive than memory, and in my experience in-memory maps are rarely, if ever, useful in smart contracts. Especially maps costing as much as 100 gas per read/write. You are better off iterating over the entire list up to a certain size of list for 50+ entries. So, yes you\u2019re right, but it\u2019s almost never useful, so this particular concern is insignificant in comparison to all the other ways you can be vulnerable to reentrancy.     ekpyron:   In general (as others have commented already), I\u2019d expect transient storage to increase the complexity of any kind of static analysis and manual code analysis / auditing significantly.    Very general concern, please provide examples. Having written and read code that uses transient storage possibly more than anyone so far I don\u2019t think it makes code any harder to read, audit, etc\u2026 It\u2019s exactly the same as regular storage, you either clear it at the end of a transaction or very intentionally don\u2019t clear it for future calls. Forgetting to clear transient storage has the same reentrancy issues as forgetting to clear regular storage used transiently. It\u2019s not actually a reentrance bug that in a later transaction the slots were 0 again (although it may cause some other kind of bug, depending on your use case).     ekpyron:   I\u2019d also expect the induced increase in semantic complexity and the reduction of the purity of EVM calls to cause pains for formal verification, in perpetuity.    \u201cReduction of purity\u201d, could you explain? And please be specific with the pains it causes? My experience with formal verification, having tried to do FV with Uniswap V3, is that it\u2019s already impractical for stateful contracts. That said, the difference here is now you have to consider subsequent calls across transactions as well as subsequent calls in the same transaction. Meaning transient storage slots can either have a value set from a previous transaction (same as storage) or 0 values at the beginning of a transaction. That doesn\u2019t seem like a huge difference, and it won\u2019t even matter for contracts where formal verification is actually practical.     ekpyron:  In general, proper language support for this is non-trivial.   It depends heavily on your current abstraction, according to @big_tech_sux on Twitter it was added to Vyper in ~20 lines of code.     ekpyron:  As far as use cases are concerned, transient storage still seems like a hacky catch-all solution to me - for reentrancy locks introducing an entire new address space of data is utter overkill; passing complex data structures between calls seems like an issue to be addressed in how calldata works instead; using it as a replacement for in-memory maps is downright dangerous etc. pp.   Do the storage refunds used for this today strike you as elegant? Considering they have a 20% cap, in order to get rid of gas token, and you still have to read from storage a value that is always 0? Please suggest an alternate solution if you are going to call this one overkill. I would love to support a simpler solution that supports the required use cases, enables parallel execution, allows simplification of storage refunds, etc.     ekpyron:  to me personally, to be honest, seeing the state of the discussion, it seems a bit premature to be considering this a candidate for inclusion in Shanghai.   I\u2019ve championed for this since late last year, discussed with @ethchris as early as February this year. It\u2019s a bit late to be getting up to speed publicly on the discussion, as your concerns are more premature than the EIP. The EIP is already implemented in several clients with passing comprehensive cross-functional EVM tests. Last I checked it\u2019s further along in terms of implementation and specification than any other Shanghai CFI EIP. There have been many opportunities to suggest alternatives (to transient storage specifically) from the core solidity team, and I still haven\u2019t seen any suggested from the team. Asking that you please provide specific examples and solutions in your feedback, rather than general concerns at this point. ",
                    "links": [
                        "https://twitter.com/big_tech_sux/status/1551696396352425984"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.356772394272395
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/leonardoalt",
                    "index": "96",
                    "likes": "1",
                    "time": "09/11/2022-16:12:29",
                    "content": " Given the unanimous app developer support  Unanimous? So you asked literally everyone?  it\u2019s quite silly for solidity compiler devs to join the discussion this late to tell their users they shouldn\u2019t have it for their own protection  This is disingenuous and borderline disrespectful. This is an open discussion and anyone is entitled to share their opinion at any point in time.  it was added to Vyper in ~20 lines of code.  Have you actually verified that? Here\u2019s the commit that added it:   GitHub    Comparing master...transient \u00b7 vyperlang/vyper Pythonic Smart Contract Language for the EVM. Contribute to vyperlang/vyper development by creating an account on GitHub.       Yes, 20 lines of code, but not a single test. I checked the tests directory, not a single reference to transient. That may be fine for a PoC, but doesn\u2019t look ready for production imho. (which is ofc understandable, to not add full support until it\u2019s actually confirmed)  It\u2019s a bit late to be getting up to speed publicly on the discussion  Why are you trying to gatekeep this discussion? I disagree that the concerns are more premature than the EIP, since a few haven\u2019t even been properly answered to, only conveniently \u201cforgotten\u201d, as seems to be a common way of getting rid of EIP criticism. The EIP being implemented in different clients is probably a requirement but it\u2019s far from being sufficient for something to go in, is it not?  There have been many opportunities to suggest alternatives (to transient storage specifically) from the core solidity team  Why should the Solidity team have to provide better alternatives to it? At this point a few members are simply voicing unresolved concerns that may worsen the EVM, and your attempt to call them \u201cresolved\u201d and say \u201cit\u2019s too late\u201d is weird, to say the least. None of us here get to make those decisions alone. ",
                    "links": [
                        "https://github.com/vyperlang/vyper/compare/master...transient"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.231922398589065
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "97",
                    "likes": "1",
                    "time": "09/11/2022-16:18:26",
                    "content": "It\u2019s rather silly to claim that this it\u2019s late for bringing this up, if for example the issue for static analysis has come up as early as 2018 (EIP-1153: Transient storage opcodes - #25 by Arachnid). Issues don\u2019t just vanish if ignored. Same goes for @chriseth\u2019s concerns. As for the reduction in the purity of EVM calls @frangio explained that already above. As for non-trivial language support: I can of course hack in support of the opcode in a few lines of code without tests, we have a PR doing the same, that doesn\u2019t mean that it suddenly becomes a properly tested high-level language construct just like that. But as @leonardoalt already pointed out, implementational difficulty is not the major issue here, I\u2019d just want to clarify that considering that to be trivial is a misrepresentation. And, of course, compiler developers, static analysis and formal verification are major parts in smart contract security and should of course be consulted in evaluating such a change that, after all, targets to become a high-level language construct. Are there any statements of these changes not causing issues and being perfectly fine and manageable from people doing static analysis or formal verification or auditors? My main point is that a change like this IMHO requires active positive confirmation from these parties and I don\u2019t see any of that. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.3104901051329625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "98",
                    "likes": "0",
                    "time": "09/11/2022-17:00:42",
                    "content": "    leonardoalt:  Unanimous? So you asked literally everyone?   Lists of developers that are in support here and here. Mark Tyneway from Optimism as well as Arbitrum (posted above, also consulted DZack23 on twitter) are in support. If you don\u2019t consider the developers that are writing the code responsible for the majority of the Ethereum chain usage \u2018unanimous\u2019, I don\u2019t know what to tell you. If you haven\u2019t seen these lists before, then that\u2019s exactly my point about joining the discussion late.     leonardoalt:  This is disingenuous and borderline disrespectful. This is an open discussion and anyone is entitled to share their opinion at any point in time.   I\u2019m pointing out that if you are saying it\u2019s a question of tradeoffs, you should give more weight to user feedback     leonardoalt:  Why are you trying to gatekeep this discussion? I disagree that the concerns are more premature than the EIP, since a few haven\u2019t even been properly answered to, only conveniently \u201cforgotten\u201d, as seems to be a common way of getting rid of EIP criticism. The EIP being implemented in different clients is probably a requirement but it\u2019s far from being sufficient for something to go in, is it not?   I am asking you to get up to speed privately and then post examples and specific feedback, rather than general concerns. I have responded to every single point in @ekpyron\u2019s post as well as @ethchris\u2019s, that\u2019s pretty far from gatekeeping the discussion I think. An open discussion is not the same as an open and productive discussion.     ekpyron:  if for example the issue for static analysis has come up as early as 2018 (EIP-1153: Transient storage opcodes - #25 by Arachnid).   From Nick in July 2022.  Screenshot 2022-11-09 at 11.37.03 AM1174\u00d72054 295 KB  From @frangio about static analysis https://twitter.com/frangio_/status/1589372426135011329  Screenshot 2022-11-09 at 11.55.13 AM1130\u00d7248 56.8 KB      ekpyron:  Are there any statements of these changes not causing issues and being perfectly fine and manageable from people doing static analysis or formal verification or auditors? My main point is that a change like this IMHO requires active positive confirmation from these parties and I don\u2019t see any of that.   I will seek more out. Anyone in particular you want to hear from? ",
                    "links": [
                        "https://github.com/ethereum/pm/issues/450#issuecomment-1077935239",
                        "https://ethereum-magicians.org/t/eip-1153-transient-storage-opcodes/553/25",
                        "https://ethereum-magicians.org/uploads/default/original/2X/e/ed1a61091049806494045849956e5c66012664e1.png",
                        "https://twitter.com/frangio_/status/1589372426135011329",
                        "https://ethereum-magicians.org/uploads/default/original/2X/f/ff23fb82d8cfd75fc8aa6255e54b345c43c4cb6f.png"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.628517316017316
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/leonardoalt",
                    "index": "99",
                    "likes": "0",
                    "time": "09/11/2022-17:40:13",
                    "content": "    moodysalem:  If you don\u2019t consider the developers that are writing the code responsible for the majority of the Ethereum chain usage \u2018unanimous   Is everyone aware of the potential problems, new complexity etc and are OK with that, or just interested in gas savings? Ofc I can\u2019t say for sure either way, and won\u2019t assume, but tweets that likely didn\u2019t warrant the proper diligence rather sounds like the latter. Also the software like clients and compilers adding code support to them doesn\u2019t mean support for it getting in, as can be seen with the Solidity PR also being there.     moodysalem:  I\u2019m pointing out that if you are saying it\u2019s a question of tradeoffs, you should give more weight to user feedback   Huh? Why is that?     moodysalem:  From Nick in July 2022.       moodysalem:  From @frangio about static analysis https://twitter.com/frangio_/status/1589372426135011329   With all the deserved due respect to Nick and Frangio, screenshots of texts and single sentences of the form \u201csounds simple\u201d hardly show diligence. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.636177624458875
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "100",
                    "likes": "0",
                    "time": "09/11/2022-17:42:11",
                    "content": "I\u2019d for example be interested in the position of people working with formal EVM semantics, like e.g. Runtime Verification, or such. Carrying another kind of state with different semantics through calls of course adds to complexity there. Be it manual or not, it basically doubles the effort to prove invariants of a smart contract, since they\u2019re contingent on the position in a transaction call chain. Is all of that managable? Theoretically, sure. Is it trivial? Depending on what you do maybe, maybe very much not. Is that enough reason for being sceptical about this EIP? For me it is, in general it may, but doesn\u2019t have to be. But anyways, I actually don\u2019t quite understand the aggressiveness. Of course, I\u2019m aware of this having the support of application developers - but that doesn\u2019t mean that it has to universally be considered as a good move (especially in any fixed particular variant). As for memory mappings: I\u2019ve even seen this mentioned as use case and I think you\u2019re underestimating the cost of iterating lists. I don\u2019t see the cost as the limiting factor here, until it\u2019s basically back at a cold storage read of a zero - a reduction of the address space would be, either for the opcodes or with the EOF-based marking of storage slots as alternatives. Storage repricing and refund adjustments are also still alternatives that have come up often. Which are complex and not nice, sure, but for modelling storage not merely as disk space, but as cached disk space, which accurately reflects what happens in clients, I don\u2019t see them going anywhere regardless. Would also be interested how this could no longer or better be done with Verkle trees. In any case, I\u2019m mainly pointing out that this EIP doesn\u2019t only have fans (and the response IMHO actually reaffirms that this is more than necessary). It\u2019s not like you will and have to have unanimous support in the end, but as I said originally, I hope the decision takes the price of this in terms of complexity into account (which surely is unarguably not just zero :-)). ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None",
                        "None",
                        "None"
                    ],
                    "Sentiment": 5.774302721088436
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/leonardoalt",
                    "index": "101",
                    "likes": "0",
                    "time": "09/11/2022-18:50:13",
                    "content": "    leonardoalt:  Is everyone aware of the potential problems, new complexity etc and are OK with that, or just  interested in gas savings?   To clarify: This by no means intends to disqualify anyone\u2019s opinions. Everyone on the \u201csupport\u201d list is ofc 100% knowledgeable and capable of judging this. However I do believe that scattered support like screenshots and tweets are different from structured support, but that\u2019s just my opinion. I\u2019m completely fine with being on the \u201cwrong\u201d side here  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.0956439393939394
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "102",
                    "likes": "0",
                    "time": "09/11/2022-21:39:40",
                    "content": "    ekpyron:  As for memory mappings: I\u2019ve even seen this mentioned as use case and I think you\u2019re underestimating the cost of iterating lists. I don\u2019t see the cost as the limiting factor here, until it\u2019s basically back at a cold storage read of a zero - a reduction of the address space would be, either for the opcodes or with the EOF-based marking of storage slots as alternatives.   Probably closer to 10 than 50, but when was the last time you saw the need for an in-memory map in solidity? Particularly one with any size? I don\u2019t expect this to practically be used solely for in-memory maps, but regardless you can always clear the entries in the map before the end of the call.     ekpyron:  Storage repricing and refund adjustments are also still alternatives that have come up often. Which are complex and not nice, sure, but for modelling storage not merely as disk space, but as cached disk space, which accurately reflects what happens in clients, I don\u2019t see them going anywhere regardless. Would also be interested how this could no longer or better be done with Verkle trees.   You can\u2019t reprice out a wasted storage load for a value that is always known to be 0 at the beginning of a transaction. @Philogy explains this rationale a few posts above. If you\u2019re marking some storage slots as transient via EOF, what is the practical difference? It seems to have all the same issues, except you can\u2019t tell from the opcode alone if it\u2019s a transient slot or not, so it seems even harder to analyze. Edit: furthermore, you cannot have mappings with keys that are determined at runtime (e.g. token addresses). Storage refunds may stick around for original-new-original writes, but not necessarily zero-nonzero-zero writes if transient storage is available. This simplification alone would make storage refunds much easier to talk about since it removes a branching condition. Alternately, with transient storage, SSTORE/SLOAD pricing could be made completely dumb about caching and the contract can use a TSTORE/TLOAD mapping to move it to the application layer. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.15719696969697
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "103",
                    "likes": "0",
                    "time": "09/11/2022-22:12:17",
                    "content": "As for storage pricing and refunds: the main point there is that you\u2019re left with one cold load no matter what refunds and whatnot, right? Can a cold load from a full zero page in verkle trees be cheaper as well, hence allowing for reserving full pages as transient storage? Honestly, I have no idea, maybe not. Maybe even if, it\u2019s messy and not a good idea to go that way. But that\u2019s not my area of expertise. But the advantage of this direction is that the clearing is fully explicit and the EVM semantics stays simpler and there\u2019s no implications for composability as Chris hinted at. (Of course at the cost of more complex gas accounting no matter what, but that complexity is actually less relevant for analysis and FV, since you can usually assume to have enough gas for that purpose anyways) As for memory mappings: A full loop iteration for iterating a list I\u2019d guess at 10-20 gas, so worst case you\u2019re at 100 with 5 to 10 elements, average case 10 to 20 - that\u2019s not a long way. (Granted that\u2019s only comparing reading the thing, and writing to it before would be quite more costly in a transient storage version as well) But anyways, of course you don\u2019t see memory maps around now, since they\u2019re costly and a pain to implement right now - which may change with the ability of abusing transient storage for them, that\u2019s the main point :-). And if you did that, clearing the map is actually the costly part (since then you need to keep and traverse a list of keys), so you\u2019re not unlikely to not do that. (and I mean, implementing cheap memory mappings in actual memory has been requested from us, it\u2019s just not feasible with current memory design, but it\u2019s not too crazy of a concept in general) Maybe that concern is ultimately unwarranted, but I\u2019d maintain that it\u2019s a valid concern in any case. To avoid this issue alone, restricting the address space would help. I.e. if I just don\u2019t have enough transient storage available (either by restricting the address range of transient storage explicitly or implicitly by it only being possible to mark a low count of storage slots as transient via EOF), I can\u2019t abuse it in this way. On the other hand, one of the use cases I\u2019ve read also appears to be passing complex data structures like mappings through calls, it\u2019s probably impossible to keep that and prevent the abuse as call-local mappings at the same time (personally, I\u2019d still argue that passing data around like that would be better done with more flexible calldata in principle, but anyways). What marking slots in EOF indeed doesn\u2019t account for either is the increase in semantic complexity, that stays the same and is a clear gaping con of transient storage in general. It may be valid to conclude that the pros outweigh this - I\u2019m personally not convinced by that, but I can relate to the opposite position. The fact that this doesn\u2019t even occur in the list of relative cons of the EIP and I don\u2019t exactly see it conceded as a valid concern, made me worry if it is even properly weighed in at all, though. (Also not entirely sure if people doing FV would appreciate a position of basically \u201cFV is too hard anyways, so it doesn\u2019t matter if it gets even harder\u201d ;-)) ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.093619465329992
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "104",
                    "likes": "0",
                    "time": "09/11/2022-22:56:59",
                    "content": "But yeah, wrt memory mappings I guess you can get away with \u201cwell, then people just shouldn\u2019t be doing that\u201d and maybe that\u2019s fair enough. Wrt static analysis, auditing and FV, I\u2019d at least want to make sure that this is given sufficient thought, since transient storage will make things more complex - that can\u2019t just be denied entirely, can it? If that\u2019s generally deemed worthwhile, that doesn\u2019t make me happy, but is also fair - it just should be properly considered at all IMHO. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 6.403846153846153
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ehildenb",
                    "index": "105",
                    "likes": "4",
                    "time": "09/11/2022-23:28:45",
                    "content": "    frangio:  As far as I can tell, the \u201creal problem\u201d is that storage is fundamentally a persistent data structure and resource, and using it for transient purposes is almost guranteed to be inefficient.       Philogy:  An alternative approach to dedicated transient storage opcodes would be to mark certain slots as transient via EOF or other opcode and then adjust the cost of the SLOAD / SSTORE if they\u2019re interacting with transient slots, however I don\u2019t like this approach as it packs even more complexity into the accounting and use of SSTORE / SLOAD which are already complicated enough on their own.   These two posts basically sum up my feelings on the issue. The goal here is to provide a fundamentally different memory region, with different scoping, longevity, and pricing than any existing memory region? Then it should be a separate memory region, rather than leaving it up to the clients to cache smarter. I am fairly confident this will not be hard to implement in KEVM (client that RV maintains), and I don\u2019t think it will increase the complexity of verification using KEVM significantly. I can\u2019t speak for other tools. I think with good usage of this feature, it may even reduce the complexity of some verification efforts (many variables you\u2019ll be able to tell immediately that they cannot alias, for example, or if an entire modifier only uses transient variables, maybe we can have modular verification of the modifier more easily?). It seems to me as well that it is not too much complexity for clients, because several clients have been modified to handle this new opcode, and tests have been provided (though maybe this could have been done earlier in the discussion, I know that having tests increases my confidence quite a bit: EIP-1153: Transient Storage tests by moodysalem \u00b7 Pull Request #1091 \u00b7 ethereum/tests \u00b7 GitHub). That being said, I cannot speak for other tools. Our semantics and verification is based on symbolic execution, which is different than other tools. I also can\u2019t speak for the Solidity compiler, but does the Solidity compiler need to support the feature immediately? Can we let devs use inline assembly, let a few examples of how it\u2019s being used trickle in, then give people the version of the feature that has compiler-guaranteed guardrails in place? The first users of the feature, whether via the Solidity compiler or not, are going to be taking the brunt of risk here (risk of not understanding the new feature correctly, or risk of Solidity compiler behaving unexpectedly on the new feature). I am usually a fan of the \u201cgive the devs tools, and let them figure out how to not shoot themselves in the foot\u201d approach. I do think that the devs opinions here are more valuable than my own opinion, they are the ones trying to innovate here. Also shoutout to @pcaversaccio for the diagram, I find these types of visualizations very helpful.  image1670\u00d7986 121 KB  ",
                    "links": [
                        "https://ethereum-magicians.org/uploads/default/original/2X/9/9256975279e9dc957137229477519b63e44ccb25.png"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party or author wants to collaborate on proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.755561568061568
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ekpyron",
                    "index": "106",
                    "likes": "0",
                    "time": "09/11/2022-23:34:55",
                    "content": "Ok, fair enough. And sure, we can provide plain assembly support immediately, properly optimizing may take a bit longer, high-level language support a bit longer still, but we can manage, I\u2019m not so much concerned with that, but with the complexity of the language semantics that inherits the increase of the complexity of the EVM semantics. But if this is deemed a non-concern, I consider myself beat on this. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 6.204081632653061
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/ehildenb",
                    "index": "107",
                    "likes": "2",
                    "time": "09/11/2022-23:44:03",
                    "content": "I do think it will be easy to make pathological hard-to-analyze code here. But I don\u2019t think these types of examples are what people will be trying to do formal verification on, and I think you could make the same or similar examples using normal storage. Double-edged sword I guess. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.729166666666666
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "108",
                    "likes": "1",
                    "time": "10/11/2022-15:08:33",
                    "content": " If the TSTORE opcode is called within the context of a STATICCALL, the call must revert.  This is different wording than how STATICCALL handles writes in static contexts as defined in EIP-214. Is the behaviour intended to be different? ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.833333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "109",
                    "likes": "0",
                    "time": "10/11/2022-15:16:48",
                    "content": "    SamWilsn:  This is different wording than how STATICCALL handles writes in static contexts as defined in EIP-214. Is the behaviour intended to be different?   It\u2019s not intended to be different, and I can adjust to this if it sounds more accurate:  If the TSTORE opcode is called within the context of a STATICCALL, it will result in an exception instead of performing the modification.  ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.166666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "110",
                    "likes": "1",
                    "time": "10/11/2022-15:19:42",
                    "content": "I\u2019d certainly appreciate it, but I\u2019m also a pedant ;3 ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.071428571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wbl",
                    "index": "111",
                    "likes": "1",
                    "time": "14/11/2022-17:29:04",
                    "content": "    ekpyron:  I\u2019m not so much concerned with that, but with the complexity of the language semantics that inherits the increase of the complexity of the EVM semantics.   I don\u2019t think the language semantics get much messier: this storage behaves the same as indexing a variable by the transaction. Now the transaction hasn\u2019t appeared before, so symbolic analysis based on model exploration will have to change, but it doesn\u2019t seem to me to be that bad. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 4.625
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/poojaranjan",
                    "index": "112",
                    "likes": "2",
                    "time": "01/12/2022-19:55:30",
                    "content": "PEEPanEIP #91: EIP-1153: Transient storage opcodes with @moodysalem     ",
                    "links": [
                        "https://www.youtube.com/watch?v=9YMEYTzzKtI"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "113",
                    "likes": "2",
                    "time": "03/12/2022-07:29:21",
                    "content": "So I spoke about this at some length with @moodysalem this week and I want to say I do support this proposal in principle. Here\u2019s why: since transactions are the unit of atomicity in the EVM, it makes sense to have a data location which is also transaction scoped. It allows the developer to \u201creason about transaction atomicity\u201d, which, as demonstrated by both the existence of reentrancy bugs and techniques to deal with them, is an extremely useful thing to be able to reason about. (In fact, one could argue that memory should have been transaction-scoped to begin with, although it\u2019s a bit late for that). By way of example, another use-case this enables is \u201ccritical sections\u201d - scoped sections of code which, while entered, do not allow reentrancy into the contract at all (via checking a transient storage slot before entering the selector table). This is possible with regular storage of course, but it incurs the cost of an SLOAD at every single call to the contract. So if you think of transient storage as a tool for reasoning about transactions, transient storage not clearing after every call might be a feature, not a bug, since you can trace information about a txn (ex. how many times a contract has been called in a particular txn \u2013 which, if I am not mistaken, is not currently possible with existing opcodes in the EVM). I do think that the concerns voiced about making it potentially harder to reason about contracts are valid! But maybe the complexity is a basic complexity of smart contract development that needs to be reasoned about anyway, and by adding this data location to the EVM we are just making it explicit. I do have the issues with the API that I voiced above. I also think \u201ctransient storage\u201d is a confusing name, since the scope of the data is much more like memory than storage as far as most programmers would be concerned - the whole point of the proposal is that data is never \u201cstored\u201d to disk. A better name might be \u201clong-lived memory\u201d or simply \u201ctransaction-scoped memory\u201d. Lastly, I am unconvinced that this proposal is strictly better than other proposals which provide some sort of transaction scoping, for instance the TXID proposal from Nikolai (rest in peace). I haven\u2019t considered the alternatives long enough. But this proposal may indeed be the happy middle ground in terms of usability and the use-cases it enables. As far as language implementation goes, Vyper team is happy to support it at the language level. As has been pointed out, our existing implementation is a PoC. In principle, it works! And you can probably use it to try out the feature! But we will not officially release as a language feature or put the level of effort necessary for production until the EIP is scheduled for a fork. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.818253968253968
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/charles-cooper",
                    "index": "114",
                    "likes": "1",
                    "time": "03/12/2022-07:49:49",
                    "content": "I think using transient storage for \u201cmemory\u201d mappings just because it has different addressing semantics from actual memory is an anti-pattern that can and will lead to the type of bugs that several people have raised concerns about in this thread. As I mentioned before, the lack of memory mappings in SC languages so far is a language restriction, not a VM restriction. You can see that C, C++, Python, Java, Rust, etc., all manage to implement map data structures with linear, not associative memory. As a language implementer myself - I would prefer that transient storage addresses the same way as memory, and to provide memory mappings as a language feature instead of having people fall back to transient storage mappings. Ultimately - transient storage should be used for things that require transient storage, and memory should be used for things that require memory. I think here is where the abstraction might leak, if developers are reaching for transient storage because of its addressing semantics instead of its volatility semantics. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 5.071428571428571
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/wbl",
                    "index": "115",
                    "likes": "1",
                    "time": "06/12/2022-14:59:56",
                    "content": "I\u2019m not sure I really follow what these two messages say: I think the two points you want to make are that transient storage might not be the best name, and programmers reaching for this might be surprised by the semantics if they reach for it as an alternative to memory, so that we should change the transient storage semantics to match those of memory to avoid the temptation. I\u2019d personally be happy to consider renaming to \u201ctransaction-scoped storage\u201d if that conveys the intent better. I don\u2019t agree with changing the addressing model to match that of memory, especially not for the reason of mismatch leading people to misuse it. Fist compilers already have code generation that works with storage as addressed today, so it would be easy to take that code and have it output TSTORE TLOADs instead to interact with transient marked storage. Using something memorylike would be a higher lift, but I don\u2019t maintain a compiler so happy to be corrected on this point. I do definitely want to be able to do storage like things like put structures in there. You might say in the future we can do it with memory-like addressing, but that\u2019s not ready now. I don\u2019t think the temptation argument really works. If programmers want memory with storage-like addressing, the right solution is to give them what they want, not take away transaction-scoped storage for fear they will use it instead. They are adults capable of making their own tradeoff decisions and ending up with bugs as a result. There is a strong reason to use associative addressing in Ethereum, namely cost alignment. Computation in the EVM is expensive. Having contracts reimplement in EVM associative maps when the Go code has them much more efficiently is a mistake imho. We should expose operations that are useful with costs reflective of the actual implementation cost+evaluation costs, rather than require a number of expensive operation invocations to achieve the same result. I also think associative addressing avoids difficult allocation and reallocation problems that linear memory with its difficult sizes and costs for range spanned invites programs to run into. It\u2019s just easier for everyone. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "None of the topics listed match",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 5.866496598639456
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/souptacular",
                    "index": "116",
                    "likes": "1",
                    "time": "12/12/2022-18:23:18",
                    "content": "Can we get an update on both the client/EVM testing efforts and the DoS concerns that have been raised previously? I mentioned it on Twitter just now (literally a minute ago, so don\u2019t expect replies yet), but will leave the link in case anyone answers on there: https://twitter.com/hudsonjameson/status/1602366049911017496?s=20&t=6Dd1J9kgY8fBI2aEfOK8GA @holiman: Expressing DoS concerns in April: Shanghai Planning \u00b7 Issue #450 \u00b7 ethereum/pm \u00b7 GitHub @moodysalem\u2019s open PR with tests (seemingly just manual client tests, but has a few mention of DoS stuff): https://github.com/ethereum/tests/pull/1091 ",
                    "links": [
                        "https://github.com/ethereum/pm/issues/450#issuecomment-1085860500",
                        "https://github.com/ethereum/tests/pull/1091"
                    ],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.388888888888889
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/Philogy",
                    "index": "117",
                    "likes": "1",
                    "time": "16/12/2022-16:09:20",
                    "content": "The semantics of transient storage opcodes as proposed in their current state don\u2019t do anything that the existing storage opcodes don\u2019t already do in terms of node memory usage. They\u2019re both: bound to their respective accounts, persist across successful calls and lead to O(n) effort upon reverts. The main difference is that transient storage has a lower upfront gas cost due to it not needing to read / write to permanent storage. This means that unlike storage there can be a larger set of changes that may need to be reverted in total (the \u201cjournal\u201d). However this effort grows proportionally to the total amount of TSTOREs possible in one transaction, meaning it is / should be priced into the opcode. Based on the threads you shared this seems to be the main root of uncertainty around whether / not EIP1153 could be a DoS vector. If it does look like TSTORE is priced too low at 100 gas then arguably the SSTORE opcode\u2019s warm, dirty price should arguably also be changed. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.368589743589744
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "118",
                    "likes": "0",
                    "time": "27/12/2022-00:23:09",
                    "content": "    souptacular:  Can we get an update on both the client/EVM testing efforts and the DoS concerns that have been raised previously?       Philogy:  This means that unlike storage there can be a larger set of changes that may need to be reverted in total (the \u201cjournal\u201d). However this effort grows proportionally to the total amount of TSTOREs possible in one transaction, meaning it is / should be priced into the opcode. Based on the threads you shared this seems to be the main root of uncertainty around whether / not EIP1153 could be a DoS vector.   With how storage reverts are currently implemented in geth, any DoS issue that exists for TSTORE will also exist for SSTORE. However there is no DoS issue with geth. This is covered in the EIP text. There is also a test specifically for the worst case O(N) revert scenario in the etheruem/tests PR, which is run against all clients. We are pretty certain that there is no DoS issue, but having this on a multi-client testnet will allow us to further verify. The EIP is blocked from merging into 2/5 clients because it\u2019s not yet included in a HF. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal",
                        "None of the topics listed match"
                    ],
                    "Sentiment": 4.7564935064935066
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "119",
                    "likes": "0",
                    "time": "12/03/2023-21:13:48",
                    "content": "Documenting another use case for transient storage I stumbled upon: Add generic parameter to IBlockhashOracle interface \u00b7 Issue #15 \u00b7 paradigmxyz/zk-eth-rng \u00b7 GitHub This is similar to the fourth use case in the latest draft of the EIP:   Fee-on-transfer contracts: pay a fee to a token contract to unlock transfers for the duration of a transaction   More generally it might be stated:   Unlocking actions within the same transaction: a fee-on-transfer token contract might require a fee to be paid before unlocking a certain amount of token transfers, or a specific implementation of an oracle interface might require a proof to be submitted before a value can be read   Would appreciate feedback ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal",
                        "3rd party auditing and reviewing proposal"
                    ],
                    "Sentiment": 5.7023809523809526
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/0xJepsen",
                    "index": "120",
                    "likes": "0",
                    "time": "13/03/2023-23:35:38",
                    "content": "Hey, I am not sure i understand how using something like the weiroll VM would introduce security concerns? Couldn\u2019t you also just write an off-chain DSL for the calldata and map it however you like? We built something like the Weiroll VM for our needs of transient storage at Primitive and are happy with how it works. In fact because it is a FSM we can reason about it\u2019s correctness much more powerfully than we would if it was a new opcode. For Reference: GitHub - primitivefinance/portfolio: On-chain portfolio protocol for risk and liquidity management. and the FVM.sol is the file where make our own vm to handle these challenges. ",
                    "links": [],
                    "GPT-discussion-categories": [
                        "3rd party giving constructive criticism of proposal",
                        "3rd party asking questions about proposal"
                    ],
                    "Sentiment": 6.738636363636363
                }
            ]
        }
    ],
    "group_index": "1259"
}