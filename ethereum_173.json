{
    "poll_list": [],
    "discourse_list": [
        {
            "thread_link": "https://ethereum-magicians.org/t/eip-5792-wallet-function-call-api/11374",
            "title": "EIP-5792 - Wallet Function Call API ",
            "index": 11374,
            "category": [],
            "tags": [
                "NONE"
            ],
            "content": [
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "1",
                    "likes": "2",
                    "time": "18/10/2022-17:31:17",
                    "content": "Thread to discuss EIP-5792 ",
                    "links": [],
                    "GPT-summary": null,
                    "GPT-proposal-categories": null,
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "2",
                    "likes": "0",
                    "time": "18/10/2022-17:41:13",
                    "content": "Re @SamWilsn:  I don\u2019t like this design. It doesn\u2019t force interoperability between wallets. A bundle created with WalletA may or may not be usable with WalletB. I would suggest either:  I might be misunderstanding the comment, but I don\u2019t think interoperability between wallets of a specific bundle identifier is a specific goal of this (that is, if you have both Rainbow and Metamask with the same EOA imported, you should not expect dapps to have consistent transaction UX between connections of the two). It is assumed that each wallet will have its own address that has its own namespaced bundle identifiers ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.208333333333334
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "3",
                    "likes": "0",
                    "time": "18/10/2022-20:21:51",
                    "content": "Nope, you\u2019re understanding it correctly. If I have an EOA today, I can freely switch between wallet applications with no drawbacks. As a user, I can\u2019t support a standard that restricts that freedom (though as an EIP Editor, I can\u2019t stop the proposal.) Is it that difficult to standardize bundle identifiers? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.833333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "4",
                    "likes": "0",
                    "time": "18/10/2022-22:11:39",
                    "content": "    SamWilsn:  As a user, I can\u2019t support a standard that restricts that freedom   I agree that users should have mobility of their EOA between wallets. Both wallets should be able to import previous transaction history based on just the account. For dapp interfaces, e.g. Uniswap interface, this EIP should have no impact on the transaction history UX as long as you don\u2019t connect to a different wallet with the same address while a transaction is still pending. It seems like an edge case for a user to switch wallets for the same EOA while an interaction is pending.     SamWilsn:  Is it that difficult to standardize bundle identifiers?   It would not work for the dapp to specify the identifier for the bundle, because that could only be stored in the connected wallet, and would not sync between apps. You could use the hash of the message bundle, but when switching from wallet app A to wallet app B, wallet app B won\u2019t know the preimage of the bundle and cannot query it from anywhere (i.e. it cannot query it from a JSON RPC as it can do with a transaction hash). ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.87962962962963
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "5",
                    "likes": "0",
                    "time": "18/10/2022-23:00:48",
                    "content": "    moodysalem:  It seems like an edge case for a user to switch apps for the same EOA while an interaction is pending.   I use a different mobile wallet from my browser wallet. I don\u2019t think it\u2019s that inconceivable.     moodysalem:  It would not work for the dapp to specify the identifier for the bundle, because that could only be stored in the connected wallet, and would not sync between apps.   Could it not be embedded in the bundle itself?     moodysalem:  You could use the hash of the message bundle, but when switching from wallet app A to wallet app B, wallet app B won\u2019t know the preimage of the bundle and cannot query it from anywhere (i.e. it cannot query it from a JSON RPC as it can do with a transaction hash).   Hm, and I guess the bundle might not have a tx.origin of the EOA itself (say for 4337 style bundles.) We are defining a new standard here, so we could make a new RPC endpoint on clients that deals with transaction bundles, if you\u2019re interested in going that route. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.373376623376624
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "6",
                    "likes": "0",
                    "time": "19/10/2022-01:36:02",
                    "content": "    SamWilsn:  I use a different mobile wallet from my browser wallet. I don\u2019t think it\u2019s that inconceivable.   In this case you\u2019re using two different browsers, so the dapp doesn\u2019t remember your transaction across the two contexts anyway\u2013it\u2019s stored in the window.localStorage for Uniswap interface, which isn\u2019t synchronized across devices.  Could it not be embedded in the bundle itself?  Yes, you can put the dapp-selected identifier in the bundle, but that bundle + ID is not synced to other wallets, so other wallets won\u2019t know what function calls that dapp-selected bundle identifier corresponds to when queried about bundle status.  Hm, and I guess the bundle might not have a tx.origin of the EOA itself (say for 4337 style bundles.) We are defining a new standard here, so we could make a new RPC endpoint on clients that deals with transaction bundles, if you\u2019re interested in going that route.  I think this is purely a wallet JSON RPC method; it requires no P2P networking and no information about the state of the network. It\u2019s just giving the dapps a better way to communicate with wallets about bundles of function calls that actually represent an action (e.g. approve and swap) rather than individual transactions. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.418081918081919
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/sbacha",
                    "index": "7",
                    "likes": "0",
                    "time": "01/11/2022-16:40:43",
                    "content": "why no GraphQL support? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "8",
                    "likes": "1",
                    "time": "01/11/2022-18:52:23",
                    "content": "    SamWilsn:  Is it that difficult to standardize bundle identifiers?   I would also add that the fact that smart contract wallets would handle differently to eoa based wallets might make this even harder. for example for an eoa a bundle of multiple calls might result in multiple transactions, but for most smart contract based wallets that would only be 1 transaction. But for most smart contract based wallets the tx hash is calculated differently (e.g. the Safe uses a EIP-712 based hash). All of this makes it harder to create a standard for the bundle identifier. Harder doesn\u2019t mean impossible, but I don\u2019t think it is necessary for this EIP and could be handled in a follow up EIP to this one. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.095708020050125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "9",
                    "likes": "1",
                    "time": "01/11/2022-18:57:53",
                    "content": "Just as a general reference: There has been a similar proposal with discussion that can be found here ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.125
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "10",
                    "likes": "0",
                    "time": "01/11/2022-18:58:45",
                    "content": "Also could you elaborate why \u201cfunction call\u201d was used for the rpc name? For me \u201ccall\u201d implies a non-state-changing operation, which is kind of confusing for this rpc. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.333333333333333
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "11",
                    "likes": "0",
                    "time": "03/11/2022-19:16:06",
                    "content": "Open to name suggestions, just gave it the best name I could think of that wasn\u2019t overloaded (message is too ambiguous, bundles sounds like flashbots and needs qualifiers) but I think call is not usually meant as staticcall in most contexts. Separately, I\u2019m slightly concerned with the additional \u2018optional\u2019 qualifier in the current specification, perhaps that should be handled at the smart contract level. And anything more complex also, e.g. a dependency graph of function calls, should be expressed in the function that is called. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.040343915343915
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "12",
                    "likes": "0",
                    "time": "04/11/2022-08:43:54",
                    "content": "    moodysalem:  but I think call is not usually meant as staticcall in most contexts.   Agree that this is the semantic on contract/evm level. My comment was more related to RPC level (e.g. eth_call vs eth_sendTransaction). I mean in the end it is just a name \u2026 so not the most important thing :P. The only thing that for me in the name is important (and already is the case) is the wallet_ namespace  Personally I think there are 2 important points to push this EIP forward:  Get the right people involved   Wallet developers (e.g. add MM, Rainbow and Argent) SDK developers (e.g. WalletConnect, Ethers, Web3js and co) Some dapp developers (i.e. CowSwap and 1Inch are quite cooperative)   Align on the return type   As mentioned before, I don\u2019t think all the details have to be listed here, but I think it makes sense to have a plan how to move this forward. There will be many devs asking the same questions as @SamWilsn. I think a uri schema based id would make sense. E.g. safe:tx:<some_hash> or evm:tx:<normal_tx_hash>. This way it is easy to extend this (can be defined in separate EIPs) and could even be backwards compatible.  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 6.243849206349205
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/zemse",
                    "index": "13",
                    "likes": "2",
                    "time": "14/11/2022-10:05:11",
                    "content": "What is the best way to know whether the connected wallet supports batching? I assume it will need a try-catch based on the following text in the EIP.  Three new JSON-RPC methods are added. Dapps may begin using these methods immediately, falling back to eth_sendTransaction and eth_getTransactionReceipt when they are not available.  Knowing in advance whether a wallet supports batching can enable the frontend to show different UI. E.g. if batching not supported, Uniswap\u2019s frontend shows both \u201cApprove\u201d and \u201cSwap\u201d buttons, but if wallet supports batching, just a \u201cSwap\u201d button can be shown. What should be the behaviour of wallet_sendFunctionCallBundle with empty calls array? Would it fail or provide an id? (For check if RPC method is supported by wallet). ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.2102272727272725
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/rmeissner",
                    "index": "14",
                    "likes": "0",
                    "time": "14/11/2022-12:30:07",
                    "content": "    zemse:  Knowing in advance whether a wallet supports batching can enable the frontend to show different UI   I agree. It probably makes sense to have a separate rpc to get wallet capabilities. This could also be used for other rpc methods (e.g. related to signing; does a wallet support eip-712, etc.). Should this be part of this eip or would it make sense to create a separate one for that? ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.791666666666667
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "15",
                    "likes": "0",
                    "time": "14/11/2022-23:14:12",
                    "content": "    rmeissner:  Should this be part of this eip or would it make sense to create a separate one for that?   I would vote separate as it needs to support this and other RPCs, but also shouldn\u2019t be specific to wallets. Could just be a generic JSON RPC introspection endpoint, maybe returning an OpenRPC compliant response. I\u2019ve also had cases where I was curious whether a particular RPC endpoint supported an RPC (e.g. eth_getProof support is not well documented) But until such an endpoint exists, I think it\u2019s a good carrot for adoption for dapps to just call eth_sendTransaction multiple times in its error handler. If dapps have to support different flows depending on wallet implementation, you still end up with the complex branching in the (single digit number of) dapps that support batch transactions for account abstracted wallets today. However this might break existing wallets if one call is required by a subsequent call, as the second eth_sendTransaction may be expected to fail without accounting for the first. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.975074404761905
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "16",
                    "likes": "0",
                    "time": "14/11/2022-23:28:21",
                    "content": "    zemse:  What should be the behaviour of wallet_sendFunctionCallBundle with empty calls array? Would it fail or provide an id? (For check if RPC method is supported by wallet).   calls has a minItems of 1, implying that this should revert as a request validation error. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 3.5
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "17",
                    "likes": "0",
                    "time": "16/11/2022-19:01:52",
                    "content": "I\u2019d really like to see an option to specify the atomicity level of a bundle. For example:   \"atomicity\": \"none\" \u2192 Stop on first failed operation. Operations successfully executed so far MUST NOT be reverted.  \"atomicity\": \"loose\" \u2192 If any operations fail, none of the operations should happen (they should either revert or not appear on-chain.) This could be implemented for EOAs with flashbots. May lose atomicity in the face of reorgs.  \"atomicity\": \"strict\" \u2192 If any operations fail, all operations MUST either revert or never appear on-chain. Must remain atomic in the face of reorgs.  If the wallet is unable to satisfy the requirements, it should fail the RPC request with a well known error. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.361538461538461
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/dror",
                    "index": "18",
                    "likes": "0",
                    "time": "16/11/2022-19:40:18",
                    "content": "    SamWilsn:  \"atomicity\": \"strict\" \u2192 If any operations fail, operations MUST revert   This mode is possible when working with contract wallets, but not with EOA. For this API to be usable, it should have broad support for different wallets. Also, a helper library (e.g. a wrapper provider) should be provided to provide this API on top of existing wallet API. This provides both a reference implementation, and also an easy way for apps to work with providers whether they support the new API or not. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.4515692640692635
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "19",
                    "likes": "1",
                    "time": "16/11/2022-19:55:47",
                    "content": "    dror:  This mode is possible when working with contract wallets, but not with EOA.   Exactly. Wallets that don\u2019t support a particular atomicity level should fail the RPC request.     dror:  For this API to be usable, it should have broad support for different wallets.   While I don\u2019t disagree with you, I think for this API to actually get used in dapps, it needs to offer more than what you can do with plain JSON-RPC batching. I don\u2019t think \u201cindicating to users that a batch of operations is logically a single chunk\u201d is enough for dapps to write custom code for it. Pretty sure \"atomicity\": \"strict\" is already supported in smart contract wallets today though, so it would be nice to expose to dapps in a consistent way. It\u2019s possible to add support for this to EOAs as well, so if something like that ever happens, they\u2019ll be able to implement this too. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.6965939153439145
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/yoavw",
                    "index": "20",
                    "likes": "0",
                    "time": "16/11/2022-23:04:33",
                    "content": "I second @SamWilsn on \"atomicity\".  It makes sense for the dapp to specify whether it\u2019s a nice-to-have batching for saving gas (so none), frontrunning/sandwiching protection (that would be loose), or an actual security reason (strict). Most contract wallets, whether 4337 or not, as well as wallets using an EIP 3074 invoker, can support all three (and in practice they\u2019ll always provide strict because they\u2019ll batch everything to a single transaction). EOAs would return an error if strict, use Flashbots (or any other trusted mev-boost building service) for loose, and normal mempool transactions for none. Dapps should only use strict when there\u2019s a real reason, since some wallets won\u2019t support it. As for communicating the identifier when switching wallet (or using a 3rd party explorer to look at the bundle), I wonder if it would make sense to encode it on-chain in the 1st transaction of there\u2019s more than one.  One byte of calldata may be enough.  Contract wallets will always use one transaction, so no need to encode anything.  If from is an EOA, then we can assume consecutive nonces and therefore we only need to know the number of transactions in the bundle.  A uint8 appended to calldata of the first transaction should be enough for all practical purposes. The 2nd wallet will then decode the 1st transaction, parse the redundant byte, and check for the next N-1 transactions (either on-chain or in mempool). The caveat (aside from paying gas for the additional calldata byte) is that the 2nd wallet can only parse it if it knows the call\u2019s signature so that it can identify the appended byte as a non-parameter. I\u2019m not sure it\u2019s worth the hassle, and adding an on-chain component (however small).  Just seems like an easy way to identify bundles across wallets. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.256611721611721
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "21",
                    "likes": "0",
                    "time": "18/11/2022-15:06:05",
                    "content": "    yoavw:  Dapps should only use strict when there\u2019s a real reason, since some wallets won\u2019t support it.   My concern with the atomicity feature is that dapps will build things with this API that only work for the strict level of atomicity, which is bad for users of wallets that do not support it, i.e. the majority of Ethereum users today And anything that is strict can probably be made into none by just architecting the contract differently\u2013I can\u2019t think of a counterexample to this point. So there\u2019s no reason to actually require strict. strict is also a bit funky when the combined calls require more than block gas limit and must be sent as multiple transactions. Maybe there should be an additional specification that the request should reject if the wallet cannot make all the calls in a single block, or maybe we want to support that use case of many calls that must be made in separate blocks ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.238095238095238
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "22",
                    "likes": "0",
                    "time": "18/11/2022-20:25:38",
                    "content": "    moodysalem:  My concern with the atomicity feature is that dapps will build things with this API that only work for the strict level of atomicity, which is bad for users of wallets that do not support it, i.e. the majority of Ethereum users today   So those dapps will either struggle to get adoption from current Ethereum users, or build a fallback. I think it\u2019s better to standardize these features so that dapps using them will automatically support wallets adding atomicity instead of relying on bespoke integrations. Imagine I wrote a dapp today that needed strict atomicity, and I write code that supports Gnosis Safe using their API. I die and obviously am unable to continue updating my dapp. Some time passes, and we finally get EIP-3074. Now all wallets can implement support for strict atomicity, but my dapp is stuck only supporting Gnosis Safe.     moodysalem:  And anything that is strict can probably be made into none by just architecting the contract differently\u2013I can\u2019t think of a counterexample to this point. So there\u2019s no reason to actually require strict.   For sure! I\u2019m thinking of scenarios like complex DeFi arbitrage or rescuing NFTs from hacked accounts, where the transaction sender doesn\u2019t have control over what they\u2019re interacting with.     moodysalem:  strict is also a bit funky when the combined calls require more than block gas limit and must be sent as multiple transactions.   If a wallet can\u2019t ensure the operations are performed atomically (because it\u2019s an EOA, because of the gas limit, or for any other reason), the RPC call must fail. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.220588235294118
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "23",
                    "likes": "0",
                    "time": "20/11/2022-17:54:26",
                    "content": "    SamWilsn:  Imagine I wrote a dapp today that needed strict atomicity, and I write code that supports Gnosis Safe using their API. I die and obviously am unable to continue updating my dapp. Some time passes, and we finally get EIP-3074. Now all wallets can implement support for strict atomicity, but my dapp is stuck only supporting Gnosis Safe.   In absence of the strict atomicity request parameter, wouldn\u2019t you build your dapp and contracts to work for all wallets, i.e. using the default none behavior? In that case, all wallets would support it on day 0, and the UX for gnosis safe would be unchanged. The atomicity request parameter enables dapp developers to build dapps that are only supported by certain kinds of wallets, even though they could just build it for all wallets without sacrificing anything.     SamWilsn:  For sure! I\u2019m thinking of scenarios like complex DeFi arbitrage or rescuing NFTs from hacked accounts, where the transaction sender doesn\u2019t have control over what they\u2019re interacting with.   I think this is out of scope for this EIP, for a bunch of reasons in no particular order:  These use cases have more to do with using a private relay than bundling function calls E.g. in cases where a rescue does require multiple function calls in a single transaction, and there is no authorization, you can do that in the constructor of a contract deployment (no bundling necessary) This is a bespoke use case that is usually handled with scripting The mempool and sequencing behavior is closely related to the underlying blockchain, whereas this API is meant to abstract those details away from the dapp developer as much as possible The wallet can have a toggle to use a private relay without any change to the RPC interface      SamWilsn:  If a wallet can\u2019t ensure the operations are performed atomically (because it\u2019s an EOA, because of the gas limit, or for any other reason), the RPC call must fail.   This does push a lot of complexity onto the dapp in the rare case that the set of function calls costs more than block gas limit. It\u2019s nice for dapp developers to not have to worry about the total size of their batch. Wallets will also have different amounts of overhead for batch function calls, so dapps cannot predict the actual cost of sending the entire batch of function calls. But I wouldn\u2019t be strongly opposed to adding a constraint that the RPC fails if it would be impossible to include all the function calls under the block gas limit. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.2814250700280105
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/SamWilsn",
                    "index": "24",
                    "likes": "0",
                    "time": "21/11/2022-06:42:38",
                    "content": "    moodysalem:  In absence of the strict atomicity request parameter, wouldn\u2019t you build your dapp and contracts to work for all wallets, i.e. using the default none behavior?   It\u2019s possible today to build a dapp that relies on strict atomicity, but the specifics of how to do that are unique to each smart contract wallet. I\u2019d really like to see some standardization there.     moodysalem:  build it for all wallets without sacrificing anything   There are zero dapps that could be built with strict atomicity that could not be built without it?     moodysalem:  It\u2019s nice for dapp developers to not have to worry about the total size of their batch.   Agreed! For the \"atomicity\": \"none\" case, I think it\u2019s fine to split the batch over multiple blocks. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.996362433862434
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "25",
                    "likes": "0",
                    "time": "21/11/2022-15:13:28",
                    "content": "    SamWilsn:  There are zero dapps that could be built with strict atomicity that could not be built without it?   I believe so. Even if a smart contract is not EOA-friendly, it can always be wrapped. For example, consider an ERC20 without an #approve function. To spend this token you would have to call #transfer and then atomically call another contract. You can work around this: deploy a contract to hold the tokens, transfer the tokens to that contract, and then execute calls from the holder contract. For every example I can think of, there is a different pattern that does not require atomicity across the function calls. It might be possible to formally prove this point. Assuming the point is true, I don\u2019t think there\u2019s any reason for a dapp developer to build a feature that requires it, so the request parameter only acts as a footgun. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.564285714285714
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/DrewF",
                    "index": "26",
                    "likes": "0",
                    "time": "30/11/2022-22:18:26",
                    "content": "While it seems very likely that a contract that enforces strict atomicity can be constructed for every scenario, there\u2019s room for dapps to use the strict flag, even if it does fail. Dapp developers may want to optimistically enforce a strict bundle, and upon failure, ask the user to acknowledge the risk they will take by downgrading to \u2018loose\u2019 or no atomicity. If a Dapp presents a user with one button to click and sign multiple transactions, it seems like pretty poor UX if part of the call reverts. This is especially true for EOA users, whose current expectation is that each signature from their wallet results in one (atomic) transaction.     moodysalem:  For every example I can think of, there is a different pattern that does not require atomicity across the function calls. It might be possible to formally prove this point. Assuming the point is true, I don\u2019t think there\u2019s any reason for a dapp developer to build a feature that requires it, so the request parameter only acts as a footgun.   Instead of building an on-chain abstraction over every contract in the Dapp, developers can leverage account abstraction to create one-signature contract compositions for users (including for contracts that the dapp developer was unaware of, provided the user can import an ABI). Optimistically, the developer can request the bundle using \"atomicity\": \"strict\", then fall back to \"loose\" or \"none\" along with a warning and explanation that the atomic composition implied by the single signature for the queued transactions will be degraded. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 4.958252531781944
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "27",
                    "likes": "0",
                    "time": "01/12/2022-18:13:17",
                    "content": "    DrewF:  Dapp developers may want to optimistically enforce a strict bundle, and upon failure, ask the user to acknowledge the risk they will take by downgrading to \u2018loose\u2019 or no atomicity.   Can you share an example of when you\u2019d be ok with loose or no atomicity even though you wanted strict?     DrewF:  including for contracts that the dapp developer was unaware of, provided the user can import an ABI   This case sounds like it\u2019s not known by the dapp whether atomicity is needed or not, but that\u2019s a really advanced user and the user should specify the atomicity requirement in this case\u2026 but wouldn\u2019t they just not send these transactions separately if their wallet doesn\u2019t support it or do some other workaround? Seems like a slightly convoluted use case AFAICT ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.08613782051282
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/DrewF",
                    "index": "28",
                    "likes": "1",
                    "time": "01/12/2022-19:39:18",
                    "content": "The most concrete use case that came to mind was a block explorer with a transaction queue. If it provides users visiting with a way to visit a few contracts and build a set of transactions to execute, a naive user would probably expect the batch to execute together, especially with only one wallet signature for the full queue, and so the default behavior should be strict atomicity. I agree that the \u2018loose\u2019 atomicity is a rather weak construction, as it encourages users to route batches to private mempools, and feels like an abstraction leak that may change with underlying things like AUTH/AUTHCALL or single-slot finality. I\u2019d be happy to hear more arguments in it\u2019s favor, but having a bollean flag for enforcing all-or-nothing execution of a bundle seems like a good abstraction of underlying wallet mechanics for developers of tools like block explorers or general purpose contract interfaces.     moodysalem:  but that\u2019s a really advanced user and the user should specify the atomicity requirement in this case   I\u2019m operating under the assumption that as the EVM gets used by more people, competent early adopters will continue using EOAs, but new/less advanced users will onboard to accounts with features like atomic batching. I think we should make it easy for dapps to cater to them, and warn EOA users that \u201cthe bundle may only succeed in part or be split up, would you like to send the transactions anyway\u201d. Essentially I\u2019d like the line in the EIP  MAY revert all calls if any call fails  to instead be  MUST revert all calls if any call fails when \"atomic\": \"true\"  ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.756282051282051
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "29",
                    "likes": "1",
                    "time": "10/12/2022-20:17:09",
                    "content": "    DrewF:  and so the default behavior should be strict atomicity.   For something like complex transaction building (e.g. furucombo) you usually want to involve a smart contract to introduce logic between the calls (e.g. all or nothing, these 2 calls are optional, take output of this call and pass as input to another call). Furucombo still greatly benefits from this EIP because the spending approvals can be batched with the function calls you want to make. The one drawback is the calls do not come from the user\u2019s wallet. But I\u2019m not sure if support for that is really required for any meaningful transaction building use case. I\u2019m on the fence. I want this interface to be as narrow and abstract as possible so as to prevent dapps from building branching logic based on wallet capabilities, which either adds work for the dapp developer or excludes wallets. The \u201catomic\u201d flag definitely leaks wallet implementation details to the dapp. But if people are strongly in favor of this change I\u2019ll add it\u2013I\u2019m definitely more ok with atomic flag than 3 different levels of atomicity which feels even leakier.     DrewF:  competent early adopters will continue using EOAs, but new/less advanced users will onboard to accounts with features like atomic batching   My two cents on this is I\u2019d think early adopters will want account abstracted wallets for better security/recovery, or other features they offer. I myself am a user of a smart contract wallet, and many of my friends use gnosis safe for self custody. I\u2019m not sure if that changes the calculus.     DrewF:  Essentially I\u2019d like the line in the EIP   Yup, makes sense, totally get what\u2019s being asked for here. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.882097069597069
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/marc",
                    "index": "30",
                    "likes": "1",
                    "time": "25/01/2023-15:37:36",
                    "content": "Hey everyone, wanted to add that we have added support for EIP-5792 for CANDIDE mobile Wallet. We are supporting the three methods:  wallet_sendFunctionCallBundle wallet_getBundleStatus wallet_showBundleStatus  Here\u2019s our implementation for other wallet developers to reference:   github.com/candidelabs/candide-mobile-app         feat: support eip 5792           Commit by                     andrewwahid                  in         feat: support eip 5792   candidelabs:main \u2190 candidelabs:feat/support_eip_5792         Documentation for dapp developers wishing to support bundle calls in their app, along with a codesanbox to start experimenting with. We wrote examples for Web3Modal and WalletConnect Standalone:    docs.candidewallet.com   Batched Transactions | CANDIDE Docs Batched transactions allow you to perform multiple transactions in one single on-chain transaction      ",
                    "links": [
                        "https://github.com/candidelabs/candide-mobile-app/pull/53/commits/539f9b959577561eb4a6895f231315f92ceed4a4",
                        "https://github.com/andrewwahid",
                        "https://github.com/candidelabs/candide-mobile-app/pull/53/commits/539f9b959577561eb4a6895f231315f92ceed4a4",
                        "https://docs.candidewallet.com/develop/wallet/batch-transactions/",
                        "https://docs.candidewallet.com/develop/wallet/batch-transactions/"
                    ],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.0669642857142865
                },
                {
                    "author_link": "https://ethereum-magicians.org/u/moodysalem",
                    "index": "31",
                    "likes": "0",
                    "time": "30/01/2023-22:24:10",
                    "content": "    rmeissner:  I agree. It probably makes sense to have a separate rpc to get wallet capabilities. This could also be used for other rpc methods (e.g. related to signing; does a wallet support eip-712, etc.).   In the absence of this method, does it make sense to add one to the EIP just for checking if this particular set of methods is supported? Reviewing the guide posted by @marc and thinking about this again, I can\u2019t imagine implementing this in a mature dapp and falling back to multiple eth_sendTransaction calls as I originally proposed. There will need to be a transitional period where a dapp needs to support both existing wallet APIs well and the function call bundle API. Such a method could look like: wallet_isFunctionCallBundleSupported with no parameters, returns true if supported and errors or returns false if not supported. ",
                    "links": [],
                    "GPT-discussion-categories": null,
                    "Sentiment": 5.206439393939394
                }
            ]
        }
    ],
    "group_index": "173"
}